## 다익스트라 알고리즘
- 그래프에서 한 정점(노드)에서 다른 정점까지의 최단 경로를 구하는 알고리즘 중 하나다. 
- 이 과정에서 도착 정점 뿐만 아니라 모든 다른 정점까지 최단 경로로 방문하며 각 정점까지의 최단 경로를 모두 찾게 된다. 매번 최단 경로의 정점을 선택해 탐색을 반복하는 것
- 참고로 그래프 알고리즘 중 최소 비용을 구하는 데는 다익스트라 알고리즘 외에도 벨만-포드 알고리즘, 프로이드 워샬 알고리즘 등이 있다.
- 인공 위성 GPS 소프트웨어 등에서 가장 많이 사용되는 알고리즘이다. 
- 다익스트라 알고리즘이 다이나믹 프로그래밍인 이유는 " 최단 거리가 여러 개의 최단 거리 " 로 이루어져있기때문이다. 즉, 하나의 최단거리를 구할때, 이전까지 구했던 최단거리 정보를 그대로 사용한다.

### 다익스트라 동작 흐름
1. 출발 노드를 설정한다. 
2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장한다.
3. 현재 위치한 노드의 인접 노드 중 방문하지않은 노드를 구별하고 방문하지 않는 노드 중에서 가장 비용이 적은 노드를 선택한다. 방문한 노드는 방문 처리를 한다. 
4. 해당 노드를 거쳐 다른 노드로 넘어가는 간선 비용(가중치)을 고려하여 최소 비용을 갱신한다.
5. 위 과정에서 3~4번을 반복한다.  

- 동작 흐름에 따른 그림과 설명은 해당 링크를 참고 
- [다익크라 동작 흐림링크](https://velog.io/@717lumos/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

### 다익스트라 특징
- 다익스트라 알고리즘은 방문하지 않은 노드 중 최단 거리인 노드를 선택하는 과정을 반복한다. 
- 또한 각 단계마다 탐색 노드로 한번 선택된 노드는 최단거리를 갱신하고, 그 뒤에는 더 작은 값으로 다시 갱신되지않는다. 
- 도착 노드는 해당 노드를 거쳐 다른 노드로 가는 길을 찾을 필요는 없다.
- **다익스트라 알고리즘은 가중치가 양수일때만 사용가능하다.** 현실에서 간선이 음수일수가 없음으로 현실에서 쓰기에 적합한 알고리즘이다. 

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/500506308-ca12ca91-115f-41ea-bd7b-d9dad225f6c0.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251013%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251013T130127Z&X-Amz-Expires=300&X-Amz-Signature=d93402382f10bc77ee43f052ffb156d95c89ca84f5fce14eba0024db7cb58cb5&X-Amz-SignedHeaders=host)

- 위 그림의 상황에서 1 → 4의 경로가 최단경로이려면 3+k가 1보다 커야 한다. 
    - 즉, k > -2가 성립해야 한다. 
- 반대로 k가 -5라고 한다면 오히려 1 → 2 → 4 경로가 더 최단 경로가 된다. 
    - 그 말인 즉, 1번에서 연결된 노드 중 4번이 가중치가 적다는 이유로 최단 거리를 1이라 할 수는 없다는 이야기이다.
- 따라서 다익스트라 알고리즘을 사용하기 위해서는 정점 사이를 잇는 간선의 가중치가 **양수**여야 한다. 그래야 한 번 방문한 정점에 대해서는 값을 업데이트 하지 않아도 되는 것이다.

## 다익스트라 구현 방법
### 순차탐색

- '방문하지 않은 노드 중 거리값이 가장 작은 노드'를 선택해 다음 탐색 노드로 삼는데 이를 순차탐색으로 볼 수 있다. 
- 즉, 거리 테이블의 앞에서부터 찾아내야 하므로 노드의 개수만큼 순차 탐색을 수행해야 한다. 
    - 여기서 거리 테이블은 시작 노드로부터 각 노드까지의 최단 거리 정보를 저장하는 배열(또는 리스트)를 의미한다. 
- 배열의 처음 인덱스(0 또는 1)부터 마지막 인덱스(N−1 또는 N)까지 순서대로 모든 노드의 현재 거리 값을 확인한다. 이 중 아직 방문하지 않은 노드이면서 가장 작은 거리 값을 갖는 노드를 찾는다. 이런 방식은 배열의 원소를 하나씩 차례대로 검사하는 순차 탬색의 전형적인 방법이다. 
- 따라서 노드 개수가 N이라고 할 때 각 노드마다 최소 거리값을 갖는 노드를 선택해야 하는 순차 탐색이 수행되므로 (N−1)×N=O(N^2)의 시간이 걸린다. 이유는 다음과 같다.
    - 각 단계에서의 최소값 탐색: 다익스트라 알고리즘은 총 N번 (노드의 개수)의 반복을 수행하며, 각 반복마다 '방문하지 않은 노드 중 최소 거리 노드'를 선택해야 한다.
    - 순차 탐색의 비용: 이 최소 거리 노드를 찾기 위해 N개의 모든 노드(또는 남은 노드들)를 순차적으로 검사한다. 노드가 N개일 때 이 순차 탐색은 O(N)의 시간이 걸린다.
    - 총 시간 복잡도: N번의 반복 (외부 루프) × 각 반복마다 O(N)의 순차 탐색 (내부 작업) O(N×N)=O(N^2) 의 시간 복잡도가 발생하게 됩니다.

#### 자바 

- 아래의 코드에서 dist[]는 각 노드까지의 최단 거리를 저장하고, visited[]는 방문 여부를, map[][]은 한 노드에서 다른 노드로의 거리(가중치)를 저장하고 있다.

```
import java.util.Arrays;

public class DijkstraO_N2 {

    // 상수 정의 (무한대 값)
    private static final int INF = Integer.MAX_VALUE; 

    private int N;            // 노드의 개수
    private int start;        // 시작 노드 인덱스
    private int[][] map;      // 인접 행렬 (가중치 저장)
    private int[] dist;       // 시작 노드로부터의 최단 거리 테이블
    private boolean[] visited; // 방문 여부 체크 배열

    // 생성자: 필요한 변수 초기화 (N은 노드 개수, 노드 인덱스는 1부터 N까지 사용한다고 가정)
    public DijkstraO_N2(int N, int start, int[][] initialMap) {
        this.N = N;
        this.start = start;
        this.map = initialMap;
        this.dist = new int[N + 1]; // 인덱스 1부터 N까지 사용
        this.visited = new boolean[N + 1];
    }

    /**
     * 방문하지 않은 노드 중 가장 거리값이 작은 노드의 인덱스를 반환.O(N) 순차 탐색을 수행한다.
     * @return 최소 거리 노드의 인덱스. 없으면 -1 반환.
     */
    private int findSmallestNode() {
        int min_dist = INF;
        int min_idx = -1;
        
        // 1번 노드부터 N번 노드까지 순차 탐색
        for (int i = 1; i <= N; i++) {
            // 1. 이미 방문한 노드는 건너뜁니다.
            if (visited[i]) {
                continue;
            }
            
            // 2. 현재까지의 최소 거리보다 작다면 갱신한다.
            if (dist[i] < min_dist) {
                min_dist = dist[i];
                min_idx = i;
            }
        }
        return min_idx;
    }

    /**
     * 다익스트라 알고리즘을 수행하여 최단 거리를 계산한다.
     */
    public void dijkstra() {
        // 1. 거리 테이블 초기화
        // 시작 노드를 제외한 모든 노드의 거리를 시작 노드와의 초기 거리로 설정
        // 이 부분은 인접 행렬(map)을 사용한 원본 C++ 코드의 방식과 유사하게 구현
        for (int i = 1; i <= N; i++) {
            // 연결되지 않은 간선은 INF로, 연결된 간선은 가중치로 초기화
            dist[i] = map[start][i]; 
        }

        // 2. 시작 노드 초기 설정
        dist[start] = 0;       // 시작 노드까지의 거리는 0
        visited[start] = true; // 시작 노드 방문 처리

        // 3. N-1개의 다른 노드를 반복하며 선택
        // 이미 start 노드를 선택했으므로 N-1번 반복
        for (int i = 0; i < N - 1; i++) {
            // (1) O(N) 순차 탐색으로 최소 거리 노드 선택
            int new_node = findSmallestNode();
            
            // 더 이상 방문할 노드가 없으면 종료
            if (new_node == -1) break; 
            
            visited[new_node] = true; // 선택된 노드 방문 처리

            // (2) 선택된 노드와 인접한 노드의 거리 갱신
            for (int j = 1; j <= N; j++) {
                // 이미 방문했거나, 경로가 없거나 (map[new_node][j] == INF), 거리가 더 길면 갱신 안함
                if (visited[j] || map[new_node][j] == INF) {
                    continue;
                }
                
                // 기존 거리보다 new_node를 거쳐가는 거리가 더 짧으면 갱신
                if (dist[j] > dist[new_node] + map[new_node][j]) {
                    dist[j] = dist[new_node] + map[new_node][j];
                }
            }
        }
    }
    
    // 최종 거리 배열을 반환하는 메서드 (선택 사항)
    public int[] getDistances() {
        return dist;
    }

    // 예시 실행을 위한 main 메서드
    public static void main(String[] args) {
        // 노드 개수 (N=6), 노드 인덱스는 1부터 6까지 사용
        int N = 6; 
        int startNode = 1;
        
        // 인접 행렬 초기화: [i][j]는 i에서 j로 가는 가중치. INF는 연결 없음
        // 노드 0 인덱스는 사용하지 않음 (N+1 크기)
        int[][] graph = {
            {0, 0, 0, 0, 0, 0, 0},   // 0번 인덱스 더미
            {0, 0, 2, 5, 1, INF, INF}, // 1번 노드 (시작)
            {0, 2, 0, 3, 2, INF, INF}, // 2번 노드
            {0, 5, 3, 0, 3, 1, 5},   // 3번 노드
            {0, 1, 2, 3, 0, 1, INF}, // 4번 노드
            {0, INF, INF, 1, 1, 0, 2}, // 5번 노드
            {0, INF, INF, 5, INF, 2, 0}  // 6번 노드
        };

        // 연결이 없는 경우 INF (Integer.MAX_VALUE)로 설정
        // 0으로 된 부분(자기 자신)은 0으로 유지

        DijkstraO_N2 algorithm = new DijkstraO_N2(N, startNode, graph);
        algorithm.dijkstra();
        
        int[] finalDist = algorithm.getDistances();
        
        System.out.println("시작 노드 " + startNode + "로부터의 최단 거리:");
        // 1번 인덱스부터 N번 인덱스까지 출력
        for (int i = 1; i <= N; i++) {
            String distance = (finalDist[i] == INF) ? "INF" : String.valueOf(finalDist[i]);
            System.out.println("노드 " + i + ": " + distance);
        }
        // 
    }
}
```

#### 파이썬

```
# 무한대 값을 표현하기 위한 상수
INF = float('inf')

class DijkstraON2:
    def __init__(self, N, start, graph):
        """
        :param N: 노드의 총 개수 (노드 인덱스는 1부터 N까지 사용)
        :param start: 시작 노드 인덱스
        :param graph: 인접 행렬 (graph[i][j]는 i에서 j로 가는 가중치)
        """
        self.N = N
        self.start = start
        self.graph = graph
        
        # 거리 테이블 (1부터 N까지 사용)
        self.dist = [INF] * (N + 1)
        # 방문 여부 체크 배열 (1부터 N까지 사용)
        self.visited = [False] * (N + 1)

    def find_smallest_node(self):
        """
        방문하지 않은 노드 중 가장 거리값이 작은 노드의 인덱스를 반환. O(N) 순차 탐색을 수행한다.
        :return: 최소 거리 노드의 인덱스. 없으면 -1 반환.
        """
        min_dist = INF
        min_idx = -1
        
        # 1번 노드부터 N번 노드까지 순차 탐색
        for i in range(1, self.N + 1):
            # 1. 이미 방문했거나, 현재 거리보다 작지 않으면 건너뜀
            if self.visited[i]:
                continue
            
            # 2. 현재까지의 최소 거리보다 작다면 갱신
            if self.dist[i] < min_dist:
                min_dist = self.dist[i]
                min_idx = i
                
        return min_idx

    def dijkstra(self):
        """
        다익스트라 알고리즘을 실행합니다.
        """
        # 1. 초기화: 시작 노드의 인접 노드 거리 설정. 시작 노드와 인접한 정점에 대해 초기 거리 계산
        for i in range(1, self.N + 1):
            self.dist[i] = self.graph[self.start][i]
        
        # 2. 시작 노드 초기 설정
        self.dist[self.start] = 0
        self.visited[self.start] = True
        
        # 3. N-1개의 다른 노드를 반복하며 선택 및 거리 갱신
        for _ in range(self.N - 1):
            # (1) O(N) 순차 탐색으로 최소 거리 노드 선택
            new_node = self.find_smallest_node()
            
            # 더 이상 방문할 노드가 없으면 종료
            if new_node == -1:
                break
            
            self.visited[new_node] = True
            
            # (2) 선택된 노드와 인접한 노드의 거리 갱신
            for j in range(1, self.N + 1):
                # 이미 방문했거나, 경로가 없으면 (INF) 건너뜀
                if self.visited[j] or self.graph[new_node][j] == INF:
                    continue
                
                # new_node를 거쳐가는 거리가 더 짧은지 확인 후 갱신
                cost = self.dist[new_node] + self.graph[new_node][j]
                if self.dist[j] > cost:
                    self.dist[j] = cost
        
        return self.dist

# --- 예시 실행 ---
if __name__ == "__main__":
    # 노드 개수 (N=6), 노드 인덱스는 1부터 6까지 사용
    N = 6
    start_node = 1
    
    # 인접 행렬 (graph[i][j]는 i에서 j로 가는 가중치)
    # 인덱스 0은 사용하지 않는 더미 데이터 (N+1 크기)
    graph = [
        [0] * (N + 1),                      # 0번 인덱스 더미
        [0, 0, 2, 5, 1, INF, INF],          # 1번 노드 (시작)
        [0, 2, 0, 3, 2, INF, INF],          # 2번 노드
        [0, 5, 3, 0, 3, 1, 5],              # 3번 노드
        [0, 1, 2, 3, 0, 1, INF],            # 4번 노드
        [0, INF, INF, 1, 1, 0, 2],          # 5번 노드
        [0, INF, INF, 5, INF, 2, 0]         # 6번 노드
    ]

    algorithm = DijkstraON2(N, start_node, graph)
    final_dist = algorithm.dijkstra()
    
    print(f"시작 노드 {start_node}로부터의 최단 거리:")
    # 1번 인덱스부터 N번 인덱스까지 출력
    for i in range(1, N + 1):
        distance = final_dist[i]
        output = "INF" if distance == INF else distance
        print(f"노드 {i}: {output}")
```

### 우선순위 큐
- 순차 탐색을 사용할 경우 노드 개수에 따라 탐색 시간이 매우 오래 걸릴 수 있다. 이를 개선하기 위해 우선순위 큐를 도입하기도 한다.
- 거리 값을 담을 우선순위 큐는 힙으로 구현하고, 만약 최소 힙으로 구현한다면 매번 루트 노드가 최소 거리를 가지는 노드가 될 것이다.
    - 최소 힙은 부모 노드의 값은 자식 노드의 값보다 항상 작거나 같아야 한다. 그렇기떄문에 맨 위(루트 노드)는 전체 힙에서 가장 작은 값이다.
    - 그러므로 다익스트라 알고리즘이 "가장 작은 거리값"을 찾고 싶을 때, 다른 노드들을 일일이 확인할 필요 없이 맨 위에 있는 루트 노드만 쳐다보면 된다.
    - 우선순위 큐에 저장하는 것은 (거리값, 노드 인덱스) 쌍이다.
        - 노드 추가 : 새로운 노드의 거리가 갱신될때마다 (갱신된거리, 노드)를 힙에 넣는다.
        - 자동 정렬 : 힙은 이 거리를 기준으로 자동 정렬되어 가장 작은 거리값을 가진 노드를 루트에 옮겨놓는다.
        - 최솟값 추출 : 다음 노드를 선택할 때, 힙에서 루트 노드만 딱 꺼내면 (이것을 extract-min 또는 poll 이라고 함), 그것이 바로 현재까지 발견된 가장 가까운(최소 거리) 노드가 된다.

- 파이썬의 경우 PriorityQueue나 heapq 라이브러리로 우선순위 큐, 최소 힙이 지원되며, 최대 힙을 최소 힙으로 쓰려면 저장되는 값에 -를 붙여 음수로 만들면 된다.
- 우선순위 큐에서 사용할 '우선순위'의 기준은 '시작 노드로부터 가장 가까운 노드'가 된다. 따라서 큐의 정렬은 최단 거리인 노드를 기준으로 최단 거리를 가지는 노드를 앞에 배치한다.
- 위의 순차 탐색을 쓰는 구현과는 다르게 우선순위 큐를 사용하면 방문 여부를 기록할 배열은 없어도 된다. 우선순위 큐가 알아서 최단 거리의 노드를 앞으로 정렬하므로 기존 최단 거리보다 크다면 무시하면 그만이다. 만약 기존 최단거리보다 더 작은 값을 가지는 노드가 있다면 그 노드와 거리를 우선순위 큐에 넣는다. 우선순위 큐에 삽입되는 형태는 <거리, 노드> 꼴이다.

### 우선 순위 큐 동작흐름

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/500546384-5d5cf7a5-bc8e-4130-8327-85feccfd073b.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251013%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251013T144309Z&X-Amz-Expires=300&X-Amz-Signature=76f6c1cb7f27a8c326bfaa25165ab928b232f4bf1b41ee7331992059712368c5&X-Amz-SignedHeaders=host)

- 시작노드 1에서 1로 가는 거리는 없으므로 0을 넣어둔다. 그리고 해당 데이터를 우선 순위 큐에 넣어준다. 

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/500548554-a003aced-cdcc-474a-b213-e6f4a6632470.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251013%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251013T144739Z&X-Amz-Expires=300&X-Amz-Signature=c178da93998ae1ebd2a001c30356eab6b5b93ab2e5f23d632cb9e758683032d2&X-Amz-SignedHeaders=host)

- 그다음 우선순위 큐에 있는 데이터(거리:0,노드:1) 를 pop을 통해 꺼내 1번 노드를 탐색한다.  
- 1번 노드와 연결되어있는 2,3,4 노드들을 우선순위 큐에 (거리, 노드)순으로 넣어준다. 그러면 거리를 기준으로 자동 정렬된다. 그럼 1번 노드와 가장 가까운 노드 4가 가장 앞으로 간다. 
- 이렇게 최단 거리를 가지고 있는 노드를 탐색하는 과정을 우선순위 큐가 대신하는 것이다. 

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/500547160-07321fe4-31a2-4867-92fb-cf439c3872ef.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251013%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251013T144446Z&X-Amz-Expires=300&X-Amz-Signature=809bc1b6bdbec2d9088298574213c1d016d27a29dcb588831d8df800639f5cb2&X-Amz-SignedHeaders=host)

- 이제 다시 우선 순위 큐에 가장 앞에 있는 (거리:1, 노드:4) 데이터를 뽑아서 4번 노드를 탐색한다.
- 이때 착각 하지말아야할 것은 1번의 인접노드가 4번이라서 4번 노드를 탐색하는 것이 아니다. 그런 것과는 상관없이 현재 최단 거리인 데이터를 꺼내오는 것이다. 
- 4번 노드와 연결된 3,5노드를 들고 오는데 이때, 연결된 노드의 거리 값 + 연결된 노드에 오기까지의 거리가 현재 노드의 거리보다 작아야만 우선순위 큐에 저장한. 이를 자세히 설명하면 다음과 같다. 
    - 현재 노드 번호와 거리 표에서 노드 3의 거리는 5로 표기되어있다. ( 바로 앞의 단계에서 1번 노드와 연결 되어있는 노드들을 우선순위 큐에 넣을때 3번 노드가 1번 노드와 5의 거리를 가지고 있었기에 거리 테이블에서 3번 노드는 5의 값을 가지고 있다.) 
    - 노드 3: 1→4→3. 새 경로 거리: 1(노드 4)+3(가중치)=4. 임으로 노드 3에 기록되어있는 거리 5보다 작다. 그러므로 우선순위 큐에 (거리:4, 노드:3)을 새로 추가한다. (기존에 넣어두었던 (거리:5, 노드:3)은 그대로 존재한다)
    - 노드 5: 1→4→5. 새 경로 거리: 1(노드 4)+1(가중치)=2. 이 경우도 현재 노드 5번에 기록된 무한(inf)값보다 작음으로 우선 순위큐에 넣어준다.
- 반대로, 우선 순위 큐에서 꺼낸 데이터의 거리가 기존 거리 테이블의 거리값보다 큰 경우에는 무시하고 넘어가면 된다. 
    - 즉, 우선 순위 큐에서 빼낸 노드를 탐색 하려고 하는데 이미 더 최단거리가 거리 테이블에 갱신되어있다면 무시한다. 
    - ex) 우선 순위 큐에서 꺼낸 (거리:5, 노드 :3)데이터를 꺼냈는데 거리테이블의 노드 3번의 거리가 2라면 무시.

- 이런 식으로 우선 순위 큐에 가장 앞에 있는 데이터를 계속 꺼내며 탐색, 거리 테이블의 값보다 작을 시 우선 순위 큐에 저장 및, 거리 테이블 새로 갱신해나간다. 그러다가 도착 노드 6에 도달하면 종료한다. (인접노드가 더이상 없거나 모든 노드의 최단 거리를 찾는 것이 목적이라면 큐가 빌때까지 계속 진행.)
- 다만 이대로라면 최단 거리의 경로를 알수 없기때문에 최단 거리의 경로를 알기 위해서는 직전 노드 라는 경로 테이블을 따로 기록해야한다. 





#### 파이썬

```


graph = {
    'A': {'B': 8, 'C': 1, 'D': 2},
    'B': {},
    'C': {'B': 5, 'D': 2},
    'D': {'E': 3, 'F': 5},
    'E': {'F': 1},
    'F': {'A': 5}
}

import heapq  # 우선순위 큐 구현을 위함

def dijkstra(graph, start):
  distances = {node: float('inf') for node in graph}  # start로 부터의 거리 값을 저장하기 위함
  distances[start] = 0  # 시작 값은 0이어야 함
  queue = []
  heapq.heappush(queue, [distances[start], start])  # 시작 노드부터 탐색 시작 하기 위함.

  while queue:  # queue에 남아 있는 노드가 없으면 끝
    current_distance, current_destination = heapq.heappop(queue)  # 탐색 할 노드, 거리를 가져옴.

    if distances[current_destination] < current_distance:  # 기존에 있는 거리보다 길다면, 볼 필요도 없음
      continue
    
    for new_destination, new_distance in graph[current_destination].items():
      distance = current_distance + new_distance  # 해당 노드를 거쳐 갈 때 거리
      if distance < distances[new_destination]:  # 알고 있는 거리 보다 작으면 갱신
        distances[new_destination] = distance
        heapq.heappush(queue, [distance, new_destination])  # 다음 인접 거리를 계산 하기 위해 큐에 삽입
    
  return distances

print(dijkstra(graph, 'A'))
{'A': 0, 'B': 6, 'C': 1, 'D': 2, 'E': 5, 'F': 6}

```

#### 자바 

```
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Comparator;
import java.util.Set;

public class DijkstraAlgorithm {

    // 그래프 정의 (인접 리스트 형태)
    // Key: 노드 이름 (String)
    // Value: 인접한 노드와 가중치를 담는 Map<인접 노드, 가중치>
    private static final Map<String, Map<String, Integer>> graph = new HashMap<>();

    static {
        // 그래프 데이터 초기화
        graph.put("A", Map.of("B", 8, "C", 1, "D", 2));
        graph.put("B", Map.of());
        graph.put("C", Map.of("B", 5, "D", 2));
        graph.put("D", Map.of("E", 3, "F", 5));
        graph.put("E", Map.of("F", 1));
        graph.put("F", Map.of("A", 5));
    }

    /**
     * 다익스트라 알고리즘을 사용하여 시작 노드로부터 모든 노드까지의 최단 거리를 계산합니다.
     * * @param graph 인접 리스트 형태의 그래프
     * @param start 시작 노드
     * @return 각 노드까지의 최단 거리를 담은 Map<노드, 거리>
     */
    public static Map<String, Integer> dijkstra(Map<String, Map<String, Integer>> graph, String start) {
        // 1. 거리 테이블 초기화 (distances)
        Map<String, Integer> distances = new HashMap<>();
        Set<String> nodes = graph.keySet();

        // 모든 노드의 거리를 무한대(Integer.MAX_VALUE)로 초기화
        for (String node : nodes) {
            distances.put(node, Integer.MAX_VALUE);
        }
        distances.put(start, 0); // 시작 노드의 거리는 0

        // 2. 우선순위 큐 초기화 (거리, 노드)
        // [거리, 노드] 쌍을 저장할 클래스 (또는 배열) 사용
        // 거리를 기준으로 오름차순 정렬 (최소 힙)
        PriorityQueue<NodeDistance> pq = new PriorityQueue<>(Comparator.comparingInt(nd -> nd.distance));
        
        // 시작 노드를 큐에 추가
        pq.add(new NodeDistance(start, 0));

        // 3. 메인 루프 (큐가 빌 때까지 반복)
        while (!pq.isEmpty()) {
            NodeDistance current = pq.poll(); // 거리가 가장 짧은 노드를 꺼냄
            String currentDestination = current.node;
            int currentDistance = current.distance;

            // 이미 더 짧은 경로를 발견했다면(이미 최단 거리가 확정된 노드라면) 무시 (Python의 'continue' 로직)
            if (distances.get(currentDestination) < currentDistance) {
                continue;
            }

            // 인접 노드 탐색 (currentDestination 노드에서 갈 수 있는 모든 노드)
            if (graph.containsKey(currentDestination)) {
                for (Map.Entry<String, Integer> neighbor : graph.get(currentDestination).entrySet()) {
                    String newDestination = neighbor.getKey();
                    int newDistance = neighbor.getValue();

                    // 현재 노드를 거쳐 갈 때의 총 거리
                    int distance = currentDistance + newDistance;

                    // 갱신 조건: 현재 계산된 거리가 기존에 알고 있던 거리보다 짧으면 갱신
                    if (distance < distances.getOrDefault(newDestination, Integer.MAX_VALUE)) {
                        distances.put(newDestination, distance);
                        // 다음 인접 거리를 계산하기 위해 큐에 삽입
                        pq.add(new NodeDistance(newDestination, distance));
                    }
                }
            }
        }

        return distances;
    }

    // 큐에 넣을 데이터를 위한 보조 클래스 (거리와 노드 이름을 함께 저장)
    static class NodeDistance {
        String node;
        int distance;

        public NodeDistance(String node, int distance) {
            this.node = node;
            this.distance = distance;
        }
    }

    public static void main(String[] args) {
        Map<String, Integer> shortestDistances = dijkstra(graph, "A");
        System.out.println(shortestDistances);
    }
}

```




#### 참고링크 
https://velog.io/@717lumos/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

https://techblog-history-younghunjo1.tistory.com/247#google_vignette

https://justkode.kr/algorithm/python-dijkstra/