## 트리 Tree
![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/495690956-afd929ad-2e0a-41d9-9282-9b26aa59d0f0.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250930%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250930T125620Z&X-Amz-Expires=300&X-Amz-Signature=afec96563e16e5b66291f9c2757ac48d498ab9eaedc50ab3e20d94384b6de2ef&X-Amz-SignedHeaders=host)

- 트리는 계층 구조를 표현하는 비선형 자료구조다.
- 그래프의 일종으로, 트리는 정점(Node)와 간선(Edge)으로 이루어져 있지만, 특별히 사이클이 없는 계층적 구조를 가진다. 

### Tree 용어
- 노드(Node) : 트리에서 데이터를 저장하는 기본 단위. 트리의 각 노드는 데이터를 포함하며, 다른 노드들과의 부모-자식 관계를 형성할 수 있다.
- 간선(Edge, Link, Branch) : 트리에서 노드 간의 연결을 나타내는 선입니다. 간혹 Link, Branch라는 용어로도 불린다. 트리에서는 각 간선이 부모 노드와 자식 노드를 연결하며, 단방향성을 가진다.
- 루프 노드(Root Node) : 트리의 최상단에 위치한 노드로, 트리의 시작점이다. 트리에는 단 하나의 루트만이 존재하며, 이 루트 노드는 트리의 모든 다른 노드들과 경로로 연결되어 있다. 부모가 없는 유일한 노드
- 리프 노드(Leaf Node) : 자식이 없는 노드, 트리의 말단. 트리의 탐색이 끝나는 지점을 나타내며 다른 노드로 더이상 연결되지 않음.
- 부모 노드와 자식노드 
    - 부모 노드 (Parent Node) : 다른 노드를 연결하고 있는 상위 노드, 연결된 하위 노드를 자식 노드라고 함.
    - 한 부모 노드는 여러 자식 노드를 가질 수 있지만 한 자식 노드는 반드시 하나의 부모 노드만 가진다. 
- 형재 노드(Sibling Nodes) : 같은 부모 노드를 공유하는 노드들. 같은 레벨에 있는 노드들이며 서로 인접한 관계로 묶여있다. 위치가 인접하다는 것일뿐 그래프에서의 인접 개념과는 다른 의미다.

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/495746021-7b84f1dd-6b02-4d6a-8fd1-8a58accfa9c6.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250930%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250930T144037Z&X-Amz-Expires=300&X-Amz-Signature=9f50bd2b04577fd4a394a2165af4fc65dcfb4369caddc4242be131b6473f5ab1&X-Amz-SignedHeaders=host)

- 서브 트리(SubTree) : 트리 내의 어느 한 노드를 루트로 하는 트리. 트리의 각 노드는 자신을 루트로 하는 하위 트리(서브트리)를 형성할 수 있다. 
- 깊이(Depth) : 특정 노드가 루트 노드로부터 떨어진 거리를 나타낸다. 루트 노드의 깊이는 0이며, 각 노드의 깊이는 부모 노드의 깊이보다 1만큼 크다. 
- 레벨 : 루트 노드를 기준으로 하는 트리의 깊이를 의미하며, 루트 노드는 0레벨, 그 아래로 내려갈수록 레벨이 1씩 증가한다. 같은 레벨에 있는 노드들은 같은 깊이를 가지며, 부모 노드가 같다면 이들은 서로 형제 노드가 된다.
- 높이(Height) : 특정 노드에서 리프 노드까지의 가장 긴 경로 (즉, 자식 노드로 내려가는 최대 깊이)를 의미한다. 트리의 높이는 루트 노드의 높이를 의미하며, 이는 트리에서 가장 깊은 노드까지의 경로 길이와 같다.
    - 리프 노드의 높이는 0이며, 부모 노드의 높이는 자식 노드의 높이보다 1만큼 크다.
    - 루트 노드의 높이는 트리 전체의 높이와 동일하다.
- 차수(Degree) : 하나의 노드가 가지고 있는 자식 노드의 수를 나타낸다. 트리의 최대 차수를 가지는 노드가 트리의 차수와 동일하다. 참고로 트리의 최대 차수가 2인 트리를 이진트리(Binary Tree)라고 부른다.


## Tree의 주요 특징
- 트리는 아래와 같은 특징들 덕분에 디렉터리 구조, 데이터 베이스 인덱스 등 계층적인 데이터 관리와 탐색에 널리 사용된다.

### 계층적 구조 
- 트리는 루트 노드(root Node, 최상단 노드)에서 시작해 자식 노드(아래 방향)들로 뻗어나가는 계층적 자료구조로 데이터를 논리적이고 구조화된 방식으로 표현할 수 있다. 
    - Root Node(루트 노드) : 트리 최상단 노드, 트리의 시작점. 모든 다른 노드는 루트 노드로부터 이어지며 트리에는 하나의 루트 노드만 존재한다.
    - 부모-자식 관계 : 트리에서 각 노드는 부모 노드와 자식 노드의 관계를 형성합니다. 상위 노드가 하위 노드로 이어져 트리 구조를 만든다. 
    - Leaf Node : 자식 노드가 없는 노드를 리프 노드라고 부르며 트리의 말단을 의미한다. 

### 비순환성 
- 트리는 사이클(순환)이 없는 비순환 구조다. 즉, 트리 내부에서 루프가 발생하지않으며 부모 노드와 자식노드간의 이동만 가능하다. 

### 연결성
- 트리의 모든 노드는 루트 노드에서 단 하나의 경로로 연결된다. 따라서 트리는 하나의 연결된 그래프로 볼 수 있다. 

## Tree 용도
- 데이터의 계층적 구조를 표현하는 데 유용하다.
- 파일 시스템 구조 : 트리는 디렉토리 구조와 파일 시스템을 표현하는 데 사용. 루트 디렉토리에서 시작하여 하위 폴더와 파일로 뻗어 나가는 구조는 트리와 동일한 원리
- 데이터베이스 인덱스 : 트리는 데이터베이스 인덱싱에서 효율적인 검색을 위해 사용됨. 예를 들어, B-Tree와 B+Tree는 대규모 데이터베이스에서 빠른 검색과 정렬을 가능하게 해준다.
- 컴파일러 구조 : 트리는 컴파일러가 구문 분석 시 프로그램의 구조를 나타낼 때 사용된다. 구문 분석 트리(Syntax Tree)는 프로그램의 문법 구조를 트리 형태로 표현
- 이진 탐색 트리(Binary Search Tree, BST) : 이진 트리는 검색 속도를 개선하기 위해 활용된다. 특히, BST는 정렬된 데이터를 저장하여 빠른 검색, 삽입, 삭제 연산을 수행할 수 있다.
- 네트워크 라우팅 : 트리는 네트워크에서 효율적인 경로 탐색 및 패킷 전달을 위해 사용되며, 최소 신장 트리(MST) 같은 알고리즘으로 네트워크 연결을 최적화할 수 있다.
- 게임 및 AI : 트리는 게임 트리, 의사결정 트리(Decision Tree) 등의 구조로 활용되며, AI와 머신러닝 분야에서는 의사결정 트리(Decision Tree)와 같은 알고리즘이 사용된다.

## Tree와 Graph 비교 

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/495743508-01a0a7a3-12f1-441b-ae45-c86b35f0a0c5.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250930%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250930T143519Z&X-Amz-Expires=300&X-Amz-Signature=0b69ec3087ae3398f177413ccc06aabaf46be2be28c76e434d7aabacc9a8459f&X-Amz-SignedHeaders=host)

- 트리는 그래프의 특수한 형태로, 사이클이 없고 명확한 부모-자식 관계를 가진 계층적 구조다.
- 반면 그래프는 좀 더 일반적인 구조로, 사이클과 다중 경로를 허용하며 네트워크 모델링에 주로 사용된다.
- 트리는 계층적 데이터를 표현하거나 탐색하는데 적합한 자료구조이고, 그래프는 복잡한 네트워크나 연결성을 분석하는 데 적합한 자료구조.
Tree는 Graph의 특수한 형태로, 사이클이 없고 명확한 부모-자식 관계를 가진 계층적 구조입니다.




## 이진트리 Binary Tree
- 트리 중에서도 각 노드가 최대 2개의 자식 노드를 가질떄 이진 트리라고 한다. 최대 2개이기때문에 자식이 없을 수도 있고 한개만 있을 수도 있다. 이때 자식 노드는 각각 왼쪽 자식 노드와 오른쪽 자식 노드로 표현한다.
- 그래서 같은 루트에 같은 자식 노드 하나를 가지고 있어도. 자식 노드의 위치가 각각 오른쪽과 왼쪽으로 다르다면 두 트리는 서로 다른 트리가 된다. 

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/495679764-8328178f-76f2-4b93-a9f8-6e9652d54f99.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250930%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250930T122857Z&X-Amz-Expires=300&X-Amz-Signature=613f8ed70df10f601d3f2b2a4340a1323a1596f4c270b9e3dbddc6b33bbfd9cb&X-Amz-SignedHeaders=host)

- 자료를 효율적으로 정렬하고 탐색하는데 유용하다. 

## 이진트리의 주요 특징
### 자식 노드의 수 제한 
- 이진 트리의 가장 큰 특징은 각 노드가 최대 두 개의 자식 노드를 가질 수 있다는 점.
    - 즉, 왼쪽 자식과 오른쪽 자식으로만 연결된다.
    - 둘 중 하나가 없거나 둘다 없어도 무방하며 3개를 넘지만 않으면 된다.

### 재귀적 구조
- 트리는 본질적으로 재귀 구조를 가지며, 하위 트리 (subtree)들도 하나의 이진 트리로 취급된다. 

### 균형성
- 이진트리에서는 노드가 어느 한쪽에 치우치지 않고 균형적으로 분포되는 것이 이상적이다. 
    - 균형 잡힌 트리 (Balanced Binary Tree)는 탐색, 삽입, 삭제 와 같은 연산에서 O(log n)의 시간 복잡도를 가진다.
    - 반면, 비균형 트리는 특정한 경로가 지나치게 길어지면, 선형 탐색과 유사한 O(n) 시간 복잡도를 가질 수 있다. 

## 이진 트리의 용도
- 탐색, 정렬, 데이터 관리등의 목적으로 널리 사용된다. 

### 이진 탐색 트리(BTS)
- 이진 탐색 트리는 각 노드가 왼쪽 자식은 부모보다 작은 값, 오른쪽 자식은 부모보다 큰 값을 가지도록 구성된 트리. 이를 통해 빠른 검색과 정렬을 가능하게 한다.다만, BST는 삽입과 삭제 과정에서 트리가 한쪽으로 치우쳐 비균형 상태가 될 수 있다. 이 경우, 탐색 성능이 O(n)으로 저하될 수 있으며, 이를 해결하기 위해 AVL 트리나 Red-Black 트리와 같은 자체 균형 트리가 사용된다.
### 힙(Heap)
- 힙은 최대값 또는 최소값을 빠르게 찾기 위해 사용하는 완전 이진 트리입니다. 주로 우선순위 큐 및 최단 경로 탐색에 활용된다.
- 최대 힙(Max Heap)에서는 부모 노드의 값이 자식 노드보다 크거나 같다, 반면에 최소 힙(Min Heap)에서는 부모 노드의 값이 자식 노드보다 작거나 같다.
- 힙은 주로 우선순위 큐, 최단 경로 탐색 등의 알고리즘에서 사용된다.

### 트리 기반 검색 알고리즘
- 이진 트리는 이진 탐색, 트리 순회 알고리즘(Pre-order, In-order, Post-order) 등에서도 매우 유용하게 사용됨.

## 완전 이진트리 
- 이진트리 중에서도 마지막 레벨을 제외한 모든 레벨에는 노드들이 가득 차 있고, 마지막 레벨의 노드들도 좌측부터 순서로 들어가있는 형태의 이진트리를 완전 이진트리라고 한다. 노드를 삽입할때 왼쪽부터 차례대로 삽입하는 트리이다. 
- 노드가 최대 2개의 자식 노드를 갖는 트리 형태의 자료구조로서 마지막 레벨을 제외한 모든 노드는 완전히 채워져 있어야 한다. 또한, 최하단 레벨의 노드는 좌측만 노드가 채워져 있거나 좌측과 우측 모두 채워져 있어야 하며, 노드를 삽입할 때는 최하단 좌측 노드부터 차례대로 삽입해야 합니다(그림 1 참고). 그림 1 우측 트리는 노드 12의 자식 노드가 우측에만 삽입되어 있기 때문에 완전 이진트리라고 할 수 없다.

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/495676472-cb224a16-4eab-4d4c-9e15-96b46fc973ac.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250930%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250930T122058Z&X-Amz-Expires=300&X-Amz-Signature=90dbcdb645ab71438ea517536628de3fbdf3ac422e0fca8b1f15a39811498fae&X-Amz-SignedHeaders=host)

### 완전 이진트리 조건
- 첫째, 마지막 레벨을 제외하고 모든 노드가 채워져있어야한다. 마지막 레벨의 노드는 다 채워져 있을 수도 있고 아닐 수도 있다.
- 둘째, 노드는 왼쪽에서 오른쪽 방향으로 채워져야한다. 그래서 어느 노드에 오른쪽 자식이 존재한다면 왼쪽 자식도 가지고 있어야 완전 이진트리로 볼 수 있다. 

## 완전 이진트리 특징
### 효율적인 배열 구현
- 배열을 이용해 구현할때의 효율성이 좋다. 노드가 왼쪽부터 순서대로 빈틈없이 채워져 있기 때문에, 연결 구조(포인터)를 사용할 필요 없이 배열의 인덱스만으로 부모/자식 노드를 쉽게 계산할 수 있다. 예를 들어, 배열 인덱스 i에 있는 노드의 왼쪽 자식은 2i+1, 오른쪽 자식은 2i+2에 위치한다. (0부터 시작하는 인덱스 기준).이는 메모리상의 연속된 공간을 사용하므로, 메모리 접근 속도(캐시 효율성)가 높아지고 포인터 오버헤드가 없어 매우 빠르다.

### 자료구조 힙(Heap)의 근간이 됨
- 힙(Heap) 자료구조는 반드시 완전 이진 트리 형태여야 한다.
- 힙은 가장 중요한 요소(최소값 또는 최대값)를 O(1)의 시간 복잡도로 빠르게 찾고, 요소를 삽입하거나 삭제할 때 O(log n)의 효율적인 시간 복잡도를 유지해야 한다. 완전 이진 트리의 규칙(항상 균형이 잡혀있음) 덕분에 트리의 높이가 항상 logn으로 유지될 수 있으며, 이를 통해 힙 연산의 효율성(시간 복잡도)이 보장됩니다.
- 완전 이진 트리는 배열을 이용한 효율적인 저장 방식을 제공함으로써, 힙과 같은 자료구조가 안정적이고 빠른 성능을 발휘할 수 있는 구조적 토대를 마련해준다.



#### 참고 링크 
https://heytech.tistory.com/105

https://rosweet-ai.tistory.com/55

https://velog.io/@dankj1991/Tree-Binary-Tree

https://velog.io/@dankj1991/Tree-Intro