![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/496649073-b418f0a4-e361-4bdf-b562-80b8e0da74ba.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251002%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251002T131253Z&X-Amz-Expires=300&X-Amz-Signature=e10b14da4cf261205273b63a982584b0cf771ffa84d0bac7957cbc820157e07a&X-Amz-SignedHeaders=host)


## 슬라이딩 윈도우(Sliding Window)

- 윈도우라고 불리는 특정 구간을 이동시키면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 알고리즘. 연속되는 투 포인터와 유사하게 부분 배열들을 활용하여 특정 조건을 일치시키는 알고리즘이지만, **윈도우의 크기가 고정적**임으로 부분 배열의 길이(크기)가 고정적이다.
- 일정한 크기의 윈도우를 설정하여 데이터를 처음부터 끝까지 일정한 간격으로 윈도우를 이동하며 처리한다. 
- 배열이나 리스트 요소의 일정 범위 값을 비교할 때, 교집합의 정보를 공유하고, 차이가 나는 양쪽 끝 원소만 갱신하는 방법을 통해 배열이나 리스트의 요소의 일정 범위의 값을 비교할 때 사용하면 매우 유용하다.
- 슬라이딩 윈도우 알고리즘은 투 포인터 알고리즘과 연동하여 많이 쓰인다. 
    - 투 포인터 (Two Pointers) : 1차원 배열이 있고, 이 배열에서 각자 다른 원소를 가리키는 2개의 포인터를 조작하며 원하는 값을 얻는 형태의 알고리즘.
    - 투 포인터 알고리즘은 부분 배열의 길이가 **가변적** 이기 때문에 부분 배열의 구간을 정할 2개의 포인터 변수가 필요한 반면, 슬라이딩 윈도우 알고리즘은 부분 배열의 길이를 고정적으로 잡기 때문에 포인터 변수가 2개일 필요가 없다.
    =- 즉, 고정적인 부분 배열의 크기를 나타내는 변수가 있다면 포인터 하나만 있어도 부분 배열의 크기를 알고 있기 때문에 각 배열의 끝이 어딘지 알 수 있습니다.

```
def find_max_sum_of_subarray(arr, k):
    """
    배열 arr에서 크기가 k인 연속된 부분 배열의 최대 합을 찾습니다.
    """
    n = len(arr)
    
    # 예외 처리: 배열 길이가 K보다 작으면 계산 불가
    if n < k:
        return "오류: 배열 길이가 윈도우 크기보다 작습니다."

    # 1. 초기 윈도우 설정 (첫 번째 윈도우의 합 계산)
    # [4, 2, 1]의 합 = 7
    current_window_sum = sum(arr[:k])
    max_sum = current_window_sum

    # 2. 윈도우를 한 칸씩 '슬라이딩'하며 최대 합 갱신
    # i는 윈도우의 '끝' 인덱스를 나타냅니다.
    # arr[0]부터 arr[k-1]까지를 이미 계산했으므로, arr[k]부터 시작합니다.
    for i in range(k, n):
        # 새로운 윈도우의 합을 O(1)로 계산:
        
        # (1) 윈도우에 새로 진입하는 원소를 더하고 (arr[i])
        current_window_sum += arr[i]
        
        # (2) 윈도우에서 빠져나가는 원소를 뺍니다. (arr[i - k])
        # arr[i-k]는 현재 윈도우의 시작점 바로 앞에 있는, 제거될 원소입니다.
        current_window_sum -= arr[i - k]
        
        # 3. 최대 합 갱신
        max_sum = max(max_sum, current_window_sum)

    return max_sum

# --- 예시 실행 ---
array = [4, 2, 1, 7, 8, 1, 2, 8, 1, 0]
k_size = 3

# 1. [4, 2, 1] = 7
# 2. [2, 1, 7] = 7 - 4 + 7 = 10
# 3. [1, 7, 8] = 10 - 2 + 8 = 16
# 4. [7, 8, 1] = 16 - 1 + 1 = 16
# 5. [8, 1, 2] = 16 - 7 + 2 = 11
# 6. [1, 2, 8] = 11 - 8 + 8 = 11
# 7. [2, 8, 1] = 11 - 1 + 1 = 11
# 8. [8, 1, 0] = 11 - 2 + 0 = 9
# 결과: 16

result = find_max_sum_of_subarray(array, k_size)

print(f"배열: {array}")
print(f"윈도우 크기 (K): {k_size}")
print(f"최대 부분 배열 합: {result}")
# 출력: 최대 부분 배열 합: 17
```

### 슬라이딩 윈도우 응용 문제 
- 최대 또는 최소 부분합 : 연속된 k개의 숫자를 합쳤을때 생기는 경우의 숫자 중, 최대 또는 최소를 찾아라. 
- 부분 배열 평군 : 연속된 k개의 숫자 평균을 구하는 문제
- 문자열 검색 : 문자열에서 특정 패턴을 찾는 문제
- 투 포인터 문제 : 두개의 포인터를 사용하여 배열에서 특정 조건을 만족하는 부분 배열을 찾는 문제 


## 투 포인터 (Two Pointers)
- 투 포인터는 **"연속되고 길이가 가변적인"** 부분 배열들을 활용하여 특정 조건을 일치시키는 알고리즘이다. 1차원 배열에서 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작해가면서 원하는 값을 찾을 때 까지 탐색한다.
- 기법의 목적은 전체 배열을 이중 루프(O(N2))로 탐색해야 할 문제를 **단일 루프(O(N))**로 최적화하는 데 있다.

## 투 포인터 방식
###  시작점-끝점 포인터 (Start/End Pointers)
- 두 포인터가 **같은 방향(주로 오른쪽)**으로 움직이면서 부분 배열의 길이를 유동적으로 조절한다.
- 두 포인터(star,end)가 모두 배열의 시작점(index 0 )에서 출발한다. 
- end 포인터는 조건을 만족시키기 위해 배열을 확장하고, Start 포인터는 조건이 위반될 때 배열을 축소한다.
- 연속된 부분배열이나 부분 문자열에서 특정 조건(합,개수,길이)를 만족하는 구간을 찾기 위해 주로 사용된다 (ex "합이 M인 연속 부분 수열의 개수 찾기", "가장 긴 중복 없는 부분 문자열 찾기" )

### 양 끝 포인터 (Opposite Pointers)
- 이 방식은 포인터가 서로 다른 방향(안쪽)으로 움직이는 방식으로, 주로 정렬된 배열에서 특정 조건을 만족하는 두 원소를 찾는 데 사용.
- Left 포인터는 배열의 시작(왼쪽 끝), Right 포인터는 **배열의 끝(오른쪽 끝)**에서 시작한다.
- 두 포인터가 서로 마주보며 안쪽으로 이동합니다. 두 포인터가 만나거나 교차할 때 탐색을 종료한다.
- 배열 내에서 두 원소를 선택해 특정 **조건(합, 차, 곱)**을 만족하는 쌍을 찾는다. (연속된 구간일 필요가 없다. 다만, 비 연속적인 배열에서 투 포인터를 쓰려면 반드시 배열이 정렬 되어있어야한다.) (ex "정렬된 배열에서 두 수의 합이 타겟 값 K가 되는 쌍을 찾기")



#### 참고 링크 

https://velog.io/@ninto_2/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

https://dolphincoding.io/learn/document/48

https://velog.io/@alkwen0996/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0Sliding-Window