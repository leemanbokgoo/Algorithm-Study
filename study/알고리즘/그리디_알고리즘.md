## 그리디 알고리즘
![그리디 알고리즘 설명](https://www.youtube.com/watch?v=_IZuE7NIeW4)

- 최적의 값을 구해야하는 상황에서 사용되는 근시적인 방법론으로서 '각 단계에서 최적이라고 생각되는 것을 선택해 나가는' 방식으로 진행하여 최정직인 해답(최종해)에 도달하는 알고리즘이다.
    - 바로 눈앞의 이익만을 쫒으며, 최적해를 찾을 수 있으면 그것을 목표로 삼고 찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는 것을 목표로 삼는다.
- 그리디 알고리즘은 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를 더 작게 줄여나가는 형태로 풀이한다. 
- 그리디 알고리즘은 현재 시점에서 가장 좋아 보이는 선택을 하고, 한번 내린 결정은 번복하지 않고 다음 단계로 넘어간다. 앞의 선택이 이후 선택에 영향을 주지않는 것이다. 다시 말해 그리디 알고리즘은 선택을 다시 고려하지않는다. 
- 항상 최적의 값을 보장하진않고 최적해에 근사한 값을 목표로 하는 알고리즘으로 합리적인 시간 내에 최적에 가까운 답을 찾을 수 있다는 점에서 매우 유용하다.
- 대부분의 경우 계산 속도가 빠르므로 매우 실용적이다.

## 그리디 알고리즘 주요 속성
- 문제를 풀 때 두가지 조건이 성립해야 그리디 알고리즘을 적용할 수 있다.

### 탐욕 선택 속성 
- 각 단계에서 '최선의 선택'을 했을 때 전체 문제에 대한 최적해를 구할 수 있는 경우를 말한다. 즉, 각 단계에서 가장 이상적인 선택을 하는 것이 전체적으로 최적의 결과를 가져온다는 속성이다.
    - 쉽게 말해 복잡하게 모든 경우의 수를 탐색할 필요 없이 현재 시점의 가장 좋은 선택만 따라가면 된다.
    - 단계에서 지역적으로 최선의 선택(로컬 최적해)을 내렸을 때, 그 선택이 전체 문제의 최적해를 찾는 데 기여해야 한다는 속성이다.
- 탐욕 선택 속성을 설명할때 앞의 선택이 이후 선택에 영향을 주지않는 다는 말은 이전 선택의 영향을 고려하지않아도 전체 최적해를 얻을 수 있는 구조여야한다는 말이다. 현재의 최선만 따라가도 되기 때문에, 이전 선택이 미래에 미칠 복잡한 영향을 미리 계산하거나 되돌아볼 필요가 없다.
    - (실제로 앞의 선택이 아예 영향을 주지않는 것은 아니지만, 그 영향을 선택에서 고려할 필요가 없는 것.)


### 최적 부분 구조 
- 전체 문제의 최적해가 부분 문제의 최적해로 구성 될 수 있는 경우를 말한다. 즉, 전체 문제를 작은 부분 문제로 나누어 각각의 부분 문제에서 최적의 해를 구한 후 이를 조합하여 전체 문제의 최적해를 구하는 것을 의미한다. 
- 예를 들어 서울 -> 부산 경로를 구한다고 가정하자. 서울 -> 부산을 한번에 갈 수는 없고 서울 -> 대전, 대전 -> 부산이라는 단계를 거쳐야한다.
    - 이때, 서울 -> 대전, 대전 -> 부산으로 가는 루트의 각각 최적해를 구한 합이 전체 서울 -> 부산 경로의 최적해가 된다. 


## 그리디 알고리즘 단계
- 1. 문제의 최적해 구조를 결정한다.
- 2. 선택 절차 : 문제의 구조에 맞게 선택 절차를 정의한다.
    - 선택 절차 : 현재 상태에서 최적의 선택을 한다. 이 선택은 이후에는 바뀌지않는다.
- 3. 선택 절차에 따라 선택을 수행한다.
- 4. 적절성 검사 : 선택된 해가 문제의 조건을 만족하는 지 검사한다.
    - 선택한 항목이 문제의 조건을 만족시키는 지 확인한다. 조건을 만족시키지 않으면 해당 항목은 제외된다.
- 5. 조건을 만족하지않으면 해당 해를 제외한다.
- 5. 해답 검사 : 모든 선택이 완료되면 해답을 검사한다.
    - 모든 선택이 왼료되면 최종 선택이 문제의 조건을 만족 시키는 지 확인한다. 조건을 만족 시킬 시 해답으로 인정됨.
- 6. 조건을 만족하지않으면 해답으로 인정되지않는다. 

## 그리디 알고리즘 장점
- 조건을 만족하면 빠르게 최적의 결과를 도출해낼 수 있다.

## 그리디 알고리즘 단점
- 적용할 수 있는 문제의 폭이 좁다. 최적 부분 구조와 탐욕 선택 속성을 갖는 문제에만 적용할 수 있기때문에 해당 조건을 만족하지않는다면 적용할 수 없다.


### 그리디 알고리즘이 사용되는 예시 
- AI의 결정 트리 학습법
- 활동 선택 문제
- 거스름돈 문제
- 최소 신장 트리
- 제약 조건이 많은 대부분의 문제
- 다익스트라 알고리즘
- 허프만 코드
- UNION & FIND 알고리즘

## 그리디 알고리즘의 예시 문제 
### 배낭 문제 
- 조합 최적화 분야의 매우 유명한 문제로 배낭에 담을 수 있는 무게의 최댓값이 정해져있고 각각 짐의 가치(가격)과 무게가 있는 짐들을 배낭에 넣을떄 가치의 합이 최대가 되도록 즉, 높은 가격을 가지도록 짐을 고르는 방법을 찾는 문제다.
    - 배낭 문제는 짐을 쪼갤 수 있는 경우인 분할 가능 배낭 문제(그리디 알고리즘으로 해결 가능)과 짐을 쪼갤 수 없는 경우인 배낭 문제(다이나믹 프로그래밍으로 해결 )로 나뉜다.

```
cargo =[
    # 가격,무게
    (4,12),
    (2,1),
    (10,4),
    (1,1),
    (2,2)
]

def fractional_knapsack(cargo):
    capacity = 15
    pack = []

    # 단가 계산 역순 정렬
    for c in cargo:
        pack.append((c[0] / c[1], c[0], c[1]))
    pack.sort(reverse=True)

    total_value : float = 0
    for p in pack:
        if capacity - p[2] >= 0:
            capacity -= p[2]
            total_value += p[1]
        else:
            fraction = capacity / p[2]
            total_value += p[1] * fraction
            break
    return total_value
```

### 동전 바꾸기 문제
- 동전의 액면이 10원, 50원, 100원처럼 증가하면서 이전 액면의 배수 이상이 되면 그리디 알고리즘으로 풀수있다.
- 예를 들어 우리나라의 동전은 항상 배수 이상임으로 그리디로 풀 수 있다. 160원을 거슬러준다면 10원 16개 보다는 100원 하나, 50원 하나, 10원하나 이런식으로 각각의 동전을 최대한 활용하는 그리디한 방법이 가장 작은 동전 개수로 거슬러 줄 수 있다.
- 하지만 80원짜리 동전이 있는 A나라의 경우에는 그리디하게 풀수없다. 160원을 거슬러 줘야한다면 80원짜리 2개가 정답인데 그리디 알고리즘으로 풀면 100원짜리부터 선택하게 될 것이기 떄문이다.



#### 참고링크 
https://adjh54.tistory.com/212

https://velog.io/@foureaf/%ED%83%90%EC%9A%95-%EC%9A%95%EB%A7%9D-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Greedy-Algorithm%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80