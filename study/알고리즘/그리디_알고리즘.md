## 그리디 알고리즘
![그리디 알고리즘 설명](https://www.youtube.com/watch?v=_IZuE7NIeW4)

- 최적의 값을 구해야하는 상황에서 사용되는 근시적인 방법론으로서 '각 단계에서 최적이라고 생각되는 것을 선택해 나가는' 방식으로 진행하여 최종직인 해답(최종해)에 도달하는 알고리즘이다.
    - 바로 눈앞의 이익만을 쫒으며, 최적해를 찾을 수 있으면 그것을 목표로 삼고 찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는 것을 목표로 삼는다.
- 현재 시점에서 가장 좋아 보이는 선택을 하고, 한번 내린 결정은 번복하지 않고 다음 단계로 넘어간다. 앞의 선택이 이후 선택에 영향을 주지않는 것이다. 다시 말해 그리디 알고리즘은 선택을 다시 번복하지않는다. 
- 항상 최적의 값을 보장하진 않고 최적해에 근사한 값을 목표로 하는 알고리즘으로 합리적인 시간 내에 최적에 가까운 답을 찾을 수 있다는 점에서 매우 유용하다.
- 대부분의 경우 계산 속도가 빠르므로 매우 효율적이다.

## 그리디 알고리즘 주요 속성
- 문제를 풀 때 두가지 조건이 성립해야 그리디 알고리즘을 적용할 수 있다.

### 탐욕 선택 속성 
- 각 단계에서 '최선의 선택'을 했을 때 전체 문제에 대한 최적해를 구할 수 있는 경우를 말한다. 즉, 각 단계에서 가장 이상적인 선택을 하는 것이 전체적으로 최적의 결과를 가져온다는 속성이다.
    - 쉽게 말해 복잡하게 모든 경우의 수를 탐색할 필요 없이 현재 시점의 가장 좋은 선택만 따라가면 된다.
    - 단계에서 지역적으로 최선의 선택(로컬 최적해)을 내렸을 때, 그 선택이 전체 문제의 최적해를 찾는 데 기여해야 한다는 속성이다.
- 탐욕 선택 속성을 설명할때 앞의 선택이 이후 선택에 영향을 주지않는 다는 말은 이전 선택의 영향을 고려하지않아도 전체 최적해를 얻을 수 있는 구조여야한다는 말이다. 현재의 최선만 따라가도 되기 때문에, 이전 선택이 미래에 미칠 복잡한 영향을 미리 계산하거나 되돌아볼 필요가 없다.
    - 정확하게는 실제로 앞의 선택이 아예 영향을 주지않는 것은 아니지만, 그 영향을 선택에서 고려할 필요가 없는 것.

### 최적 부분 구조 
- 전체 문제의 최적해가 부분 문제의 최적해로 구성 될 수 있는 경우를 말한다. 즉, 전체 문제를 작은 부분 문제로 나누어 각각의 부분 문제에서 최적의 해를 구한 후 이를 조합하여 전체 문제의 최적해를 구하는 것을 의미한다. 
- 예를 들어 서울 -> 부산 경로를 구한다고 가정했을 때, 서울 -> 부산을 한번에 갈 수는 없고 서울 -> 대전, 대전 -> 부산이라는 단계를 거쳐야한다. 이때, 서울 -> 대전, 대전 -> 부산으로 가는 루트의 각각 최적해를 구한 합이 전체 서울 -> 부산 경로의 최적해가 된다. 


## 그리디 알고리즘 단계
- 1. 문제의 최적해 구조를 결정한다.
- 2. 선택 절차 : 현재 상태에서 최적의 선택을 한다. 이 선택은 이후에는 바뀌지않는다.
- 3. 선택 절차에 따라 선택을 수행한다.
- 4. 적절성 검사 : 선택한 항목이 문제의 조건을 만족시키는 지 확인한다. 조건을 만족시키지 않으면 해당 항목은 제외된다.
- 5. 조건을 만족하지않으면 해당 해를 제외한다.
- 5. 해답 검사 : 모든 선택이 왼료되면 최종 선택이 문제의 조건을 만족 시키는 지 확인한다. 조건을 만족 시킬 시 해답으로 인정됨.
- 6. 조건을 만족하지않으면 해답으로 인정되지않는다. 

## 그리디 알고리즘 장점
- 조건을 만족하면 빠르게 최적의 결과를 도출해낼 수 있어 속도가 빠르고 효율적이다. 전체 경우의 수를 다 확인하는 부르트 포스나 이전 상태를 저장하고 재활용하는 다이나믹 프로그래밍보다 시간복잡도가 낮다.
- 이전의 모든 선택지를 기억할 필요가 없기 때문에 공간 복잡도가 낮다. 보통 현재 값이나 누적된 결과 값만 저장할 변수 한 두개면 충분하다. 

## 그리디 알고리즘 단점
- 전역 최적해(글로벌 최적해)를 보장하지 못한다. 
    - 현재 시점에서는 최선의 선택이었지만 그 선택이 나중에 문제가 되어 전체적인 결과가 틀릴 수 있다. 예를 들어 경로를 찾을때, 짧은 길만 골라 선택했는데 알고 보니 그 길이 나중에 엄청나게 돌아가는 길일 수 있다. 반면, 처음에는 조금 긴 길을 선택했지만 후에 지름길이 나올 수 있다. 이런 식으로 후자의 선택을 고려하지 않음으로 최선의 결과를 도출해 내지 못할 수 있다.
- 선택의 번복이 불가능함으로 다이나믹 프로그래밍(DP)나 백 트래킹처럼 이전의 단계로 돌아가거나 다른 경우의 수를 고려할 수 없다. 그리디는 직진밖에 선택할 수 없다. 
- 최적 부분 구조와 탐욕 선택 속성을 갖는 문제에만 적용할 수 있기때문에 해당 조건을 만족하지않는다면 적용할 수 없다. 고로 적용할 수 있는 문제의 폭이 좁다. 
- 그리디 알고리즘은  전체 문제의 최적해가 부분 문제의 최적해로 구성될 수 있어야하는데 이를 수학적으로 증명하기가 매우 까다롭다. 정당성의 증명이 어렵다. 코테 등에서 그리디 알고리즘으로 문제를 풀이했을 때, 특정 예외 케이스(Edge Case)에서 틀리는 경우가 많다.


### 그리디 알고리즘이 사용되는 예시 
- AI의 결정 트리 학습법
- 활동 선택 문제
- 거스름돈 문제
- 최소 신장 트리
- 제약 조건이 많은 대부분의 문제
- 다익스트라 알고리즘
- 허프만 코드
- UNION & FIND 알고리즘

## 그리디 알고리즘의 예시 문제 
### 배낭 문제 
- 조합 최적화 분야의 매우 유명한 문제로 배낭에 담을 수 있는 무게의 최댓값이 정해져있고 각각 짐의 가치(가격)과 무게가 있는 짐들을 배낭에 넣을떄 가치의 합이 최대가 되도록 즉, 높은 가격을 가지도록 짐을 고르는 방법을 찾는 문제다.
    - 배낭 문제는 짐을 쪼갤 수 있는 경우인 분할 가능 배낭 문제(그리디 알고리즘으로 해결 가능)과 짐을 쪼갤 수 없는 경우인 배낭 문제(다이나믹 프로그래밍으로 해결 )로 나뉜다.

```
cargo =[
    # 가격,무게
    (4,12),
    (2,1),
    (10,4),
    (1,1),
    (2,2)
]

def fractional_knapsack(cargo):
    capacity = 15
    pack = []

    # 단가 계산 역순 정렬
    for c in cargo:
        pack.append((c[0] / c[1], c[0], c[1]))
    pack.sort(reverse=True)

    total_value : float = 0
    for p in pack:
        if capacity - p[2] >= 0:
            capacity -= p[2]
            total_value += p[1]
        else:
            fraction = capacity / p[2]
            total_value += p[1] * fraction
            break
    return total_value
```

### 동전 바꾸기 문제
- 동전의 액면이 10원, 50원, 100원처럼 증가하면서 이전 액면의 배수 이상이 되면 그리디 알고리즘으로 풀수있다.
- 예를 들어 우리나라의 동전은 항상 배수 이상임으로 그리디로 풀 수 있다. 160원을 거슬러준다면 10원 16개 보다는 100원 하나, 50원 하나, 10원하나 이런식으로 각각의 동전을 최대한 활용하는 그리디한 방법이 가장 작은 동전 개수로 거슬러 줄 수 있다.
- 하지만 80원짜리 동전이 있는 A나라의 경우에는 그리디하게 풀수없다. 160원을 거슬러 줘야한다면 80원짜리 2개가 정답인데 그리디 알고리즘으로 풀면 100원짜리부터 선택하게 될 것이기 떄문이다.



#### 참고링크 
https://adjh54.tistory.com/212

https://velog.io/@foureaf/%ED%83%90%EC%9A%95-%EC%9A%95%EB%A7%9D-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Greedy-Algorithm%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80