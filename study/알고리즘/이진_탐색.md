## 이진 탐색
- "정렬된 배열"에서 검색 범위를 줄여 나가면서 검색 값을 찾는 알고리즘으로 리스트의 중간 값과 비교하여 검색값을 찾는다.
- 중간 값을 찾아야함으로 정렬된 리스트에만 사용할 수 있지만, 검색이 반복될 때마다 검색 범위가 절반으로 줄기 때문에 속도가 빠르다.
- 탐색 범위를 절반씩 줄여나가기 때문에 선형 탐색에 비해 빠른 속도를 보장한다. 하지만 배열이 정렬 되어있어야한다는 조건이 필요함으로 배열이 정렬 되어있지않는 경우에는 정렬 작업이 필요하다. 
    -  선형탐색(Linear Search) :  배열(Array)이나 리스트(List)와 같은 데이터 구조에서 특정한 값을 찾는 알고리즘 중 하나로 이름 그대로 데이터의 처음부터 끝까지 '직선(선형)' 방향으로 하나씩 순서대로 확인하며 원하는 값을 찾는 방식
- 데이터의 양이 많은 경우에도 빠른 시간 내에 값을 찾을 수 있어 많이 활용됨.
- 이진 탐색 트리가 정렬된 구조를 저장하고 탐색하는 '자료구조'라면 이진 탐색은 정렬된 배열에서 값을 찾아내는 '알고리즘'을 지칭한다. 

### 이진 탐색 시간복잡도 
- 최선의 경우 O(1)
- 평균 및 최악의 경우 O(log N)

### 이진 탐색 동작 방식
- 1. 배열의 중간 값을 가져온다. (중간 값이 필요함으로 그래서 정렬된 배열이여야함.)
- 2. 중간 값과 검색 값을 비교한다.
    - 중간 값이 검색 값과 같다면 종료. (mid = key)
    - 중간 값보다 검색 값이 크다면 중간 값을 기준으로 배열의 오른쪽 구간을 대상으로 탐색한다. (mid < key)
    - 중간 값보다 검색 값이 작다면 중간 값을 기준으로 배열의 왼쪽 구간을 대상으로 탐색한다. (mid > key)
- 3. 값을 찾거나 간격이 비어있을 때까지 반복한다.

### 이진 탐색 장점
- 기본적으로 속도가 빠른데 매번 탐색 범위를 절반씩 줄여나가기 때문에 데이터 크기가 클수록 매우 빠른 속도를 보인다. 데이터가 늘어도 연산 속도가 데이터 크기에 비해 아주 적게 증가한다. 
- 추가적인 메모리 공간을 거의 쓰지않는다. 보통 O(1)의 공간 복잡도를 가진다. (재귀가 아닌 반복문으로 구현 시) 
    - 데이터를 따로 복사하거나 옮길 필요없이 기존 리스트의 시작, 끝, 중간 위치를 나타내는 인덱스 변수만 있으면 된다. 
- 단순히 값을 찾는 게 아니라 조건을 만족하는 최솟값/최댓값을 찾을 때(최적화 문제)도 이진 탐색 사용 가능.
    - "이 값이 조건을 만족하는가?"라는 Yes/No 질문을 던짐으로써, 특정 조건을 만족하는 최솟값 또는 최댓값을 매우 효율적으로 찾아낼 수 있다. (예: 나무 자르기, 공유기 설치 등)
    - 예를 들어, 나무를 잘라서 20m를 가져가야한다고 할 때 목재 절단기 높이를 최대 몇 m로 설정해야 하는지 맞추는 문제를 푸는 경우, 절단기 높이를 15cm로 하면 나무를 20cm로 넘게 가져갈 수 있는지 확인한다. 이러면 질문을 Yes/No로 대답할 수 있다. Yes/No로 대답할 수 있는 질문을 던지면서 범위를 절반씩 깍아내려가는 방식으로 사용한다. 
    - 다만 이런 방식으로 하려면 어느 지점을 기준으로 [Yes, Yes, Yes, No, No, No] 처럼 결과가 딱 갈려야 이진 탐색으로 그 경계선을 찾을 수 있다.
- 정렬된 데이터라는 전제 조건만 충족된다면 어떤 데이터 타입(숫자, 문자열 등)이든 적용 가능하며 로직이 단순하다. 

### 이진 탐색 단점
- 사전 정렬이 필요하다. 정렬 되어있는 데이터에만 적용 가능하다. 데이터가 정렬되어있지 않다면 정렬하는데 O(n log n)이 든다. 정렬 되지않은 대량의 데이터를 빠르게 찾기위해서는 해시 테이블을 쓰는 게 좋다. 
- 삽입 삭제가 빈번하면 매번 다시 정렬하거나 데이터를 밀어내야하기때문에 이럴 때는 이진 탐색 트리(BST) 같은 구조를 써야한다. 
- 연결 리스트처럼 무작위 접근이 어려운 불안전 자료구조에는 부적합하다. 중간 값을 바로 찾을 수 없기때문이다. 배열처럼 연속된 메모리 구조가 필요하기때문에 인덱스로 임의의 위치에 즉시 접근 가능한 구조에서만 제 성능이 나온다. 
- 소규모 데이터 셋에서는 비효율적이다. 데이터 양이 아주 적을 때는 오히려 선형 탐색이 빠를 수 있다. 
- 메모리를 건너뛰며 접근하는 특성상 하드웨어 수준의 캐시 최적화 혜택을 받기 어렵다. 선형 탐색은 메모리의 인접한 위치를 순서대로 읽기 때문에 현대 CPU의 캐시 효율이 높지만 이진 탐색은 메모리 이곳저곳(중간 지점)을 건너뛰며 확인하므로 캐시 미스(Cache Miss)가 발생할 확률이 더 높다. 다만 데이터가 많을 경우에는 캐시 미스가 좀 나더라도 이진 탐색이 비교해야하는 횟수 자체가 압도적으로 적기때문에 문제가 되지않는다. 

### 이진 탐색을 사용하는 경우
- 이진 탐색은 데이터가 이미 정렬 되어있을때
- 데이터의 양이 수만 건 이상으로 많을때
- 정적(static)인 데이터에서 반복적인 조회가 일어날때 


### 이진 탐색 구현 코드 

- 탐색을 위해 배열의 인덱스를 저장하는 left, right 포인터로 범위를 지정하고 해당 포인터들을 이용해 중앙 인덱스 값인 mid를 구한다.
- mid에 해당하는 배열의 요소 값과 찾고자 하는 값을 비교한다.
- left가 right보다 작거나 같을 때까지 탐색 과정을 반복한다.
- left가 right보다 커질 경우 탐색을 종료한다. 해당 경우는 원하는 값이 존재하지 않는 경우다.

```
class IsExistingTargetNumberBinary {
    public static boolean isExistingTargetNumberBinary(int target, int[] array) {
        int left = 0; // left 포인터 
        int right = array.length - 1; // right 포인터 
        
        int findCount = 0; // 탐색 횟수
        
        while (left <= right) {
            findCount += 1;

            // 중앙값 계산을 while문 안으로 옮기면 중복 코드가 사라진다.
            // (left + right) / 2 대신 아래 방식을 쓰면 더 안전함.
            int mid = left + (right - left) / 2;
            
            if (array[mid] == target) {
                System.out.println("탐색 횟수: " + findCount);
                return true;

            // 2. 탐색 범위 절반으로 줄이기 
            // 현재 값이 target보다 크면 target이 중간 값(mid)보다 더 뒤(오른쪽)에 있다.
            } else if (array[mid] < target) {
                left = mid + 1; // 방금 확인한 mid 값보다 한 칸 큰 쪽으로 이동.

            // 작다면 right를 왼쪽으로 옮긴다. target이 mid보다 더 앞(왼쪽)에 있기때문.
            } else { // array[mid] > target
                right = mid - 1;
            }
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        int findingTarget = 14;
        int[] findingNumbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
        
        
        // 최소                  탐색                            최대
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        //       최소                        최대
        // UP -> [9, 10, 11, 12, 13, 14, 15, 16]
        //         최소                최대
        // DOWN -> [1, 2, 3, 4, 5, 6, 7]
        //
        //
        // 최소                  탐색                            최대
        // 0                     7                             15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        //
        //                          최소        탐색             최대
        //                          8          11              15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        //
        //                                         최소 탐색     최대
        //                                         12  13      15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        
        //                                             최소 탐색 최대
        //                                             13  14  15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        
        //                                                 최소 최대
        //                                                 14  15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        
        //                                                   최소=최대
        //                                                     15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        
        
        boolean result = isExistingTargetNumberBinary(findingTarget, findingNumbers);
        System.out.println(result);
    }
}

```

#### 참고링크 

https://yoongrammer.tistory.com/75

https://adjh54.tistory.com/187

https://bkstudio.tistory.com/10