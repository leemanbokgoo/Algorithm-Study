## 이진 탐색
- "정렬된 배열"에서 검색 범위를 줄여 나가면서 검색 값을 찾는 알고리즘으로 리스트의 중간 값과 비교하여 검색값을 찾는다.
- 중간 값을 찾아야함으로 정렬된 리스트에만 사용할 수 있지만, 검색이 반복될 때마다 검색 범위가 절반으로 줄기 때문에 속도가 빠르다.
- 탐색 범위를 절반씩 줄여나가기 때문에 선형 탐색에 비해 빠른 속도를 보장한다. 하지만 배열이 정렬 되어있어야한다는 조건이 필요함으로 배열이 정렬 되어있지않는 경우에는 정렬 작업이 필요하다. 
    -  선형탐색(Linear Search) :  배열(Array)이나 리스트(List)와 같은 데이터 구조에서 특정한 값을 찾는 알고리즘 중 하나
- 데이터의 양이 많을 경우에도 빠른 시간 내에 값을 찾을 수 있어 많이 활용됨.
- 이진 탐색 트리가 정렬된 구조를 저장하고 탐색하는 '자료구조'라면 이진 탐색은 정렬된 배열에서 값을 찾아내는 '알고리즘'을 지칭한다. 

### 이진 탐색 시간복잡도 
- 최선의 경우 O(1)
- 평균 및 최악의 경우 O(log N)이다.

### 이진 탐색 동작 방식
- 1. 배열의 중간 값을 가져온다.
- 2. 중간 값과 검색 값을 비교한다.
    - 중간 값이 검색 값과 같다면 종료. (mid = key)
    - 중간 값보다 검색 값이 크다면 중간값 기준 배열의 오른쪽 구간을 대상으로 탐색한다. (mid < key)
    - 중간 값보다 검색 값이 작다면 중간값 기준 배열의 왼쪽 구간을 대상으로 탐색한다. (mid > key)
- 3. 값을 찾거나 간격이 비어있을 때까지 반복한다.

### 이진 탐색 장점
- 기본적으로 속도가 빠른데 매번 탐색 범위를 절반씩 줄여나가기 때문에 데이터 크기가 클수록 매우 빠른 속도를 보인다. 
- 정렬된 데이터 셋에서는 높은 효율성을 보인다.

### 이진 탐색 단점
- 사전 정렬이 필요하다. 정렬 되어있는 데이터에만 적용 가능
- 연결 리스트처럼 무작위 접근이 어려운 불안전 자료구조에는 부적합하다. 


### 이진 탐색 구현 코드 

- 파이썬 

- 탐색을 위해 배열의 인덱스를 저장하는 left, right 포인터로 범위를 지정하고 해당 포인터들을 이용해 중앙 인덱스 값인 mid를 구한다.
- mid에 해당하는 배열의 요소 값과 찾고자 하는 값을 비교한다.
- left가 right보다 작거나 같을 때까지 탐색 과정을 반복한다.
- left가 right보다 커질경우 탐색을 종료한다. 해당 경우는 원하는 값이 존재하지 않는 경우다.

```
finding_target = 14
finding_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]


def is_existing_target_number_binary(target, array):
    current_min = 0
    current_max = len(array) - 1
    current_guess = (current_min + current_max) // 2

    while current_min <= current_max:
        if array[current_guess] == target:
            return True
        elif array[current_guess] < target:
            current_min = current_guess + 1
        else:
            current_max = current_guess - 1
        current_guess = (current_min + current_max) // 2

    return False


result = is_existing_target_number_binary(finding_target, finding_numbers)
print(result)

```

- 자바 

```
class IsExistingTargetNumberBinary {
    public static boolean isExistingTargetNumberBinary(int target, int[] array) {
        int currentMin = 0;
        int currentMax = array.length - 1;
        int currentGuess = (currentMin + currentMax) / 2;
        
        int findCount = 0;
        
        while (currentMin <= currentMax) {
            findCount += 1;
            if (array[currentGuess] == target) {
                System.out.println(findCount);
                return true;
            } else if (array[currentGuess] < target) {
                currentMin = currentGuess + 1;
            } else { // array[currentGuess] > target
                currentMax = currentGuess - 1;
            }
            currentGuess = (currentMin + currentMax) / 2;
        }
        
        // 구현해보세요!
        return false;
    }
    
    public static void main(String[] args) {
        int findingTarget = 14;
        int[] findingNumbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
        
        
        // 최소                  탐색                            최대
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        //       최소                        최대
        // UP -> [9, 10, 11, 12, 13, 14, 15, 16]
        //         최소                최대
        // DOWN -> [1, 2, 3, 4, 5, 6, 7]
        //
        //
        // 최소                  탐색                            최대
        // 0                     7                             15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        //
        //                          최소        탐색             최대
        //                          8          11              15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        //
        //                                         최소 탐색     최대
        //                                         12  13      15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        
        //                                             최소 탐색 최대
        //                                             13  14  15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        
        //                                                 최소 최대
        //                                                 14  15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        
        //                                                   최소=최대
        //                                                     15
        // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        
        
        boolean result = isExistingTargetNumberBinary(findingTarget, findingNumbers);
        System.out.println(result);
    }
}

```

#### 참고링크 

https://yoongrammer.tistory.com/75

https://adjh54.tistory.com/187

https://bkstudio.tistory.com/10