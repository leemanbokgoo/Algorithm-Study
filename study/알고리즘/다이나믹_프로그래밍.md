## 다이나믹 프로그래밍 (동적 계획법, Dynamic Programming, DP)

- 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘이다. 다이나믹 프로그래밍 알고리즘을 이용하면 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결방법으로 구성되는 문제. 즉, 최적 부분 구조를 갖고 있는 문제를 풀이할 수 있다. 
    - 최적 구분 구조를 푸는 또 다른 알고리즘으로는 그리디 알고리즘이 있다. 
- 즉, 다이나믹 프로그래밍은 여러개의 하위 문제를 풀고, 그 결과를 기록한 뒤 문제를 해결하는 데 이용하는 알고리즘이다.
- 이처럼 문제를 반복해서 해결해 나가는 모습이 재귀 알고리즘과 닮아있지만 다른 점은 **그 결과를 기록하고 이용한다는 점**이다.
- 결과를 기록하는 것을 메모이제이션(Memoization) 이라고 하고, 문제를 쪼갤 수 있는 구조를 겹치는 부분 문제(Overlapping Subproblem)라고 한다.
- 각 구간마다의 시간을 계산하면 최적의 시간을 구할 수 있는 것을 겹치는 부분 문제, 이미 실험했던 내용은 기록해두고 쓰면 된다는 것을 메모이제이션 이라고 생각하시면 된다.
- 즉, 겹치는 부분 문제일 경우 동적 계획법을 사용하면 되는데,이 때 사용하는 방법은 메모이제이션을 이용한다고 생각하면 된다.
- **피보나치 수열**은 다이나믹 프로그래밍의 가장 기본중의 기본임으로 왠만하면 외워두면 좋다. (재귀와 다이나믹 프로그래밍을 한번에 평가할 수 있는 좋은 문제이며 알고리즘 자체가 간단하기때문에 화이트 보드 테스트에도 자주 등장한다.)
    - 특히 피보나치 수에 대한 다양한 풀이법만 제대로 익혀도 다이나믹 프로그래밍의 기본은 충분히 익혔다고 할 수 있다. 
- => 다이나믹 프로그래밍은 최적 부분 구조를 지닌 중복된 하위 문제들을 분할 정복으로 풀이하는 문재 해결 패러다임이다.


## 다이나믹 프로그래밍의 조건
- 다이나믹 프로그래밍을 적용하기 위해서는 다음의 두가지 조건을 만족해야 한다.

### 최적 부분 구조 
- 부분 문제의 최적해를 통해 전체 문제의 최적해를 구한다.
    - 예를들어 서울에서 부산까지 가는 최단 경로를 찾는 문제가 있다. 서울에서 대구까지 가는 경로는 3가지, 대구 -> 부산 경로도 3가지가 있다. 서울에서 부산까지 가는 최단경로는 200km + 80km = 280km이다. 이 경로는 서울 -> 대구까지 가는 최단 경로(200km)와 대구 -> 부산 최단 경로(80km)으로 구성된다. 즉, 서울에서 부산까지 가는 최단 경로는 각각의 부분 문제인 1) 서울에서 대구까지 가는 최단경로 문제 2)대구에서 부산까지 가는 최단 경로 문제의 해결방법의 합이다. 따라서 문제의 최적 해결 방법은 부분 문제에 대한 해결 방법으로 구성된다.
    - 이러한 구조를 최적 부분 구조라고 하며, 이런 유형의 문제는 분할 정복으로 풀 수 있다. 또한 다이나믹 프로그래밍 또는 그리디 알고리즘으로 접근해볼 수 있는 문제의 후보가 된다. 
    - 그러나 서울 -> 부산 까지 바로 연결되는 고속 도로가 새롭게 개통되어 더이상 대구를 거칠 필요가 없다면 이 문제는 더이상 최적 부분 구조가 아니다. 그렇게 되면 분할 정복, 다이나믹 프로그래밍이나 그리디 알고리즘으로도 풀이할 수 없다. 

### 중복되는 부분 문제 
- 부분 문제가 중복되어 여러번 반복 계산되어야한다. 즉, 중복된 하위 문제들을 갖는다. 문제를 나누고 그 문제의 결과 값을 재활용해서 전체의 답을 구한다. 그래서 동일한 작은 문제들이 반복하여 나타나는 경우에 사용 가능하다.
- 예를 들어 피보나치 수열을 재귀로 풀면 반복적으로 동일한 하위 문제들이 발생한다. 

### 피보나치의 수열
-  첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열이다. 처음 여섯 항은 각각 1, 1, 2, 3, 5, 8이다.
- 즉, n번째 피보나치 수를 Fibo(n)라고 표현한다면, 첫째 및 둘째 항을 1이라고 가정하기때문에 Fibo(1) 은 1이고 Fibo(2) 도 1이다. Fibo(3) 부터는 이전 값과 이전 이전 값의 합이다. 그렇게 되면 Fibo(3) = Fibo(1) + Fibo(2) = 1 + 1 = 2 이다.
- Fibo(4) = Fibo(3) + Fibo(2) = 2 + 1 = 3
- Fibo(5) = Fibo(4) + Fibo(3) = 3 + 2 = 5
- Fibo(6) = Fibo(5) + Fibo(4) = 5 + 3 = 8 ..... 임으로 
- Fibo(n) = Fibo(n - 1) + Fibo(n-2) 라고 표현할 수 있다.
```
fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2), (n >= 2)
```

#### 피보나치 수열과 재귀 함수 

```
def fibo_recursion(n):
    if n == 1 or n == 2:
        return 1
    return fibo_recursion(n - 1) + fibo_recursion(n - 2)


print(fibo_recursion(input))  # 6765
```

- 피보나치 수열을 계산하는 가장 간단한 방법은 재귀함수를 이용하는 것이다. 그러나 위 그림과 같이 반복 계산되는 문제가 생긴다. 
- 재귀함수가 그렇듯 재귀함수로 피보나치 수열을 구현하게 되면 스택 오버 플로우 문제가 발생한다. 5번째 피보나치 수열을 구하기 위해선 다음 그림과 같이 총 15번의 함수 호출이 발생한다. 숫자가 작을 때는 그나마 괜찮지만, 숫자가 조금만 커져도 시간 복잡도와 공간 복잡도가 지수 스케일로 폭발한다(Exponential Explosion) 

![image](https://github.com/user-attachments/assets/444a96f0-4e6a-4255-8c4e-91b919c9b9fc)


#### 피보나치 수열과 다이나믹 프로그래밍
- 다이나믹 프로그래밍으로 피보나치 수열을 구현하면 어떨까?
- 동적 계획법에서는 재귀 함수의 반복계산을 막기 위해 이전에 계산했던 값들을 배열에 저장한다. 대표적인 방식은 Top-down과 Bottom-up이다.
    - Top-down은 위에서 내려오는 것, 즉, 큰 문제부터 시작해서 계속 작은 문제로 분할해 가면서 푸는 것이다. fibonacci(4)를 구하는 큰 문제는 fibonacci(3)과 fibonacci(2)를 구하는 작은 문제로 나눌 수 있다. fibonacci(3)을 구하는 작은 문제는 fibonacci(2)와 fibonacci(1)을 구하는 더 작은 문제로 나눌 수 있다. 따라서 fibonacci(n)을 구하는 큰 문제를 풀 수 있다. 
    - Bottom-up은 바닥에서 올라오는 것, 즉, 작은 문제부터 시작해서 작은 문제를 점점 쌓아 큰 문제를 푸는 것이다. 첫 번째 피보나치 수를 구하는 문제와 두 번째 피보나치 수를 구하는 문제를 풀면 세 번째 피보나치 수를 구하는 문제를 풀 수 있다. 두 번째 피보나치 수를 구하는 문제와 세 번째 피보나치 수를 구하는 문제를 풀면 네 번째 피보나치 수를 구하는 문제를 풀 수 있다. 이걸 반복하면 n번째 피보나치 수를 구할 수 있다.
- 이렇게 하면 숫자를 저장하는 공간이 계속 필요한 대신 O(n)의 시간 복잡도로 빠른 속도로 구할 수 있다. 


## 다이나믹 프로그래밍 구현 방법 
- 다이나믹 프로그래밍(DP)는 특정한 경우에 사용하는 알고리즘이 아니라 하나의 방법론이므로 다양한 문제해결에 쓰일 수 있다. 그래서 다이나믹 프로그래밍을 적용할 수 있는 문제인지를 알아내는 것부터 코드를 짜는 과정이 난이도가 쉬운 것부터 어려운 것까지 다양하다.
- 일반적으로 DP를 사용하기 전에는 아래의 과정을 거쳐 진행할 수 있다.
    - 1) DP로 풀 수 있는 문제인지 확인한다.
    - 2) 문제의 변수 파악
    - 3) 변수 간 관계식 만들기(점화식)
    - 4) 메모하기(memoization or tabulation)
    - 5) 기저 상태 파악하기
    - 6) 구현하기

### 1. DP로 풀 수 있는 문제인지 확인
- 애초에 이 부분 부터 해결이 매우 어렵다. 우선 현재 직면한 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지를 판단해야 한다. 즉, 위에서 쓴 조건들이 충족되는 문제인지를 한 번 체크해보는 것이 좋다.
- 보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다

### 2. 문제의 변수 파악
- DP는 현재 변수에 따라 그 결과 값을 찾고 그것을 전달하여 재사용한다.  즉, 문제 내 변수의 개수를 알아내야한다. 이것을 영어로 "state"를 결정한다고 한다.
    - 예를 들어, 피보나치 수열에서는 n번째 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다.
    - 또한, 문자열 간의 차이를 구할 때는 문자열의 길이, Edit 거리 등 2가지 변수를 사용한다. 해당 문제를 몰라도 된다.
    - 또, 유명한 Knapsack 문제에서는 index, 무게로 2가지의 변수를 사용한다. 이와 같이 해당 문제에서 어떤 변수가 있는지를 파악해야 그에 따른 답을 구할 수 있다.

### 3. 변수 간 관계식 만들기
- 변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 또한 다이나믹 프로그래밍 시 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다. 그러한 식을 점화식이라고 부르며 그를 통해 우리면 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.
    - 예를 들어 피보나치 수열에서는 f(n) = f(n-1) + f(n-2) 였다. 이는 변수의 개수, 문제의 상황마다 모두 다를 수 있다.

### 4. 메모하기
- 변수 간 관계식까지 정상적으로 생성되었다면 변수의 값에 따른 결과를 저장해야 한다. 이것을 메모한다고 하여 Memoization이라고 부른다. 변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과를 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다. 이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.

### 5.기저 상태 파악하기
- 여기까지 진행했으면, 가장 작은 문제의 상태를 알아야 한다. 보통 몇 가지 예시를 직접 손으로 테스트하여 구성하는 경우가 많다. 
    - 피보나치 수열을 예시로 들면, f(0) = 0, f(1) = 1과 같은 방식이다. 이후 두 가지 숫자를 더해가며 값을 구하지만 가장 작은 문제는 저 2개로 볼 수 있다.
- 해당 기저 문제에 대해 파악 후 미리 배열 등에 저장해두면 된다. 이 경우, 피보나치 수열은 매우 간단했지만 문제에 따라 좀 복잡할 수 있다.
 
### 6. 구현하기
- 개념과 DP를 사용하는 조건, DP 문제를 해결하는 과정도 익혔으니 실제로 어떻게 사용할 수 있는지를 알아보고자 한다. DP는 2가지 방식으로 구현할 수 있다.
    - 1) Bottom-Up (Tabulation 방식) - 반복문 사용
    - 2) Top-Down (Memoization 방식) - 재귀 사용


## 다이나믹 프로그래밍 방법론

![image](https://github.com/user-attachments/assets/0443dce4-3549-4d46-9a72-730f942f67cd)

- 방법론은 방식에 따라 크게 상향식과 하향식으로 나뉜다. 일반적으로 상향식을 타블레이션, 하향식을 메모이제이션이라고 구분해 부르기도한다.

### 상향식 (Bottom-Up), 타뷸레이션 
- 더 작은 하위 문제 부터 살펴본 다음, 작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나간다. 타뷸레이션이라고도 부르며 일반적으로 이 방식만을 다이나믹 프로그래밍으로 지칭하기도 한다.
- 재귀적인 정의를 테이블로 구현하는 방식으로 작은 하위 문제부터 차례대로 정답을 풀어나가며 큰 문제의 정답을 만든다. 

```
def fib(n):
    dp[0] = 0
    dp[1] = 1

    for i range(2, n+1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]
```


### 하향식 (Top-Down), 메모이제이션 
- 하위 문제에 대한 정답을 계산 했는지 확인해가며 문제를 자연스러운 방식으로 풀어나간다. 이 방식을 특별히 **메모이제이션**이라 지칭한다.
- 기존 재귀 풀이와 거의 동일하면서도 이미 풀어봤는지 확인하여 재활용하는 효율적이다. 재귀 호출을 이용하되 메모이제이션을 추가하는 방식이다. 

```
def fib(n):
    if n <= 1:
        return n
    
    if dp[n]:
        return dp[n]
    
    dp[n] = fib(n - 1) + fib(n - 2)
    return dp[n]

```

### 다이나믹 프로그래밍 장점
- 중복 계산을 줄이고 효율적인 시간 복잡도를 가질 수 있다.
- 최적해를 보장한다. 최적 부분 구조를 이용해 풀기때문에 최종적으로 구하는 해답이 전역 최적해임을 보장한다. 그리디 알고리즘이 매 순간 지역 최적해만 선택하는 것과 달리, DP는 모든 가능한 경로를 고려한 후 최적의 해를 도출한 ㅊ다.

### 다이나믹 프로그래밍 단점
- 메모리 사용량이 크다. DP는 중간 결괄르 저장하기위해 추가적인 메모리를 사용한다. 따라서 문제의 크기가 커질 수록 필요한 메모리도 증가할 수 있다.
- 중복되는 하위 문제와, 최적 부분 구조라는 조건을 만족해야만 사용할 수 있다. 
- 구현이 복잡하고 난이도가 있다. DP는 문제의 패턴을 파악하고 올바른 **점화식(Recurrence Relation)**을 세우는 것이 까다롭다. 
    - 점화식이란 수열(Sequence) : 이웃하는 항들 사이의 관계를 나타내는 식. 쉽게 말해, 수열의 다음 항을 바로 앞 항들로 어떻게 계산할지를 정의하는 규칙이다. 가장 흔하게 접하는 두 가지 수열의 점화식은 등차 수열과 피보나치 수열이 있다. DP 문제를 풀기 위한 핵심은 문제를 점화식 형태로 정의하여 중복되는 하위 문제를 계산하는 방법을 찾는 것이다.


### 다이나믹 프로그래밍을 사용할 수 있는 문제
- 피보나치 수열 
- 배낭 문제 
- 최장 증가 부분 수열
- 최단 경로 문제 
- 문자열 편집 거리 문제 


## 다이나믹 프로그래밍 VS 그리디 알고리즘 
- 그리디 알고리즘은 항상 그 순간에 최적이라고 생각되는 것을 선택하면서 풀이해 나가는 것이고, 다이나믹 프로그래밍은 중복된 하위 문제들의 결과를 저장해뒀다가 풀이해 나간다는 차이가 있다. 
- 여기서 중요한 점은 **중복된 문제들**이라는 점이며 **중복되지않는 문제들은 다이나믹 프로그래밍으로 풀지않는다.**
    - 병합 정렬과 퀵 정렬등이 있으며 이들은 모두 분할 정복 알고리즘으로 분류한다. 
- 다익스트라 알고리즘은 다이나믹 프로그래밍과 그리디 알고리즘 둘다 해당하는 경우인데 BFS(너비 우선 탐색)시 항상 최단 경로를 찾고 탐욕 선택 속성을 갖는 그리디 알고리즘이면서, 이미 계산한 경로는 저장해두었다가 활용하며 중복된 하위 문제들을 푸는 다이나믹 알고리즘이기도하다. 즉, 다익스트라 알고리즘은 '최적 부분 구조', '중복된 하위 문제들', '탐욕 선택 속성'을 모두 갖는 알고리즘이다.


### 다이나믹 프로그래밍 VS 분할정복
- 다이나믹 프로그래밍과 분할정복과 차이가 생기는 부분은 원래의 문제를 부분 문제로 나누는 방식에 있다.
    -  동적 계획법의 경우, 주어진 문제를 나눌 때 부분 문제를 최대한 많이 이용하도록 나눈 다음, 주어진 부분 문제의 정답을 한 번만 계산하고 저장해둔 뒤 다시 한 번 이 부분 문제를 이용할 때에는 저장해둔 정답을 바로 산출하여 이용함으로써 속도를 향상시킨다.
- 즉, **하위 문제의 중복성** 차이라고 할 수 있다.

- 분할정복은 큰 문제를 더 작고 **독립적인**하위 문제로 나누고, 이들을 각각 해결한 뒤 결과를 결합하여 문제의 해답을 얻는다. 
    - 하위 문제의 성격: 하위 문제들이 서로 겹치지 않는다. 한 하위 문제의 해결 과정이 다른 하위 문제에 영향을 미치거나 그 결과를 재사용할 필요가 없다.
    - 비용 효율성: 각 하위 문제가 한 번만 계산되므로, 중복 계산을 방지하기 위한 추가적인 메모리 저장(메모이제이션)이 필요 없다.
    - 예시: **병합 정렬 (Merge Sort)**이나 **퀵 정렬 (Quick Sort)**을 생각하면 된다. 배열을 반으로 나누었을 때, 왼쪽 반을 정렬하는 과정은 오른쪽 반을 정렬하는 과정과 완전히 독립적이다.

- 다이나믹 프로그래밍은 큰 문제를 더 작고 중복되는 (Overlapping) 하위 문제로 나누고, 각 하위 문제의 해답을 딱 한 번만 계산하여 저장해 둔다.
    - 하위 문제의 성격: 문제를 해결하는 과정에서 같은 하위 문제가 반복적으로 발생하며. 즉, 여러 번 재활용 된다.
    - 비용 효율성: 중복되는 하위 문제를 계산할 때마다 다시 계산하는 대신, 이전에 계산하여 저장해 둔 결과를 꺼내 **재활용 (메모이제이션/테이블화)**함으로써 시간을 크게 단축한다.
    - 예시 ) 피보나치 수열이 대표적이다. fib(5)를 계산하려면 fib(4)와 fib(3)이 필요하다. fib(4)를 계산하려면 fib(3)과 fib(2)가 필요하다.여기서 fib(3)이 두 번 필요하게 되는데, DP는 fib(3)을 한 번만 계산하고 저장했다가 두 번째 호출에서 바로 사용한다.





#### 참고링크 
https://ai-sinq.tistory.com/entry/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Dynamic-Programming-DP

https://ai-sinq.tistory.com/entry/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Dynamic-Programming-DP

https://velog.io/@boyeon_jeong/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming

https://hongjw1938.tistory.com/47