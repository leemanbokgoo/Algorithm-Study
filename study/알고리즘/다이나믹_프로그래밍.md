## 다이나믹 프로그래밍 (동적 계획법, Dynamic Programming, DP)

- 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘이다. 다이나믹 프로그래밍 알고리즘을 이용하면 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결방법으로 구성되는 문제. 즉, 최적 부분 구조를 갖고 있는 문제를 풀이할 수 있다. 
    - 최적 구분 구조를 푸는 또 다른 알고리즘으로는 그리디 알고리즘이 있다. 
- 즉, 다이나믹 프로그래밍은 여러 개의 하위 문제를 풀고, 그 결과를 기록한 뒤 문제를 해결하는 데 이용하는 알고리즘이다.
- 이처럼 문제를 반복해서 해결해 나가는 모습이 재귀 알고리즘과 닮아있지만 다른 점은 **그 결과를 기록하고 이용한다는 점**이다.
- 결과를 기록하는 것을 메모이제이션(Memoization) 이라고 하고, 문제를 쪼갤 수 있는 구조를 겹치는 부분 문제(Overlapping Subproblem)라고 한다. 즉, 겹치는 부분 문제일 경우 동적 계획법을 사용하면 되는데,이 때 사용하는 방법이 메모이제이션이라고 생각하면 된다.
- 각 구간마다의 시간을 계산하면 전체의 최적의 시간을 구할 수 있는 문제가 겹치는 부분 문제, 부분 문제에서 얻어낸 해결법을 기록해두고 쓰는 것을 메모이제이션 이라고 생각하면 된다.
    - 메모(memo)해두고 재사용(ization)한다는 뜻. 
- => 다이나믹 프로그래밍은 최적 부분 구조를 지닌 중복된 하위 문제의 중복 계산을 막기위해 메모제이션을 활용하는 알고리즘 설계 기법이다.
    - 다이나믹 프로그래밍은 최적 부분 구조와 겹치는 부분문제(중복된 하위 문제)의 성질을 둘다 가진다.  

- **피보나치 수열**은 다이나믹 프로그래밍의 가장 기본 중의 기본임으로 외워두면 좋다. (재귀와 다이나믹 프로그래밍을 한번에 평가할 수 있는 좋은 문제이며 알고리즘 자체가 간단하기때문에 화이트 보드 테스트에도 자주 등장한다.)
    - 특히 피보나치 수에 대한 다양한 풀이법만 제대로 익혀도 다이나믹 프로그래밍의 기본은 충분히 익혔다고 할 수 있다. 


## 다이나믹 프로그래밍의 조건
- 다이나믹 프로그래밍을 적용하기 위해서는 다음의 두가지 조건을 만족해야 한다.

### 최적 부분 구조 
- 부분 문제의 최적해를 통해 전체 문제의 최적해를 구한다.
    - 예를들어 서울에서 부산까지 가는 최단 경로를 찾는 문제가 있다. 서울에서 대구까지 가는 경로는 3가지, 대구 -> 부산 경로도 3가지가 있다. 서울에서 부산까지 가는 최단경로는 200km + 80km = 280km이다. 이 경로는 서울 -> 대구까지 가는 최단 경로(200km)와 대구 -> 부산 최단 경로(80km)으로 구성된다. 즉, 서울에서 부산까지 가는 최단 경로는 각각의 부분 문제인 1) 서울에서 대구까지 가는 최단경로 문제 2)대구에서 부산까지 가는 최단 경로 문제의 해결방법의 합이다. 따라서 문제의 최적 해결 방법은 부분 문제에 대한 해결 방법으로 구성된다.
    - 이러한 구조를 최적 부분 구조라고 하며, 이런 유형의 문제는 DP나 분할 정복, 그리디 알고리즘으로도 풀 수 있는 문제의 후보가 된다. 
    - 그러나 서울 -> 부산 까지 바로 연결되는 고속 도로가 새롭게 개통되어 더이상 대구를 거칠 필요가 없다면 이 문제는 더이상 최적 부분 구조가 아니다. 그렇게 되면 분할 정복, 다이나믹 프로그래밍이나 그리디 알고리즘으로도 풀이할 수 없다. 

### 중복되는 부분 문제 , 겹치는 부분 문제 
- 부분 문제가 중복되어 여러번 반복 계산되어야한다. 즉, 중복된 하위 문제들을 갖는다. 문제를 나누고 그 문제의 결과 값을 재활용해서 전체의 답을 구한다. 그래서 동일한 작은 문제들이 반복하여 나타나는 경우에 사용 가능하다.
- 예를 들어 피보나치 수열을 재귀로 풀면 반복적으로 동일한 하위 문제들이 발생한다. 

### 다이나믹 프로그래밍 장점
- 중복 계산을 줄이고 효율적인 시간 복잡도를 가질 수 있다.
    - 일반 재귀 방식으로 구현하면 여러번 계산하겠지만 다이나믹 프로그래밍은 부분 문제의 해를 기록함으로 연산 횟수를 줄 일 수 있다. 
- 하위 문제의 결과를 보존하기 때문에 안정적이다. 
    - 한번 계산 된 결과는 메모리(DP 테이블)에 영구적으로 보관된다. 실시간으로 데이터가 추가되거나 쿼리가 반복되는 환경에서 이미 계산된 하위 문제의 답을 즉시 반환할 수 있어 효율적이다. 
- 최적해를 보장한다. 최적 부분 구조를 이용해 풀기때문에 최종적으로 구하는 해답이 전역 최적해(전체 문제의 최적해)임을 보장한다. 그리디 알고리즘이 매 순간 지역 최적해만 선택하는 것과 달리, DP는 모든 가능한 경로를 고려한 후 최적의 해를 도출한다. 

### 다이나믹 프로그래밍 단점
- 메모리 사용량이 크다. 
    - DP는 중간 결과를 저장하기위해 추가적인 메모리를 사용한다. 따라서 문제의 크기가 커질 수록 필요한 메모리도 증가할 수 있다.
- 중복되는 하위 문제와, 최적 부분 구조라는 조건을 만족해야만 사용할 수 있다. 
- 구현이 복잡하고 난이도가 있다. DP는 문제의 패턴을 파악하고 올바른 **점화식(Recurrence Relation)**을 세우는 것이 까다롭다. 
    - 점화식 : 큰 문제의 정답을 구하기 위해, 바로 직전 단계나 그보다 작은 하위 문제들의 정답을 어떻게 조합할지 정의한 논리적 공식이다. 가장 흔하게 접하는 점화식은 등차 수열과 피보나치 수열이 있다. DP 문제를 풀기 위한 핵심은 문제를 점화식 형태로 정의하여 중복되는 하위 문제를 계산하는 방법을 찾는 것이다.
    - 부분 하위 문제의 답이 정확하다는 가정 하에 다음 단계의 답을 도출하기때문에 하위 문제의 결과가 잘못되면 그 결과를 사용하는 모든 상위 단계의 답이 오염된다. 또한 Bottom-up 방식의 경우, 앞선 단계의 계산이 완료되어야만 다음 단계로 넘어갈 수 있어 엄격한 계산 순서를 지켜야한다. 


## 다이나믹 프로그래밍 구현 방법 
- 다이나믹 프로그래밍(DP)는 특정한 경우에 사용하는 알고리즘이 아니라 하나의 방법론이므로 다양한 문제해결에 쓰일 수 있다. 그래서 다이나믹 프로그래밍을 적용할 수 있는 문제인지를 알아내는 것부터 코드를 짜는 과정이 난이도가 쉬운 것부터 어려운 것까지 다양하다.
- 일반적으로 DP를 사용하기 전에는 아래의 과정을 거쳐 진행할 수 있다.
    - 1) DP로 풀 수 있는 문제인지 확인한다.
    - 2) 문제의 변수 파악
    - 3) 변수 간 관계식 만들기(점화식)
    - 4) 메모하기(memoization or tabulation)
    - 5) 기저 상태 파악하기
    - 6) 구현하기

### 1. DP로 풀 수 있는 문제인지 확인
- 애초에 이 부분부터 해결이 매우 어렵다. 우선 현재 직면한 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지를 판단해야 한다.
- 보통 특정 데이터 내 최대화/최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.참고로 특정 조건에서 최대/최소를 구할때 지금 당장의 최선의 선택이 나중에도 최선이면 그리디. 지금의 선택이 나중에 영향을 미쳐서 모든 경우를 따져봐야하면 DP이다.

### 2. 문제의 변수 파악
- DP는 현재 변수에 따라 그 결과 값을 찾고 그것을 전달하여 재사용한다. 즉, 문제 내 변수의 개수를 알아내야한다. 이것을 영어로 "state"를 결정한다고 한다.
    - 예를 들어, 피보나치 수열에서는 n번째 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다. 또한, 문자열 간의 차이를 구할 때는 문자열의 길이, Edit 거리 등 2가지 변수를 사용하거나 유명한 Knapsack 문제에서는 index, 무게로 2가지의 변수를 사용한다. 이와 같이 해당 문제에서 어떤 변수가 있는지를 파악해야 그에 따른 답을 구할 수 있다.

### 3. 변수 간 관계식 만들기
- 변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 또한 다이나믹 프로그래밍 시 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다. 그러한 식을 점화식이라고 부르며 이를 통해 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.
    - 예를 들어 피보나치 수열에서는 f(n) = f(n-1) + f(n-2)라는 단순한 점화식을 갖지만 실제 문제에서는 변수의 개수나 연산 방식(더하기, 최댓값 찾기 등)이 문제의 상황마다 다를 수 있다.

### 4. 메모하기(Memoization)
- 변수 간 관계식까지 정상적으로 생성되었다면 변수의 값에 따른 결과를 저장해야 한다. 이것을 메모한다고 하여 Memoization이라고 부른다
- 변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과가 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나가는 방식이다. 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.
    - Memoization(Top-Down) :  필요한 부분 문제만 호출, Lazy Evaluation 방식임.
    - Tabulation(Bottom-Up) : 작은 문제부터 순서대로 모두 채우는 방식이며 반복문을 사용하기 때문에 함수 호출 오버헤드가 없어 일반적으로 더 빠르다. 

### 5.기저 상태(Base Case) 파악하기
- 여기까지 진행했으면, 가장 작은 문제(Base Case)의 상태를 알아야 한다. 보통 몇 가지 예시를 직접 손으로 테스트하여 구성하는 경우가 많다. 
    - 피보나치 수열을 예시로 들면, f(0) = 0, f(1) = 1과 같은 방식이다. 이후 두 가지 숫자를 더해가며 값을 구하지만 가장 작은 문제는 저 2개로 볼 수 있다.
- 해당 기저 문제에 대해 파악 후 미리 배열 등에 저장해두면 된다. 이 경우, 피보나치 수열은 매우 간단했지만 문제에 따라 좀 복잡할 수 있다.
 
### 6. 구현하기
-  DP는 2가지 방식으로 구현할 수 있다.
    - 1) Bottom-Up (Tabulation 방식) - 반복문 사용
    - 2) Top-Down (Memoization 방식) - 재귀 사용


## 다이나믹 프로그래밍 구현 방법 

![image](https://github.com/user-attachments/assets/0443dce4-3549-4d46-9a72-730f942f67cd)

- DP는 풀이 방향에 따라 **상향식(Bottom-Up)**과 **하향식(Top-Down)**으로 나뉜다. 일반적으로 상향식은 표를 채워 나간다는 의미의 타뷸레이션, 하향식은 계산 결과를 기억한다는 의미의 메모이제이션과 혼용하여 부르기도 한다

### 상향식 (Bottom-Up), 타뷸레이션
- 더 작은 하위 문제부터 살펴 본 다음, 작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나간다. 타뷸레이션이라고도 부르며 학술적으로는 이 방식만을 다이나믹 프로그래밍으로 지칭하기도 하지만 코테나 실무에서는 하향식도 DP로 본다. 
- 재귀적인 정의를 반복문을 통해 테이블로 구현하는 방식으로 작은 하위 문제부터 차례대로 정답을 풀어나가며 큰 문제의 정답을 만든다. 

```
public class Fibonacci {
    public int fib(int n) {
        // 1. 기저 상태(Base Case) 예외 처리
        if (n <= 1) {
            return n;
        }

        // 2. 데이터를 저장할 테이블(배열) 생성 (n까지 저장해야 하므로 크기는 n+1)
        int[] dp = new int[n + 1];

        // 3. 초기값 설정
        dp[0] = 0;
        dp[1] = 1;

        // 4. 반복문(for)을 이용해 작은 문제부터 큰 문제까지 채우기 (상향식)
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        // 5. 최종 결과 반환
        return dp[n];
    }
}
```

### 하향식 (Top-Down), 메모이제이션 
- 하위 문제에 대한 정답을 계산 했는지 확인해가며 문제를 자연스러운 방식으로 풀어나간다. 이 방식을 특별히 **메모이제이션**이라 지칭한다.
- 기존 재귀 풀이와 거의 동일하면서도 이미 풀어봤는지 확인하여 재활용하는 효율적인 방식이다. 재귀 호출을 이용하되 메모이제이션을 추가하는 방식이라고 할 수 있다. 

```
public class Fibonacci {
    // 이미 계산된 값을 저장할 메모장 (배열)
    static int[] memo;

    public int fib(int n) {
        // 배열 크기 설정 (0부터 n까지 인덱스가 필요하므로 n+1)
        memo = new int[n + 1];
        return topDown(n);
    }

    private int topDown(int n) {
        // 1. 기저 상태 (Base Case): 0이나 1이면 바로 반환
        if (n <= 1) {
            return n;
        }

        // 2. 메모이제이션: 이미 계산한 적이 있다면(0이 아니라면) 바로 반환
        if (memo[n] != 0) {
            return memo[n];
        }

        // 3. 재귀 호출: 큰 문제를 풀기 위해 작은 문제들을 호출 (하향식)
        // 계산 결과를 메모장에 기록(Memoization)
        memo[n] = topDown(n - 1) + topDown(n - 2);

        return memo[n];
    }
}
```

### 다이나믹 프로그래밍을 사용할 수 있는 문제
- 최솟값/최댓값 : ~하는 방법 중 최소비용(또는 최대 가치)를 구하는 문제 
    - ex) 배낭 문제, 최단 경로 문제, 문자열 편집 
- 경우의 수 : ~하는 방법은 총 몇 가지인지 구하는 문제 
    - ex) 계단 오르기, 타일 채우기, 피보나치 수열
- 최적화 : 가장 효율적인 경로/순서를 찾는 문제 
    - ex) 행렬 곱셈 순서, 최장 공통 부분 수열(LSC)
- 연속/누적 : 이전까지의 합이 다음 계산에 영향을 주는 문제 
    - ex) 구간 합, 가장 긴 증가하는 수열(LIS)
- 모든 경우의 수를 다 합했을 때 답이 나올 것 같은데 데이터 범위가 커서 시간 초과가 날 것 같은 경우. 

## 다이나믹 프로그래밍 VS 그리디 알고리즘 
- 그리디 알고리즘은 항상 그 순간에 최적이라고 생각되는 것을 선택하면서 풀이해 나가는 것이고, 다이나믹 프로그래밍은 중복된 하위 문제들의 결과를 저장해뒀다가 풀이해 나간다는 차이가 있다. 
- 여기서 중요한 점은 DP의 핵심은 **중복된 하위 문제들**이라는 점이며 하위 문제가 중복되지 않는다면 굳이 메모리를 써서 결과를 저장할 필요가 없기때문에 DP를 사용하지 않는다.
    - 예를 들어 병합 정렬과 퀵 정렬은 문제를 나누지만 나누어진 부분들이 서로 겹치지않는 독립적인 형태가 되므로 DP가 아닌 분할 정복 알고리즘으로 분류한다. 
- 다익스트라 알고리즘은 다이나믹 프로그래밍과 그리디 알고리즘 둘다 해당하는 독특한 사례다.
    - 우선순위 큐를 이용한 BFS(너비 우선 탐색) 과정에서 항상 최단 거리 경로를 우선적으로 선택하는 탐욕 선택 속성을 갖는 그리디 알고리즘이면서, 이미 계산한 경로는 저장해두었다가 활용하며 중복된 하위 문제들을 푸는 다이나믹 알고리즘이기도하다. 
    - 즉, 다익스트라 알고리즘은 '최적 부분 구조', '중복된 하위 문제들', '탐욕 선택 속성'을 모두 갖는 알고리즘이다.

### 그리디 알고리즘 혹은 다이나믹 프로그래밍을 선택하는 기준
- 지금의 순간의 최선이 나중에도 최선일때(탐욕적 선택) YES라면 그리디, NO 라면 DP
- 문제가 중복되어 나타나서 문제를 풀때 똑같은 계산을 반복하고있다면 높은 확률로 DP라고 생각하면 된다.


### 다이나믹 프로그래밍 VS 분할정복
- 다이나믹 프로그래밍과 분할정복과 차이가 생기는 부분은 원래의 문제를 부분 문제로 나누는 방식에 있다.
    -  동적 계획법의 경우, 주어진 문제를 나눌 때 부분 문제를 최대한 많이 이용하도록 나눈 다음, 주어진 부분 문제의 정답을 한 번만 계산하고 저장해둔 뒤 다시 한 번 이 부분 문제를 이용할 때는 저장해둔 정답을 바로 산출하여 이용함으로써 속도를 향상시킨다.
- 즉, **하위 문제의 중복성** 차이라고 할 수 있다.

- 분할정복은 큰 문제를 더 작은 **독립적인** 하위 문제로 나누고, 이들을 각각 해결한 뒤 결과를 결합하여 문제의 해답을 얻는다. 
    - 하위 문제의 성격: 하위 문제들이 서로 겹치지 않는다. 한 하위 문제의 해결 과정이 다른 하위 문제에 영향을 미치거나 그 결과를 재사용할 필요가 없다.
    - 비용 효율성: 각 하위 문제가 한 번만 계산되므로, 중복 계산을 방지하기 위한 추가적인 메모리 저장(메모이제이션)이 필요 없다.
    - 예시: **병합 정렬 (Merge Sort)**이나 **퀵 정렬 (Quick Sort)**을 생각하면 된다. 배열을 반으로 나누었을 때, 왼쪽 반을 정렬하는 과정과 오른쪽 반을 정렬하는 과정은 완전히 독립적이다.

- 다이나믹 프로그래밍은 큰 문제를 더 작고 중복되는 (Overlapping) 하위 문제로 나누고, 각 하위 문제의 해답을 딱 한 번만 계산하여 저장해 둔다.
    - 하위 문제의 성격: 문제를 해결하는 과정에서 같은 하위 문제가 반복적으로 발생한다. 즉, 여러 번 재활용 된다.
    - 비용 효율성: 중복되는 하위 문제를 계산할 때마다 다시 계산하는 대신, 이전에 계산하여 저장해 둔 결과를 꺼내 **재활용 (메모이제이션/테이블화)**함으로써 시간을 크게 단축한다.
    - 예시 ) 피보나치 수열이 대표적이다. fib(5)를 계산하려면 fib(4)와 fib(3)이 필요하다. fib(4)를 계산하려면 fib(3)과 fib(2)가 필요하다. 여기서 fib(3)이 두 번 필요하게 되는데, DP는 fib(3)을 한 번만 계산하고 저장했다가 두 번째 호출에서 바로 사용한다.




## 피보나치 수열과 다이나믹 프로그래밍

### 피보나치 수열
-  피보나치 수열은 바로 앞의 두항을 더하면 그 다음항이 된다는 규칙을 따른다. 순서를 나타낸다면 (n) + (n+1) = n+2 가 되는 것이다. 
- n번째 피보나치 수를 Fibo(n)라고 표현한다면, 보통 Fibo(0) = 0, Fibo(1) = 1로 정의한다. Fibo(2)부터는 이전 값과 전전 값의 합으로 계산한다. 
- 피보나치 수열의 공식은 다음과 같다. fib(n) = fib(n-1) + fib(n-2)
    - 예를 들어 Fibo(2) = Fibo(1) + Fibo(0) = 1 + 0 = 1 이다.
    - Fibo(3) = Fibo(2) + Fibo(1) = 1 + 1 = 2
    - Fibo(4) = Fibo(3) + Fibo(2) = 2 + 1 = 3
    - Fibo(5) = Fibo(4) + Fibo(3) = 3 + 2 = 5
    - 이를 일반화하면 Fibo(n) = Fibo(n - 1) + Fibo(n - 2) 라고 표현할 수 있다.
    - 참고로 Fibo(2) + Fibo(1) = 1 + 1 인 이유는 수열을 시작하기 위해 최초의 계산을 하려면 1과 1을 더해서 2를 만들어야하기때문에 첫 시작은 1 + 1을 하도록 규칙이 정해진 것이다. 피보나치 수열은 더해서 나온 값을 계산에 다시 재활용되기때문에 1 + 1을 해야 2라는 숫자가 생긴다.

```
fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2), (n >= 2)
```

### 재귀 함수로 피보나치 수열 풀이

```
public class Fibonacci {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // 입력 받기 (예: 20)
        int n = sc.nextInt();
        // 결과 출력
        System.out.println(fiboRecursion(n));
        
        sc.close();
    }

    // 파이썬의 fibo_recursion과 동일한 로직
    public static int fiboRecursion(int n) {
        // 기저 상태 (Base Case)
        if (n == 1 || n == 2) {
            return 1;
        }
        
        // 재귀 호출
        return fiboRecursion(n - 1) + fiboRecursion(n - 2);
    }
}
```

- 피보나치 수열을 계산하는 가장 간단한 방법은 재귀함수를 이용하는 것이다. 그러나 위 그림과 같이 반복 계산되는 문제가 생긴다. 
- 재귀함수가 그렇듯 재귀함수로 피보나치 수열을 구현하게 되면 스택 오버 플로우 문제가 발생한다. 5번째 피보나치 수열을 구하기 위해선 총 15번의 함수 호출이 발생한다. 숫자가 작을 때는 그나마 괜찮지만, 숫자가 조금만 커져도 시간 복잡도와 공간 복잡도가 지수 스케일로 폭발한다(Exponential Explosion) 

### 다이나믹 프로그래밍으로 피보나치 수열 풀이 
- 동적 계획법에서는 재귀 함수의 반복계산을 막기 위해 이전에 계산했던 값들을 배열에 저장한다. 대표적인 방식은 Top-down과 Bottom-up이다.
    - Top-down(하향식)은 위에서 내려오는 것, 즉, 큰 문제부터 시작해서 계속 작은 문제로 분할해 가면서 푸는 것이다. fibonacci(4)를 구하는 큰 문제는 fibonacci(3)과 fibonacci(2)를 구하는 작은 문제로 나눌 수 있다. fibonacci(3)을 구하는 작은 문제는 fibonacci(2)와 fibonacci(1)을 구하는 더 작은 문제로 나눌 수 있다. 이렇게 구한 작은 문제의 값으로 fibonacci(4)라는 더 큰 문제의 값을 구할 수 있다. 
    - Bottom-up(상향식)은 바닥에서 올라오는 것, 즉, 작은 문제부터 시작해서 작은 문제를 점점 쌓아 큰 문제를 푸는 것이다. 첫 번째 피보나치 수를 구하는 문제와 두 번째 피보나치 수를 구하는 문제를 풀면 세 번째 피보나치 수를 구하는 문제를 풀 수 있다. 두 번째 피보나치 수를 구하는 문제와 세 번째 피보나치 수를 구하는 문제를 풀면 네 번째 피보나치 수를 구하는 문제를 풀 수 있다. 이걸 반복하면 n번째 피보나치 수를 구할 수 있다.
- 이렇게 하면 숫자를 저장하는 공간이 계속 필요한 대신 빠른 속도(O(n)의 시간 복잡도)로 구할 수 있다. 

![image](https://github.com/user-attachments/assets/444a96f0-4e6a-4255-8c4e-91b919c9b9fc)



#### 참고링크 
https://ai-sinq.tistory.com/entry/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Dynamic-Programming-DP

https://ai-sinq.tistory.com/entry/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Dynamic-Programming-DP

https://velog.io/@boyeon_jeong/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming

https://hongjw1938.tistory.com/47