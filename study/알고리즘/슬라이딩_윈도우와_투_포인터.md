
## 슬라이딩 윈도우(Sliding Window)

![image](https://github.com/user-attachments/assets/d8c6bdd9-1bbd-4538-9b86-a032d16023fc)

- 윈도우라고 불리는 특정 구간을 이동시키면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 알고리즘. 데이터가 연속적이여야 하며, 배열의 순서가 바뀌면 안될 때 주로 사용한다.
    - 윈도우는 고정 크기일 수도 있고 아닐 수도 있다. 고정 크기 윈도우일는 한 칸 전진 할때 새로 들어오는 요소는 더하고 나가는 요소는 뺴는 방식으로 중복 계산을 방지한다. 
    - 가변 크기일 때는 특정 조건을 만족 할때까지 윈도우의 오른쪽을 늘리고 조건을 만족하면 왼쪽을 줄이며 최적의 구간을 찾는다.
- 슬라이딩 윈도우의 동작 방법은 다음과 같다. 윈도우를 밀면서 한칸 오른쪽으로 이동한다.
    - 1. 새로운 요소 추가 : 윈도우 오른쪽 끝에 새로 들어오는 값을 더한다.
    - 2. 기존 요소 제거 : 윈도우의 왼쪽 끝에서 빠져나가는 값을 뺀다.
    - 3. 중간 요소 유지 : 두 끝을 제외한 나머지 요소들은 계산 된 상태 그대로 유지한다. 
- 슬라이딩 윈도우는 구간을 관리하기 위해 투 포인터(Left, Right) 기법을 도구로 사용하며, 특히 가변 크기 문제에서는 두 포인터의 이동이 핵심적인 역할이다. 

### 장점 
- 1. 중복 계산을 방지함으로 연산 횟수를 줄여 효율적이다. 
    - 이미 계산된 구간의 결과값에서, 윈도우가 이동하며 발생하는 '변화량(양 끝값)'만 반영하여 다음 구간의 결과값을 즉시 도출해내는 최적화 기법을 사용한다. 즉, 계산 값을 재사용하고 변화만 반영한다. 
- 2. 현재 구간(윈도우)에 대한 정보만 들고 있으면 된다. 
    - 모든 부분 배열의 합을 미리 계산해서 저장해둘 필요가 없다. 현재의 윈도우 합(또는 상태)을 나타내는 변수 하나만 계속 업데이트하며 재사용하기 때문에 공간 복잡도를 매우 낮게(O(1) 혹은 상태 관리를 위한 최소한의 메모리) 유지한다. 
- 3. 실시간 데이터 처리에 유리하다. 
    - 데이터가 한꺼번에 주어지지 않고 하나씩 계속 들어오는 상황에서 주로 사용된다. 데이터가 실시간으로 입력될 때, 전체를 다시 계산할 필요 없이 새로 들어온 값과 방금 나간 값만 처리하면 즉시 현재의 통계(평균, 최댓값 등)를 낼 수 있다. 네트워크 트래픽 감시, 실시간 주식 차트의 이동평균선 계산 등에서 필수적으로 사용된다.

### 단점
- 1. 데이터가 연속적이여야만 사용할 수 있다. 
    - 슬라이딩 윈도우는 데이터가 물리적으로든 논리적으로든 순서대로 이어져 있을 때만 사용할 수 있다. 부분 집합을 구하는 문제처럼 요소들이 떨어져있어도 상관없는 경우에는 사용할 수 없다. 
- 2. 윈도우 내부 요소의 순서나 개별 정보를 파악하기 어렵다. (어렵다는 거지 불가능하진 않음.)
    - 윈도우는 보통 **'구간의 합'** 같은 통계적인 수치를 빠르게 구하는데 특화되어있다. 윈도우 내부에 특정 숫자가 몇 번째 인덱스에 있는지, 혹은 내부 요소들이 특정 순서로 정렬되어 있는지 등을 확인하려면 별도의 복잡한 자료구조(해시맵, 덱 등)를 추가해야한다. 최댓값/최솟값을 구할 수 있으며 성능도 빠르지만 구현이 복잡해진다. 
    - 하지만 실제 코테에서는 슬라이딩 윈도우 + 자료구조 조합을 자주 쓴다. 순수 슬라이딩 윈도우는 정보 유지 능력이 낮다는 한계가 있지만, 이를 자료구조로 보완하는 방식이 현대 알고리즘 풀이의 핵심이다.
- 3. 삭제 연산이 불가능한 경우의 한계 
    - 평균이나 합산의 경우 단순히 계산 값에서 들어온 값을 더하고 나간값을 빼면 되지만 곱셈의 경우 나가는 값을 나누기 해야하는데 배열에 0이 하나라도 존재하면 곱하기도 나누기도 안된다. 
    - 또한 최솟값, 최댓값을 구하는 경우, 윈도우에서 가장 큰 값이 빠져나갔을 때, 그다음으로 큰 값이 무엇인지는 단순히 빼기 연산만으로는 알 수 없다. 단조 큐라는 추가적인 기법이 필요해서 구현이 복잡해진다. 

### 사용 하지 말아야할 상황
- 데이터가 불연속적이거나 순서가 중요하지 않을 때. (ex 부분 집합 구하기)
- 윈도우에서 빠져나가는 값이 전체 결과에 미치는 영향을 단순 연산으로 되돌릴 수 없을 때, 윈도우 내부의 모든 개별 요소의 위치나 상태를 실시간으로 파악해야 할 때
    - 하지만 Deque(단조 큐)나 Priority Queue 같은 추가 자료구조를 같이 사용하면 구현 가능하며 시간 복잡도를 똑같이 O(N)으로 유지할 수 있기때문에 코테 등에서 자주 사용되는 조합이다.  

## 사용 하기 좋은 상황
- 연속적인 단어가 보일때
    - 연속된 K일, 연속된 부분 문자열, 인접한 요소 등의 표현이 있다면 90% 확률로 슬라이딩 윈도우나 투 포인터 문제다. 데이터를 건너뛰지않고 덩어리로 묶어서 이동해야 하기 때문.
- 고정된 길이의 구간을 처리할때
    - 3일간의 이동 평균, 길이가 5인 모든 부분 문자열 같이 조사해야 할 구간의 너비가 정해져있다면 슬라이딩 윈도우가 가장 빠르다.
- O(n^2) 풀이를 O(n)으로 줄여야 할 때
    - 중첩 반복문(for문 안에 for문)으로 풀었더니 시간 초과가 난다면 슬라이딩 윈도우를 의심하는 편이 좋다. 
    - 이중 for문은 구간을 옮길 때마다 매번 다시 계산 O(n X k) 해야하지만 슬라이딩 윈도우는 O(N)이 걸린다. 
- 실시간으로 통계치를 업데이트 해야할때.
    - 데이터가 멈춰있지 않고 계속해서 들어오는 상황에서 현재 시점의 최댓값, 최솟값, 혹은 평균을 유지해야 할 때 사용한다. 
    - ex) 주식 차트의 5일 이동평균선, 네트워크 패킷의 최근 10초간 트래픽 양 점검.

### 복잡도 
- 시간 복잡도 : O(n) 
    - 배열 전체를 한번 훑으면서 각 원소를 최대 한 두번씩 건드리기 때문에 O(N)
- 공간 복잡도 : O(1), 상황에따라 O(k)
    - 보통 현재 합이나 개수를 저장할 몇 개의 변수(또는 해시맵/배열)만 사용하기 때문


```
public class Main {
    public static void main(String[] args) {
        int[] array = {4, 2, 1, 7, 8, 1, 2, 8, 1, 0};
        int kSize = 3;

        // 1. [4, 2, 1] = 7
        // 2. [2, 1, 7] = 7 - 4 + 7 = 10
        // 3. [1, 7, 8] = 10 - 2 + 8 = 16
        // 4. [7, 8, 1] = 16 - 1 + 1 = 16
        // 5. [8, 1, 2] = 16 - 7 + 2 = 11
        // 6. [1, 2, 8] = 11 - 8 + 8 = 11
        // 7. [2, 8, 1] = 11 - 1 + 1 = 11
        // 8. [8, 1, 0] = 11 - 2 + 0 = 9
        // 결과: 16

        // 결과 출력
        Object result = findMaxSumOfSubarray(array, kSize);
        System.out.println("배열: " + java.util.Arrays.toString(array));
        System.out.println("윈도우 크기 (K): " + kSize);
        System.out.println("최대 부분 배열 합: " + result);
    }

    public static Object findMaxSumOfSubarray(int[] arr, int k) {
        int n = arr.length;

        // 예외 처리: 배열 길이가 K보다 작으면 계산 불가
        if (n < k) {
            return "오류: 배열 길이가 윈도우 크기보다 작습니다.";
        }

        // 1. 초기 윈도우 설정 (첫 번째 윈도우의 합 계산)
        int currentWindowSum = 0;
        for (int i = 0; i < k; i++) {
            currentWindowSum += arr[i];
        }
        
        int maxSum = currentWindowSum;

        // 2. 윈도우를 한 칸씩 '슬라이딩'하며 최대 합 갱신
        // i는 윈도우의 '끝' 인덱스를 나타낸다.
        for (int i = k; i < n; i++) {
            // (1) 새로운 원소 arr[i]를 더하고
            // (2) 윈도우에서 빠지는 arr[i - k]를 뺍니다.
            currentWindowSum += arr[i] - arr[i - k];

            // 3. 최대 합 갱신
            maxSum = Math.max(maxSum, currentWindowSum);
        }

        return maxSum;
    }
}

```

### 슬라이딩 윈도우 종류 
- 문제 지문에 구체적인 길이(숫자)가 명시 되어있을때는 고정 크키 슬라이딩 윈도우. 구간 안의 결과 값이 궁금할때 (ex 합이 얼마인지)
    - 연속된 3일간, 길이가 5인, k개씩 묶어서
- 길이는 알려주지않고 달성해야 할 목표(조건)만 알려줄때는 가변 크기. 구간의 길이 그 자체가 궁금할때 (ex 길이가 몇인지)
    - 합이 100이상 되는, 중복 문자가 없는, 가장 짧은/가장 긴 

### 고정크기 슬라이딩 윈도우 
- 윈도우의 너비(데이터 개수)가 문제에서 미리 주어지는 경우로 right 포인터가 한 칸 앞으로 가면, left 포인터도 반드시 한 칸 따라간다. 두 포인터의 간격이 일정하다.
- 연속된 k일 동안의 합, 길이가 n인 모든 부분 문자열 찾기 등 구간의 길이가 정해져 있을 때 사용

```
public int fixedSlidingWindow(int[] nums, int k) {
    int windowSum = 0;
    int maxSum = 0;

    // 1. 첫 번째 윈도우 초기화
    for (int i = 0; i < k; i++) {
        windowSum += nums[i];
    }
    maxSum = windowSum;

    // 2. 윈도우 밀기 (슬라이딩)
    for (int i = k; i < nums.length; i++) {
        // 들어오는 놈 더하고, 나가는 놈 빼기
        windowSum += nums[i] - nums[i - k];
        // 결과 갱신
        maxSum = Math.max(maxSum, windowSum);
    }
    
    return maxSum;
}
```

### 가변 크기 슬라이딩 윈도우
- 윈도우의 크기가 특정 조건(합, 중복 여부 등)을 만족할 때까지 늘어나거나 줄어든다. right를 이동시켜 윈도우를 확장하다가, 조건을 만족하거나 넘어서면 left를 이동시켜 윈도우를 수축시킨다.
-  "합이 S 이상이 되는 가장 짧은 부분 배열", "중복 문자가 없는 가장 긴 부분 문자열" 등 구간의 길이를 구하는 것이 정답일 때 사용한다.
- 주로 while 루프를 사용하여 내부에서 left 포인터를 조정하는 방식으로 작동한다. 

```
public int dynamicSlidingWindow(int[] nums, int target) {
    int left = 0;
    int currentSum = 0;
    int minLength = Integer.MAX_VALUE;

    // right 포인터를 계속 확장
    for (int right = 0; right < nums.length; right++) {
        // 1. 현재 윈도우에 요소 추가
        currentSum += nums[right];

        // 2. 조건 충족 시 left를 당겨서 윈도우를 수축 (while문이 핵심)
        while (currentSum >= target) {
            // 결과 갱신 (예: 최소 길이 구하기)
            minLength = Math.min(minLength, right - left + 1);
            
            // 왼쪽 요소를 빼고 포인터 이동
            currentSum -= nums[left];
            left++;
        }
    }

    return minLength == Integer.MAX_VALUE ? 0 : minLength;
}
```

### 슬라이딩 윈도우 응용 문제 
- 최대 또는 최소 부분합 : 연속된 k개의 숫자를 합쳤을때 생기는 경우의 숫자 중 최대 또는 최소를 찾아라. 
- 부분 배열 평군 : 연속된 k개의 숫자 평균을 구하는 문제
- 문자열 검색 : 문자열에서 특정 패턴을 찾는 문제
- 투 포인터 문제 : 두개의 포인터를 사용하여 배열에서 특정 조건을 만족하는 부분 배열을 찾는 문제 


## 투 포인터 (Two Pointers)
- 투 포인터는 **"연속되고 길이가 가변적인"** 부분 배열들을 활용하여 특정 조건을 일치시키는 알고리즘이다. 1차원 배열에서 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작해가면서 원하는 값을 찾을 때 까지 탐색한다.
- 전체 배열을 이중 루프(O(N2))로 탐색해야 할 문제를 **단일 루프(O(N))**로 최적화하기 위해 사용한다.

### 투 포인터와 슬라이딩 윈도우의 차이
- 슬라이딩 윈도우는 두 포인터 사이의 구간이 중심이고 윈도우가 이동할 때 그 안에 담긴 데이터들의 합, 평균, 개수 등을 계속 유지하고 업데이트 한다. 보통 left와 right가 같은 방향으로 이동하며, 고정 크기일 경우 두 포인터가 일정한 간격을 유지하며 같이 움직인다.
- 그러나 투 포인터는 left와 right라는 두 지점이 중심으로 두 지점이 가리키는 값의 관계(합, 비교)를 보고 포인터를 어떻게 옮길지 결정한다. 구간 내의 모든 데이터를 다루기보다 특정 조건을 만족하는 두 위치를 찾는 것이 중심이다. 양 끝에서 서로를 향해 오거나(전형적인 방식), 속도를 다르게 해서 한 방향으로 가기도 한다. 
- 즉, 윈도우 내의 전체 데이터를 굴리면서(더하고 빼면서) 이동하면 슬라이딩 윈도우, 단순히 두 위치의 값만 비교하면서 이동하면 투 포인터다.

## 투 포인터 방식
### 시작점-끝점 포인터 (Start/End Pointers)
- 두 포인터가 **같은 방향(주로 오른쪽)**으로 움직이면서 부분 배열의 길이를 유동적으로 조절한다.
- 두 포인터(star,end)가 모두 배열의 시작점(index 0 )에서 출발한다. 
- end 포인터는 조건을 만족시키기 위해 배열을 확장하고, Start 포인터는 조건이 위반될 때 배열을 축소한다.
- 연속된 부분 배열이나 부분 문자열에서 특정 조건(합,개수,길이)를 만족하는 구간을 찾기 위해 주로 사용된다 (ex "합이 M인 연속 부분 수열의 개수 찾기", "가장 긴 중복 없는 부분 문자열 찾기" )

### 양 끝 포인터 (Opposite Pointers)
- 이 방식은 포인터가 서로 다른 방향(안쪽)으로 움직이는 방식으로, 주로 정렬된 배열에서 특정 조건을 만족하는 두 원소를 찾는 데 사용.
- Left 포인터는 배열의 시작(왼쪽 끝), Right 포인터는 **배열의 끝(오른쪽 끝)**에서 시작한다.
- 두 포인터가 서로 마주보며 안쪽으로 이동한다. 두 포인터가 만나거나 교차할 때 탐색을 종료한다.
- 배열 내에서 두 원소를 선택해 특정 **조건(합, 차, 곱)**을 만족하는 쌍을 찾는다. (연속된 구간일 필요가 없다. 다만, 비 연속적인 배열에서 투 포인터를 쓰려면 반드시 배열이 정렬 되어있어야한다. 연속된 구간일 필요가 없다는 소리는 nums[0]과 nums[100]처럼 멀리 떨어진 두 원소를 선택해서 비교할 수 있다는 말이다.) 
- ex) 정렬된 배열에서 두 수의 합이 타겟 값 K가 되는 쌍을 찾기




#### 참고 링크 

https://velog.io/@ninto_2/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

https://dolphincoding.io/learn/document/48

https://velog.io/@alkwen0996/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0Sliding-Window