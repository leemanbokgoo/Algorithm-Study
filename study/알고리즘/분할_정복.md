## 분할 정복 
- 다중 재귀를 기반으로 하는 알고리즘 디자인 패러다임으로 말 그대로 문제를 '분할'해서 '정복'한 다음 정답을 '조합'해나간다는 의미를 지닌다.
- 직접 해결 할 수 있을 정도로 간단한 문제가 될 때 까지 문제를 재귀적으로 쪼개 나간다음, 그 하위 문제의 결과들을 조합하여 원래 문제의 결과로 만들어 낸다. 재귀를 활용하는 대표적인 알고리즘이다. 
- 다만, 일반적인 재귀 함수와 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신 거의 같은 크기의 부분 문제로 나눈다는 것이다.
- 분할 정복을 활용하면, 선형적인 방법보다 빠르게 문제를 해결할 수도 있다.
- 분할 정복 알고리즘 디자인 패러다임은 중급 이상의 코딩 테스트 문제로 빈번히 출제되며, 최적 부분 구조를 풀이하는데 매우 중요한 기법 중 하나이므로 잘 숙지해둘 필요가 있다. 
- 분할 정복을 가장 잘 보여주는 예시는 병합 정렬이다. 

### 분할 정복의 단계
- 분할 정복 알고리즘을 활용하여 문제를 해결 할 때는 '분할' > '정복' > '결합'의 단계로 결과를 호출한다.
    - 1.  분할 : 문제를 동일한 유형의 여러 하위 문제로 나눈다. 문제가 충분히 작아져서 바로 해결 할 수 있을 때까지 계속해서 나눈다. 보통 이 단계를 재귀적으로 수행한다. 
    - 2. 정복 : 가장 작은 단위의 하위 문제를 해결하여 정복한다. 만약 하위 문제가 여전히 크다면 다시 분할 단계를 거치고 충분히 작다면 즉각적인 해답을 얻는다. 이 최소 단위를 Base Case 라고 부른다. 
    - 3. 조합 : 하위 문제에 대한 결과를 원래 문제에 대한 결과로 조합한다. 단순히 합치는 경우도 있지만 정렬처럼 순서를 맞추며 복잡하게 합쳐야하는 경우도 있다. 


### 분할 정복의 장점
- 복잡한 문제를 단순화함으로 문제 해결 과정의 간편하다. 
    - 문제를 더 작고 쉬운 문제로 분할하여 해결하므로 해결 과정이 간단해지고 대규모 문제를 해결하기 용이함. 하노이의 탑이나 정렬 알고리즘처럼 규칙성이 있는 문제에서 더욱 진가를 발휘한다. 
- 연산 횟수를 줄여 속도가 빠름.(효율적)
    - 분할정복의 가장 큰 기술적인 장점으로 하나씩 확인하는 방식(선형 검색)보다 연산 횟수를 획기적으로 줄일 수 있기 때문에 훨씬 빠른 성능을 낼 수 있다. 예를 들어 선택/버블 정렬이 O(N)의 시간이 걸릴 때, 분할 정복을 이용한 합병 정렬이나 퀵 정렬은 O(n log n)이다. 
- 병렬 처리 수행에 최적화되어있다. 
    - 부분 문제들이 독립적이기 때문에 병렬 처리가 가능하다. 따라서 여러개의 CPU 코어나 스레드에 작업을 분산시켜 동시에 처리하기 매우 유리한 구조를 가진다. 
- 캐시 효율성이 좋다.
    - 문제를 작게 쪼개다 보면 데이터가 메모리의 좁은 범위 안에 머물게 됨으로 캐시 적중률(Cache Hit Rate)을 높여 실제 실행 속도가 더욱 빨라진다. 

### 분할 정복의 단점
- 재귀 호출로 인한 오버 헤드(스택 오버 플로우 문제)와 추가 메모리의 필요
    - 분할 정복은 대부분 재귀 함수 형태로 구현됨으로 재귀를 호출 할 때마다 스택 영역에 실행 정보가 계속 쌓인다. 재귀가 너무 깊어지면 메모리 한계를 초과하여 스택 오버플로우 문제가 발생함.
    - 문제를 분할하는 과정에서 추가적인 메모리가 필요할 수 있다. 예를 들어 합병 정렬의 경우, 데이터를 반으로 쪼개서 각각 정렬한 뒤 다시 합칠 때, 정렬된 데이터를 임시로 저장할 데이터 전체 크기만한 별도의 배열이 필요하다. 
- 불균형한 분할로 인한 효율성 저하
    - 분할 정복의 핵심은 균형있는 분할이다. 만약 분할 된 부분 문제들이 같은 크기를 갖지않을 경우, 효율성이 떨어질 수 있다. 퀵 정렬에서 주로 발생하는 치명적인 문제다.
- 문제를 나누는 방식이 잘못되면 과도한 중복 계산으로 오히려 성능이 더 떨어질 수 있다.
    - 예를 들어 피보나치 수열을 단순 재귀(분할 정복 방식)으로 풀면 이미 구한 값을 수만번 다시 계산하는 비효율이 발생한다. 이런 경우 동적 계획법을 사용하는 것이 좋다. 
- 합치는 과정의 비용이 많이 들 수 있다. 
    - 문제를 나누는 것은 쉽지만 해결한 조각들을 다시 하나로 합치는 결합 과정이 복잡하거나 시간이 오래걸릴 수 있다. 예를 들어 합병 정렬은 데이터를 합치는 과정에서 정렬된 결과를 담을 별도의 추가 메모리 공간이 필요하다. 공간 효율성 측면에서는 손해를 보게 된다. 


### 분할정복 알고리즘의 시간 복잡도
- 빅오 표기법으로 나타내면 일반적으로 O(n log n)을 가진다.
- 분할정복의 시간 복잡도는 각 하위 문제의 크기가 n / b로 줄어들고, 분할되는 문제의 수가 a개인 경우, 일반적으로 다음과 같이 나타낼 수 있다. (a는 분할되는 문제의 수, b는 각 하위 문제의 크기, d는 분할과정을 제외한 각 문제를 해결하는 데 필요한 시간복잡도)
    - T(n) = aT(n/b) + O(n^d)
        - T(n) : 크기가 n인 문제를 해결하는 데 걸리는 총시간.
        - a : 문제를 분할했을 때 발생하는 부분 문제의 개수
        - n/b : 부분 문자 하나당 데이터의 크기 ( 즉, 문제를 1/b 크기로 쪼갠다는 뜻.)
        - O(n^d) : 문제를 나누고 나중에 결과를 하나로 합치는 데 드는 추가적인 시간.
- 분할정복 알고리즘의 시간복잡도는 Master theorem에 따라 결정된다.


### 분할 정복과 재귀 함수의 차이
- 분할 정복 알고리즘과 재귀 함수는 모두 문제를 작은 부분으로 나누어 해결하는 '재귀적인 방법'을 통해 해결한다.

![image](https://github.com/user-attachments/assets/0ca8c788-e922-4a4c-ad40-7ca9ff8c8ba0)

#### 일반적인 재귀 호출 
- 자기 자신을 호출하면서 문제를 해결 해 나가기에 해결하는 과정에서 결과를 메모리에 저장한다. 그렇기에 호출 스택과 같은 추가적인 메모리 사용으로 속도가 느려질 수 있다. 
- 문제를 해결하는 과정이 하나의 과정(문제 해결, 분할)으로 이루어진다. 

#### 분할 정복 
- 분할 > 정복 > 결합 과정을 통해서 해결해 나아가기에 해결하는 과정이 '분할'하는 과정과 '해결'하는 과정으로 분리되어있다. 
- 별도의 메모리를 사용하지않고 문제를 작은 부분으로 나누어 해결함으로 속도가 상대적으로 빠르다.
- 대규모 문제를 해결하기 용이하다.

### 분할 정복과 동적 계획법 알고리즘 차이
- 동적 계획법(Dynamic Programming)과 분할 정복(Divide and Conquer)은 서로 비슷한 알고리즘 기법이지만 ‘목적’과 '적용 대상’이 다르다.
- 분할정복의 경우는 큰 문제를 작은 문제들로 나누어서 해결함. 큰 수의 곱셈, 퀵 정렬 등과 같은 문제를 해결한다. 
- 동적 계획법의 경우는 작은 문제들을 풀면서 그 결과를 저장하며 전체 문제를 해결함. 최적화 문제나 최단 경로 문제등의 문제를 해결한다.

### 분할 정복을 활용한 알고리즘
- 분할 정복을 가장 잘 보여주는 예시는 정렬이다.( 특히 병합 정렬 )
    - 퀵 정렬
    - 이진 검색
    - 병합 정렬 


#### 참고링크 
https://algorfati.tistory.com/133

https://adjh54.tistory.com/219