## 비트 Bit
- 데이터의 가장 작은 단위로 0 또는 1 중 하나의 값을 가질 수 있다. Binary Digit의 줄임말로 2진수를 뜻한다. 
    - 예를 들어 이진수 0110은 4비트다. 
- 컴퓨터는 0과 1의 조합으로 수의 계산과 논리 계산을 한다. 컴퓨터에서 모든 데이터는 비트로 표현되며, 전기 신호의 상태 (On/Off 또는 True/False)로 비트를 나타낸다
- bit는 컴퓨터의 데이터를 나타내는 데 중요한 역할을 한다. 
    - 여러 개의 bit를 조합하여 숫자, 문자, 이미지, 음성 등의 다양한 데이터를 표현할 수 있다. 
    - 컴퓨터의 처리 속도, 저장 용량, 통신 속도 등을 결정하는 중요한 요소다. 
    - 더 많은 bit를 사용할수록 더 많은 정보를 나타낼 수 있으며, 이는 컴퓨터의 성능과 기능에 직접적인 영향을 미친다.

### Bit VS Byte
- Byte는 8개의 비트로 이루어진 단위이다.
- 프로그래밍 언어에서 데이터는 일반적으로 byte를 기준으로 다루며 컴퓨터 시스템에서 일반적인(기본적인) 데이터 단위를 말한다. 즉, byte는 메모리나 저장공간을 할당하고 데이터를 처리할때의 가장 기본적인 단위이다. 
    - int는 보통 4 byte 혹은 8 byte
    - string은 문자 하나당 보통 2byte 또는 1 byte
    - boolean은 보통 1 byte
    ```
    1 byte = 8 bits
    1 killobyte(KB) = 1024 bytes
    1 megabyte(MB) = 1024 kilobyte(KB)
    1 gigabyte(GB) = 1024 megabyte(MB)
    1 terabyte(TB) = 1024 gigabyte(GB)
    ```

## 비트의 특징

### 이진 체계 
- 이진 체계는 0과 1 두 개의 값만을 사용하여 모든 데이터를 표현할 수 있는 방법(체계)이다. 
- 컴퓨터는 전기 신호(=전구)나 자기장(=자석) 등의 물리적인 수단을 사용하여 bit를 나타낼 수 있다. 
    - 전구 스위치가 꺼져있다면 0, 전구 스위치가 켜져있다면 1로 표현한다.

### 데이터 표현
- bit를 사용하여 다양한 종류의 데이터를 표현할 수 있다. 
    - 예를 들면, 숫자, 문자, 이미지, 음성 등의 데이터를 이진 형태로 나타낼 수 있다. 
    - 컴퓨터에서 문자를 표현하기 위해서는 문자 인코딩 방식(ASCII, UTF-8)을 사용해서 bit로 매핑한 뒤 문자를 표현한다. 
    - 예를 들면, 이진수 101을 인코딩 방식으로 변환하면 숫자 5가 된다.

### 비트 묶음과 바이트
- bit는 컴퓨터가 사용하는 데이터의 가장 작은 단위를 말하며 컴퓨터의 데이터를 나타내는 데 중요한 역할을 한다. 
- 여러 개의 bit를 조합해서 더 큰 데이터 단위를 표현할 수 있다.
    - 8개의 bit를 묶어서 하나의 단위로 표현할 수 있는데, 이를 바이트(byte)라고 한다. 
    - byte가 프로그래밍 언어에서 쓰이는 가장 일반적인 데이터 단위이지만, 다른 단위도 존재한다.

### 컴퓨터 구성
- bit는 컴퓨터의 처리 속도, 저장 용량, 통신 속도 등을 결정하는 중요한 요소로 컴퓨터의 CPU(중앙 처리 장치), 메모리(Memory), 저장 장치(Storage) 등은 모두 bit를 사용하여 데이터를 처리한다. 
- 컴퓨터의 비트 수는 해당 컴퓨터 시스템이 처리할 수 있는 데이터의 크기와 범위를 결정한다. 
    - 일반적으로, 컴퓨터가 처리할 수 있는 비트 수가 많아질 수록 처리 속도나 저장 용량이 결정된다. 따라서 더 빠른 속도의 성능 좋은 컴퓨터(운영체제)를 사용하고 싶다면 bit가 높은걸 고르면 된다.

### 컴퓨터 아키텍처(Architecture)
- 컴퓨터 시스템의 아키텍처는 bit의 크기에 따라 결정된다. 
    - 예를 들어, 32비트 아키텍처는 각 워드(word)가 32비트로 구성되어 있고, 64비트 아키텍처는 각 워드(word)가 64비트로 구성되어 있다.
    - 워드(word) : 컴퓨터 구조에서 하나의 연산을 통해 저장 장치로부터 프로세서(데이터를 처리하는 장치)의 레지스터(CPU 내부에 존재하는 아주 작은 고속 저장 공간)에 옮겨놓을 수 있는 데이터 단위이다. 즉, 컴퓨터에서 저장할 수 있는 데이터(연산)의 단위이다.
- 윈도우 32비트와 64비트의 차이는 시스템이 한 번에 처리하는 데이터의 단위를 의미한다. 따라서 높은 비트를 사용할수록 더 복잡한 연산을 빠르게 수행하며 대용량 메모리를 인식할 수 있다.
    - 윈도우 32 비트 : 4,294,967,296의 데이터 크기 처리 가능
    - 윈도우 64 비트 : 18,446,744,073,709,600,000의 데이터 크기 처리 가능

### 논리 연산
- 비트는 0(거짓)과 1(참)이라는 논리적 상태를 가지므로, 논리 연산(AND, OR, NOT 등)의 기본 단위가 된다. 이를 통해 컴퓨터 시스템의 복잡한 조건문이나 논리 회로를 구현한다. 논리 연산은 컴퓨터 시스템에서 조건문, 논리회로, boolean 로직 등을 구현하는 데 사용된다.
- 비트는 무엇(0 또는 1)인가를 나타내고 논리 연산은 그 비트들을 가지고 어떻게(판단, 계산)할 것인가를 결정한다. 즉, 비트는 참/거짓을 표현하며 논리 연산을 통해 시스템의 조건이나 회로를 구성한다. 


-----


## Bit 조작 이란?
- 비트 조작은 컴퓨터 프로그래밍에서 가장 low-level의 데이터 조작 기술으로 데이터를 비트(0과 1) 수준에서 직접 다루는 것을 의미한다. 즉, 데이터를 일반적인 바이트 단위가 아닌 비트 단위로 쪼개서 처리하고 조작하는 것이다. 이를 통해 데이터의 작은 부분을 효율적으로 다루고, 특정 비트 위치를 변경하거나 확인할 수 있다. 

### Bit 조작의 필요성
- 성능 최적화: 비트 연산은 CPU에서 직접 처리되어 매우 빠르다
- 메모리 효율성: 적은 메모리로 많은 정보를 저장할 수 있다
- 특정 문제 해결: 일부 알고리즘 문제는 비트 연산으로 훨씬 효율적으로 해결된다 (코테/기술면접에서 유용)

### 비트연산 vs 일반 산술 연산
- 둘다 언어나 CPU 아키텍쳐에 따라 다를수있다
- 성능의 차이는 보통 비트연산이 약간 빠르나, 쉽게 체감할수 있는 정도는 아니지만 이 약간의 차이가 임팩트를 가져올수있는 상황에서는 유용할수 있다


## 기본 개념

## 비트 연산자
```
print(~7)
>>> -8 
```
-  &(and), |(or), ~(not), ^(xor)와 같은 비트 연산자는 정수 전체가 아닌, 개별 비트(0과 1)에 대해 논리적인 규칙을 적용한다. 이러한 연산은 저수준 데이터 조작이나 하드웨어 제어 등에서 사용되며, 결과로 새로운 정수 값을 반환한다.
- 비트 연산은 피연산자인 정수를 구성하는 2진수 비트 하나하나에 대해 수행되며, 결과는 새로운 정수이다.
    - AND (&): 두 비트가 모두 1일 때만 결과 비트가 1.
    - OR (|): 두 비트 중 하나라도 1이면 결과 비트가 1.
    - NOT (~): 모든 비트를 반전 (0 -> 1, 1 -> 0, 1의 보수 연산).
    - XOR (^): 두 비트가 서로 다를 때만 결과 비트가 1.

- 예를 들면, 5(0101) and 3(0011) 일때, 비트 연산자의 비교 방식은 다음과 같다. 참고로 비트는 오른쪽부터 세며 0번째 자리부터 시작이다.
    - 1(0번째 자리)과 1(0번째 자리) 비교 -> 1
    - 0(1번째 자리)과 1(1번째 자리) 비교 -> 0
    - 1(2번째 자리)과 0(2번째 자리) 비교 -> 0
    - 0(3번째 자리)과 0(3번째 자리) 비교 -> 0
    - 결과는 2진수 0001 이다. 0001을 십진수로 변환하면 1이 된다.
    - 즉, 5 & 3 = 1

- 비트 연산 시 NOT을 사용할 때 주의해야할 점은 NOT 7은 -7이 아니다. NOT 연산은 2의 보수 시스템에서 부호를 바꾸는 연산이 아니라, 모든 비트를 반전시키는 연산이기 때문이다.
    - NOT 연산은 단순히 모든 비트를 뒤집는 연산이다.  1 -> 0, 0 -> 1으로 바꾼다. 
        - NOT 7 : 여기서 7의 이진수는 0111이며 이를 뒤집으면 1000이다.
        - 1000 은 십진수로 변환하면 -8이다. **NOT x = -x -1**이 된다.
            - NOT 7 = -7 -1
            - NOT 7 - -8
        - 만약 7의 음수를 구하고 싶다면 NOT이 아니라 2의 보수 연산을 해야한다.
    - NOT 연산 = 2의 보수 연산 - 1을 한다면 NOT 5 = (5의 2의 보수 연산) -1이 된다.
        - 즉, -6 = (-5)-1이 되며 최종적으로는 -6 = -6이 된다.
        - 5를 NOT 연산하면 -6이 된다.
        - 5을 2의 보수로 연산하면 -5가 된다.
    
## 2의 보수, 음수를 구하는 방법
- 컴퓨터가 음수를 저장하기 위해 사용하는 방법 중 하나다.  양수 -> 음수, 음수 -> 양수로 바꿔주는 연산. 즉, 부호를 바꾸는 연산이다.
    - 예를 들어 4비트로 숫자를 표현한다고 치면 가능한 범위는 0000부터 1111까지로 총 16개다. 양수만 저장한다면 0부터 15까지 16개를 그대로 저장하면 된다. 하지만 문제는 음수도 저장해야한다는 점이다.
    - 그래서 16개 중 절반을 음수를 위해 할당한다. 따라서 -8부터 7까지 숫자를 저장하게 된다. 맨 앞의 비트는 부호 비트로 사용한다.
    - 즉, 양수의 경우 0xxx를 사용하고 음수의 경우 1xxx를 사용한다. 
- 2의 보수는 숫자 포맷으로 쓰일 때와 수학 연산자로 쓰일 때 서로 다른 의미를 가진다. 여기서 2의 보수 연산은 양수를 음수로, 음수를 양수로 바꾸는 작업을 말한다. 숫자 포맷으로 쓰일 때는 음수를 말한다. 2의 보수 방식으로 나타내라고 하면 음수로 저장했을때 비트가 무엇인지 묻는 것이다.
    - ex) -6의 2의 보수는 1010이다. -6의 2의 보수 연산은 0110(6)이다.
- 어떤 수의 2의 보수를 구한다고 하면 음수일때는 양수의 2진수를, 양수일때는 음수의 2진수를 구하면 된다.
    - 7의 2의 보수를 구한다고 하면, 7의 이진수는 0111이고 2의 보수 연산을 적용하면 1001이다. 1001으로 십진수로 변환하면 -7이다.
    - 즉, -6의 2의 보수 연산을 구한다면 그냥 6의 2진수를 구하면 된다. 6의 2진수는 0110임으로 -6의 2의 보수 연산은 0110이다.

### 2의 보수 연산
- 2의 보수 연산은 양수를 음수로 바꾸는 것이고, 그 방법으로 비트를 다 뒤집는 NOT 연산의 결과에 + 1을 한다.
    - 2의 보수 연산 = NOT 연산 +1 이고, 반대로 NOT 연산 = 2의 보수 연산 - 1으로 2의 보수 연산과 NOT 연산은 같다. 
    - 즉, 비트 연산자 NOT은 2의 보수에서 1을 뺀 것이고 2의 보수 연산은 비트 연산자 NOT에서 1을 더한 것이다.
    - 예를 들어 0111의 2의 보수 연산은 1000 + 1이 된다. 1001의 비트 연산자 NOT은 0111 - 1 = 0110이다. 이 값은 ~1001로 표현하기도 한다.
    - ex) 음수일 경우에는 우선 양수의 2진수를 찾는다. 즉 -7의 2진수가 궁금할때는 우선 7의 2진수를 찾는다. 7을 2진법으로 나타내고 싶으면 7을 2로 반복하여 나누면서 나오는 나머지를 거꾸로 읽어주면 된다. 따라서 7의 2진수는 0111이다. 여기서 2의 보수 연산을 하면 음수를 구할 수 있다. 0111에 2의 보수 연산(NOT x + 1 )을 적용하여 NOT을 하면 1000. 여기에 1을 더해야함으로 최종적으로 1001이 된다. 즉, -7의 2진수는 1001이다. 
    - 4비트가 아닌 16비트, 32비트 등 더 큰 비트에서는 다음과 같다.
        - 12의 2진수는 0000....1100이다. -> NOT 연산을 하면 1111....0011
        - 여기서 +1을 하면 1111....0011 -> 1111....0100
        - 따라서 -12는 1111....0100 이 된다.

![image](https://github.com/user-attachments/assets/ea271f9d-5706-4659-ab15-f5b25f8aee60)

#### 만약 2진수를 십진수로 변환한다면 
- 부호비트가 0이면 즉, 맨앞의 비트가 0이면 그 수는 양수라는 뜻이다. 양수의 경우 십진법으로 바꾸는 방법은 다음과 같다.
    - 0110의 경우 1*0 + 2*1 + 4*1 = 6 이다.
- 부호비트가 1이면, 즉 맨앞의 비트가 1이면 그 수는 음수다. 음수의 경우 2의 보수 연산을 해준다.
    - 1111....0100을 십진법으로 바꾼다면 2의 보수 연산을 하여 0000...1100이 된다. 이 수는 12이다.
    - 따라서 1111....0100은 -12가 된다. 
    - 2의 보수 연산은 음수도 양수로 바꿀 수 있다. 


#### 참고링크 
https://jerryjerryjerry.tistory.com/167

https://github.com/moong00n/leetcode/tree/main/bit_manipulation_basics