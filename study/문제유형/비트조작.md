## 비트 Bit
- 데이터의 가장 작은 단위로 0 또는 1 중 하나의 값을 가질 수 있다. Binary Digit의 줄임말로 2진수를 뜻한다. 
    - 예를 들어 이진수 0110은 4비트다. 
- 컴퓨터는 0과 1의 조합으로 수의 계산과 논리 계산을 한다. 컴퓨터에서 모든 데이터는 비트로 표현되며, 전기 신호의 상태 (On/Off 또는 True/False)로 비트를 나타낸다
- bit는 컴퓨터의 데이터를 나타내는 데 중요한 역할을 한다. 
    - 여러 개의 bit를 조합하여 숫자, 문자, 이미지, 음성 등의 다양한 데이터를 표현할 수 있다. 
    - 컴퓨터의 처리 속도, 저장 용량, 통신 속도 등을 결정하는 중요한 요소다. 
    - 더 많은 bit를 사용할수록 더 많은 정보를 나타낼 수 있으며, 이는 컴퓨터의 성능과 기능에 직접적인 영향을 미친다.

### Bit VS Byte
- Byte는 8개의 비트로 이루어진 단위이다.
- 프로그래밍 언어에서 데이터는 일반적으로 byte를 기준으로 다루며 컴퓨터 시스템에서 일반적인(기본적인) 데이터 단위를 말한다. 즉, byte는 메모리나 저장공간을 할당하고 데이터를 처리할때의 가장 기본적인 단위이다. 
    - int는 보통 4 byte 혹은 8 byte
    - string은 문자 하나당 보통 2byte 또는 1 byte
    - boolean은 보통 1 byte
    ```
    1 byte = 8 bits
    1 killobyte(KB) = 1024 bytes
    1 megabyte(MB) = 1024 kilobyte(KB)
    1 gigabyte(GB) = 1024 megabyte(MB)
    1 terabyte(TB) = 1024 gigabyte(GB)
    ```

## 비트의 특징

### 이진 체계 
- 이친 체계는 0과 1 두 개의 값만을 사용하여 모든 데이터를 표현할 수 있는 방법(체계)이다. 
- 컴퓨터는 전기 신호(=전구)나 자기장(=자석) 등의 물리적인 수단을 사용하여 bit를 나타낼 수 있다. 
    - 전구 스위치가 꺼져있다면 0, 전구 스위치가 켜져있다면 1로 표현한다.

### 데이터 표현
- bit를 사용하여 다양한 종류의 데이터를 표현할 수 있다. 
    - 예를 들면, 숫자, 문자, 이미지, 음성 등의 데이터를 이진 형태로 나타낼 수 있다. 
    - 컴퓨터에서 문자를 표현하기 위해서는 문자 인코딩 방식(ASCII, UTF-8)을 사용해서 bit로 매핑한 뒤 문자를 표현한다. 
    - 예를 들면, 이진수 101을 인코딩 방식으로 변환하면 숫자 5가 된다.

### 비트 묶음과 바이트
- bit는 컴퓨터가 사용하는 데이터의 가장 작은 단위를 말하며 컴퓨터의 데이터를 나타내는 데 중요한 역할을 한다. 
- 여러 개의 bit를 조합해서 더 큰 데이터 단위를 표현할 수 있다.
    - 8개의 bit를 묶어서 하나의 단위로 표현할 수 있는데, 이를 바이트(byte)라고 한다. 
    - byte가 프로그래밍 언어에서 쓰이는 가장 일반적인 데이터 단위이지만, 다른 단위도 존재한다.

### 컴퓨터 구성
- bit는 컴퓨터의 처리 속도, 저장 용량, 통신 속도 등을 결정하는 중요한 요소로 컴퓨터의 CPU(중앙 처리 장치), 메모리(Memory), 저장 장치(Storage) 등은 모두 bit를 사용하여 데이터를 처리한다. 
- 컴퓨터의 비트 수는 해당 컴퓨터 시스템이 처리할 수 있는 데이터의 크기와 범위를 결정한다. 
    - 일반적으로, 컴퓨터가 처리할 수 있는 비트 수가 많아 질 수록 처리 속도나 저장 용량이 결정된다. 
    - (따라서 더 빠른 속도의 성능 좋은 컴퓨터(운영체제)를 사용하고 싶다면 bit가 높은걸 고르면 된다.)

### 컴퓨터 아키텍처(Architecture)
- 컴퓨터 시스템의 아키텍처는 bit의 크기에 따라 결정된다. 
    - 예를 들어, 32비트 아키텍처는 각 워드(word)가 32비트로 구성되어 있고, 64비트 아키텍처는 각 워드(word)가 64비트로 구성되어 있다.
    - 워드(word) : 컴퓨터 구조에서 하나의 연산을 통해 저장 장치로부터 프로세서의 레지스터에 옮겨놓을 수 있는 데이터 단위이다. 즉, 컴퓨터에서 저장할 수 있는 데이터(연산)의 단위이다.

- 윈도우 운영체제를 사용하는 사람들은 윈도우가 32비트인지, 64비트인지 확인하라는 말을 들어봤을 것이다. 이때 32비트는 데이터를 처리하는 비트가 32비트라는 것이다. 따라서 높은 비트를 사용할수록 처리할 수 있는 연산과 데이터가 많아져서 소프트웨어를 다루는데 더 유용하다고 할 수 있다.
    - 윈도우 32 비트 : 4,294,967,296의 데이터 크기 처리 가능
    - 윈도우 64 비트 : 18,446,744,073,709,600,000의 데이터 크기 처리 가

### 논리 연산
- bit는 논리 연산을 수행하는 데 사용된다. 논리 연산자인 AND, OR, NOT, XOR 등은 bit 단위로 수행되어 다양한 논리 연산을 수행할 수 있다. 논리 연산은 컴퓨터 시스템에서 조건문, 논리회로, boolean 로직 등을 구현하는 데 사용된다.
- 컴퓨터 데이터의 가장 작은 단위인 비트(bit)는 비트 연산자를 사용하여 조작된다. &(and), |(or), ~(not), ^(xor)와 같은 비트 연산자는 정수 전체가 아닌, 개별 비트(0과 1)에 대해 논리적인 규칙을 적용한다. 이러한 연산은 저수준 데이터 조작이나 하드웨어 제어 등에서 사용되며, 결과로 새로운 정수 값을 반환한다.
- 비트 연산은 피연산자인 정수를 구성하는 2진수 비트 하나하나에 대해 수행되며, 결과는 새로운 정수이다.
    - AND (&): 두 비트가 모두 1일 때만 결과 비트가 1.
    - OR (|): 두 비트 중 하나라도 1이면 결과 비트가 1.
    - NOT (~): 모든 비트를 반전 (0 -> 1, 1 -> 0, 1의 보수 연산).
    - XOR (^): 두 비트가 서로 다를 때만 결과 비트가 1.
- 예를 들자면 5(0101) and 3(0011) 일때, 비트 연산자의 비교 방식은 다음과 같다. 참고로 비트는 오른쪽부터 세며 0번째 자리 부터 시작이다.
    - 1(0번째 자리)과 1(0번째 자리) 비교 -> 1
    - 0(1번째 자리)과 1(1번째 자리) 비교 -> 0
    - 1(2번째 자리)과 0(2번째 자리) 비교 -> 0
    - 0(3번째 자리)과 0(3번째 자리) 비교 -> 0
    - 결과는 2진수 0001 이다. 0001을 십진수로 변환하면 1이 된다.
    - 즉, 5 & 3 = 1

#### 부울 연산자와의 차이 
- 반면, 부울 연산자 (일반적으로 논리 연산자라고도 불림)는 전체 값의 논리적 상태, 즉 참(True)과 거짓(False)에 대해 작동한다. &&(and), ||(or), !(not)와 같은 부울 연산자는 주로 프로그래밍에서 조건문이나 boolean 로직을 구현하는 데 사용되며, 결과는 항상 **논리값(참 또는 거짓)**이다.

-----


## Bit 조작 이란?
- 비트 조작은 컴퓨터 프로그래밍에서 가장 low-level의 데이터 조작 기술이다.
- 데이터를 비트(0과 1) 수준에서 직접 다루는 것을 의미, 즉, 데이터를 일반적인 바이트 단위가 아닌 비트 단위로 쪼개서 처리하고 조작하는것
이를 통해 데이터의 작은 부분을 효율적으로 다루고, 특정 비트 위치를 변경하거나 확인할 수 있다. 

### Bit 조작의 필요성
- 성능 최적화: 비트 연산은 CPU에서 직접 처리되어 매우 빠르다
- 메모리 효율성: 적은 메모리로 많은 정보를 저장할 수 있다
- 특정 문제 해결: 일부 알고리즘 문제는 비트 연산으로 훨씬 효율적으로 해결된다 (코테/기술면접에서 유용)

### 비트연산 vs 일반 산술 연산
- 언어나 CPU 아키텍쳐에 따라 다를수있다
- 성능의 차이는 보통 비트연산이 약간 빠르나, 쉽게 체감할수 있는 정도는 아니다
- 하지만, 이 약간의 차이가 임팩트를 가져올수있는 상황에서는 유용할수 있다


## 기본 개념

## 비트 연산 NOT
```
print(~7)
>>> -8 
```

- 비트 연산자 NOT(~)은 1 -> 0, 0 -> 1으로 바꿔준다. 
- 4비트라고 가정할때 0111의 NOT 연산 결과는 1000이며 0111은 7이고 1000은 -8로 **NOT x = -x -1**이 된다.
    - NOT 7 = -7 -1
    - NOT 7 - -8
- 여기서 주의해야할 점은 NOT 7은 -7이 아니다. NOT 연산은 2의 보수 시스템에서 부호를 바꾸는 연산이 아니라, 모든 비트를 반전시키는 연산이기 때문이다.
    - NOT 연산은 단순히 모든 비트를 뒤집는 연산이다. 
        - NOT 7 : 여기서 7은 0111이며 이를 뒤집으면 1000이다.
        - 1000 은 십진수로 변환하면 -8이다.
        - 만약 7의 음수를 구하고 싶다면 NOT이 아니라 2의 보수 연산을 해야한다.
        
- 참고로, 2의 보수 연산은 NOT 연산 + 1이다. 
    - 2의 보수 연산 = NOT 연산 +1 은 NOT 연산 = 2의 보수 연산 -1 과 같다. 
    - 예를 들어, 5를 2의 보수 연산하여 -5로 바꾼다고 하면 5의 이진수는 0000 0101이다.
        - 2의 보수 연산은 NOT 연산 + 1 임으로 0000 0101의 NOT 연산은 1111 1010이다. 여기서 + 1을 하면 1111 1011이다.
        - 따라서 -5는 1111 1011이다. 

    - NOT 연산 = 2의 보수 연산 - 1을 한다면 NOT 5 = (5의 2의 보수 연산) -1이 된다.
        - 즉, -6 = (-5)-1이 되며 최종적으로는 -6 = -6이 된다.
        - 5를 NOT 연산하면 -6이 된다.
        - 5을 2의 보수로 연산하면 -5가 된다. 거기에 -1을 더하면 -6이다.


## 2의 보수, 음수 
- 컴퓨터가 음수를 저장하기위해 사용하는 방법 중 하나다. 
    - 예를 들어 4비트로 숫자를 표현한다고 치면 가능한 범위는 0000부터 1111까지로 총 16개다. 양수만 저장한다면 0부터 15까지 16개를 그대로 저장하면 된다. 하지만 문제는 음수도 저장해야한다는 점이다.
    - 그래서 16개 중 절반을 음수를 위해 할당한다. 따라서 -8부터 7까지 숫자를 저장하게 된다. 맨앞의 비트는 부호비트로 사용한다.
    - 즉, 양수의 경우 0xxx를 사용하고 음수의 경우 1xxx를 사용한다. 

### 2의 보수 수학 연산
- 양수를 음수로, 음수를 양수로 바꾸는 작업을 말한다.
    - 비트 연산자 NOT은 2의 보수에서 1을 뺀것이고
    - 2의 보수 수학 연산은 비트 연산자 NOT에서 1을 더한것이다.
- 즉, 0111의 2의 보수 연산은 1000 + 1이 된다. 



![image](https://github.com/user-attachments/assets/ea271f9d-5706-4659-ab15-f5b25f8aee60)

#### 음수를 구하는 방법

- 7을 2진법으로 나타내고 싶으면 7을 2로 반복하여 나누면서 나오는 나머지를 거꾸로 읽어주면 된다. 따라서 7의 2진수는 011이다.
- 음수일 경우에는 우선 양수의 2진수를 찾는다. 즉 -7의 2진수가 궁금할때는 우선 7의 2진수를 찾는다.
- 7의 2진수는 0111이다. 여기서 2의 보수 연산을 하면 음수를 구할 수 있다.
    - 2의 보수 연산 : 양수 -> 음수, 음수 -> 양수로 바꿔주는 연산이다. 즉, 부호를 바꾸는 연산이다.
    - NOT x 에서 1을 더해주면 된다. 여기서 NOT x는 비트가 0이면 1로, 비트가 1이면 0으로 바꿔주는 연산이다.
    - 이를 0111에 적용해본다. 
        - 0111에 2의 보수 연산을 적용하여 NOT을 하면 1000 
        - 여기에 1을 더해야함으로 최종적으로 1001이 된다.
        - 즉, -7의 2진수는 1001이다. 
- 4비트가 아닌 16비트, 32비트 등 더 큰 비트에서는 다음과 같다.
    - 12의 2진수는 0000....1100이다. -> NOT을 하면 1111....0011
    - 여기서 2의 보수 연산을 하면 1111....0011 -> 1111....0100
    - 따라서 -12는 1111....0110 이 된다.

#### 만약 2진수를 십진수로 변환한다면? 음수의 경우 
- 부호비트가 0이면 즉, 맨앞의 비트가 0이면 그 수는 양수라는 뜻이다. 양수의 경우 십진법으로 바꾸는 방법은 다음과 같다.
    - 0110의 경우 1*0 + 2*1 + 4*1 = 6 이다.
- 부호비트가 1이면, 즉 맨앞의 비트가 1이면 그 수는 음수다. 음수의 경우 2의 보수 연산을 해준다.
    - 1111....0100을 십진법으로 바꾼다면 2의 보수 연산을 하여 0000...1100이 된다. 이 수는 12이다.
    - 따라서 1111....0100은 -12가 된다. 
    - 2의 보수 연산은 음수도 양수로 바꿀 수 있다. 

- 어떤 수의 2의 보수를 구한다고 하면 음수일때는 양수의 2진수를, 양수일때는 음수의 2진수를 구하면 된다.
    - 7의 2의 보수를 구한다고 하면, 7은 0111이고 2의 보수 연산을 적용하면 1001이다. 즉, 7의 2의 보수는 1001으로 십진수로 변환하면 -7이다.
    - -6의 2의 보수를 구한다면 그냥 6의 2진수를 구하면 된다. 6의 2진수는 0110이다. 즉, -6의 2의 보수는 0110이다.

#### 2의 보수 이름의 유래
- 4비트에서 7은 0110이고 -7은 1001이다. 더하면 10000이 된다.
    - 4은 0100이고 -4는 1100이다. 더하면 10000이 된다.
    - 3은 0011이고 -3는 1101이다. 더하면 10000이 된다.
    - 전부 10000이다.
- 8비트에서 1은 00000001이고 -1은 11111111이다. 더하면 10000000이 된다.
    - 10은 00001010이고 -10은 11110110이다. 더하면 10000000이 된다.
    - 33은 00100001이고 -33은 11011111이다. 더하면 10000000이 된다.
- 즉, 두수를 더하게 되면 최대 비트 크기보다 크면서 가장 작은 2의 거듭제곱 수가 나온다. 


#### 참고링크 
https://jerryjerryjerry.tistory.com/167

https://github.com/moong00n/leetcode/tree/main/bit_manipulation_basics