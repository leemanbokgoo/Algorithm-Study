# 그래프
- 그래프는 컴퓨터 과학과 수학에서 사용되는 중요한 자료 구조 중 하나로, 다양한 관계와 연결성을 표현하는데 사용된다.
- 연결되어있는 정점(노드)과 정점(노드)간의 관계를 표현할 수 있는 자료구조.그래프는 노드와 노드 사이의 관계를 나타내는 간선(엣지,Edge)로 구성되며, 이러한 노드와 간선의 집합으로 이루어진다.
- 비선형 구조는 표현에 초점이 맞춰져있고 선형 구조는 자료를 저장하고 꺼내는 것에 초점이 맞춰져있다. 그래프는 **연결 관계**에 초점이 맞춰져있다.
    - 예를 들어 영수는 친구 제니를 알고있고 로제와 친하다. 로제는 사나를 알고 있다. 이런 경우 영수는 사나와 2촌 관계라고 말할 수 있다. 
- 그래프는 실제 세계의 다양한 상황을 모델링하고 해결하기 위해 사용된다. 네트워크, 소셜그래프, 도로망, 웹 링크 구조, 알고리즘, 경로 최적화 및 상호 관계를 연구하는 데 중요한 역할을 한다.

## 그래프에서 사용되는 용어 
- 노드(Node) : 연결 관계를 가진 각 데이터를 의미. 정점(Vertex)이라고도 한다.그래프 내에서 개체나 데이터를 나타내는 지점이다.
- 간선(Edge) : 노드 간의 관계 또는 연결을 나타내는 선이다. 간선은 노드 간의 관계를 정의한다.
- 인접 노드(Adjacent Node) : 간선으로 직접 연결된 노드(또는 정점) 
```
      로제 - 사나
       ㅣ
제니 - 영수
```
- 위의 그림에서 영수는 연결관계를 가진 데이터, 노드 이다.
- 영수와 제니는 간선으로 연결되어있다.
- 영수와 로제는 인접 노드이다. 


### 그래프의 특징
- 방향성(무방향 그래프 vs 방향 그래프) : 그래프는 방향성을 가질 수 있다. 무방향 그래프는 간선가 양 방향으로 통과할 수 있는 반면, 방향 그래프는 간선에 방향이 지정되어 있다.
- 가중치(Weight) : 그래프의 간선에 가중치를 할당하여 간선 간의 관계의 강도를 나타낼 수 있다. 이러한 가중치는 네트워크 및 경로 최적화 문제에 유용하다.
- 경로(Path) : 그래프에서 노드 간의 연결된 간선의 순서이다. 경로는 노드 간의 이동방법을 설명한다.
- 순환(Cycle) : 그래프 내에서 동일한 노드로 돌아가는 경로를 형성하는 것을 의미한다. 그래프가 순환을 가질 수 있고, 순환 그래프는 환경 모델링에 사용된다.


### 그래프 종류
![image](https://github.com/user-attachments/assets/9aef3891-67e5-48f6-ac16-1d16dca2df31)

- 유방향 그래프(Directed Graph) : 방향 그래프라고도 불리며 방향이 있는 간선을 갖는다. 간선은 단방향 관계를 나타내며, 각 간선은 한 방향으로만 진행할 수 있다. 예를 들어 A가 B를 향한다.와 같은 방향성을 가지고 있다. 노드간의 관계가 단방향이거나 양방향이 아닐 수 있다.
- 무방향 그래프(Undirected Graph) : 방향이 없는 간선을 갖는다. 연결 되어있을 뿐, 방향은 없다. 노드 간의 관계가 상호적이며, 간선의 순서가 중요하지 않다.
- 가중 그래프(Weighted Graph) : 엣지에 가중치가 할당된 그래프로, 엣지 간의 관계의 강도를 나타낸다.
- 트리(Tree) : 사이클을 형성하지 않는 무방향 그래프이다. 트리는 하위 데이터 구조에서 많이 사용된다.

### 그래프의 표현방법
- 그래프라는 개념을 컴퓨터에서 표현하는 방법은 두가지다.
    - 인접행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현
    - 인접 리스트(Adjacency List) : 링크드 리스트로 그래프의 연결 관계를 표현

### 그래프의 표현 방법 예시 : 인접 행렬(Adjacency Matrix)
- 예를 들기위해 제니가 0 , 영수가 1, 로제가 2, 사나를 3이라고 가정한다.

```
    2 - 3  
    ⎜       
0 - 1

```
- 이를 인접 행렬, 2차원 배열로 나타내면 다음과 같다.
```
  0  1  2  3
0 X  O  X  X
1 O  X  O  X
2 X  O  X  O
3 X  X  O  X

```
- 0과 1이 연결 되어있기때문에 (0,1)(1,0)에는 O를 넣는다. 1과 2가 연결되어있으니 (1,2)(2,1)에 O를 넣는다. 2와 3이 연결되어있음으로 (2,3)(3,2)에 O를 넣는 식으로 그래프를 표현한다.
- 이걸 배열로 표현하면 다음과 같다.
```
graph = [
    [False, True, False, False],
    [True, False, True, False],
    [False, True, False, True],
    [False, False, True, False]
]
```
- 인접 행렬의 경우, 2차원 배열에 표현할때 1과 2가 연결 되어있는지 찾아보기위해서는 2차원 배열의 (0,2) 즉 배열[0][2] 이런 식으로 즉각적으로 찾아볼 수 있다. O(1)의 시간복잡도를 가진다. 그러나, 현재 존재하는 모든 노드들의 개수 만큼의 조합만들어 모든 조합의 연결 여부를 저장해야함으로 O(N^2)만큼의 공간을 필요로 한다. (그래프에 존재하는 모든 공간을 표현해야함으로.)
- 즉, 인접 행렬의 경우 시간 복잡도는 O(1)로 빠르지만 공간은 O(N^2)만큼 필요로 한다. 


### 그래프의 표현 방법 예시 : 인접 리스트(Adjacency List)

- 인접 리스트는 모든 노드에 연결된 노드에 대한 정보를 차례대로 다음과 같이 링크드 리스트 형태로 저장한다.
```
0 -> 1
1 -> 0 -> 2
2 -> 1 -> 3
3 -> 2

```
- 0 번 노드는 1번 노드와 연결 되어있고 1번 노드는 0번과 2번 노드로 저장되어있는데 이를 저장하기위해서 1 다음, 0다음 2를 저장해놓는다. 2번은 1,3과 연결 되어있기때문에 1과 3을 링크드 리스트 형태로 저장해놓는다.
- 이를 딕셔너리로 표현하면 다음과 같다

```
graph = {
    0: [1],
    1: [0, 2]
    2: [1, 3]
    3: [2]
}
```
- 인접 리스트의 경우는 1과 2가 연결되어있는지 알기위해 리스트의 1번째 키 값의 연결 리스트를 확인 -> 이 연결 리스트를 전부 조회해야만 알 수 있다. 최악의 경우에는 O(N)만큼의 시간복잡도를 사용하게 된다. 다만, 현재 존재하는 모든 노드들의 개수 만큼 키 값을 가지고 있고, 안에는 간선의 갯수 만큼의 연결 리스트가 존재한다. 노드가 몇백만개를 가지더라도 제곱만큼 커지지않는다. 즉 O(N+E)정도의 공간 복잡도를 가진다. 
- 즉, 인접 리스트의 경우 O(N+E)만큼의 공간 복잡도를 가져 인접 행렬보다는 공간을 덜 차지하지만 O(N)만큼의 시간복잡도를 가지며 인접 행렬보다는 느리다. 

## 두 방식의 차이
- 두 방식은 구현 방법의 차이에 따라 시간 복잡도와 공간복잡도에서 차이를 가진다. 시간이 필요한 경우 인접 행렬방식, 공간이 적게 쓰였으면 좋을때는 인접 리스트 방식을 쓰는게 좋다. 
