# 연결 리스트

![image](https://github.com/user-attachments/assets/61044c3c-0832-4579-b5cb-639280b8d59d)

- 연결 리스트란 일반적으로 사용하는 배열과 달리 동적으로 각 칸들이 앞,뒤로 사슬처럼 연결되있는 구조
- 연결 리스트에서 각 칸은 노드(Node)라고 부른다. 하나의 개체를 이루는 노드가 연결되어 리스트를 이룬다.
- 노드에는 값을 담고 있는 '데이터'와 다음 노드를 가리키는 '링크'정보를 저장하고 있는 것이 기본이다. '데이터'에는 숫자,문자열 또다른 연결 리스트 등 다양한 형식을 가질 수 있다. 
- 일반적으로 리스트의 맨 앞 노드를 헤드(Head), 맨 마지막 노드를 테일(Tail)이라고 함.
- 그래서 연결 리스트를 가리키는 변수가 있을 때는 연결 리스트의 전체를 가리킨다기보단 해당 노드를 가리킨다고 보면 된다.(ex 연결리스트의 head) 연결 리스트를 변수에 담으면 연결 리스트의 head를 가리킨다. 배열을 담고 있는 변수가 배열 전체를 가리키는 것과 다르다. 배열을 담는 변수(이름)는 메모리에 연속적으로 할당된 데이터 블록 전체를 가리킨다.

#### 1차원 배열
![image](https://github.com/user-attachments/assets/2d50d3c3-1882-4141-b4aa-ed67278a0a5f)

#### 연결 리스트 
![image](https://github.com/user-attachments/assets/394f2854-aca1-4740-a864-62a440abdf7a)

## 배열과 연결 리스트의 차이점.

### 메모리 저장 위치 
- 배열은 메모리의 연속된 위치에 저장되고 연결 리스트는 각 노드가 임의의 위치에 저장된다. 배열은 연속적으로, 연결 리스트는 메모리상에 흩어져서 저장되어있다. (그래서 다음 노드를 알기 위해서 다음 노드의 메모리상 주소를 가지고 있는 것.)

### 조회 시 성능
- 배열은 특정 원소를 조회할때 인덱스를 통해 조회함으로 O(1) 시간복잡도를 가짐. 연결 리스트는 선형 탐색을 하듯 노드에 저장된 다음 노드의 포인터를 따라가야함으로 O(n)의 시간 복잡도를 가진다.

### 삽입 or 삭제 시 성능 
- 연결 리스트: 맨 앞(Head) 의 경우나 특정 노드의 주소를 아는 경우 노드 간의 연결 정보만 수정하면 됨으로 O(1), 중간 또는 맨뒤의 노드의 경우 해당 위치를 찾기 위해 순차 탐색이 필요하기 때문에 O(n)의 시간 복잡도를 가진다. 
- 배열 : 메모리 주소가 연속적이므로 데이터를 삽입하거나 삭제할때 그 뒤의 모든 데이터를 한칸씩 밀거나 당겨야한다.(System.arraycopy) 이 데이터 이동이 n에 비례함으로 시간 복잡도는 O(n)이다.
- 얼핏 둘다 O(n)의 시간도를 가짐으로 비슷한 성능을 보인다고 생각할 수 있지만 그 뒤의 모든 데이터를 한칸씩 밀거나 당겨야하는 배열과 달리 노드는 주변 노드의 포인터/참조만 수정하면 된다. 즉, 데이터를 이동하는 과정이 없기때문에 상대적으로 배열보다 연결 리스트 사용 시 삽입 삭제 성능이 더 좋다. 
    - 즉, 둘다 O(n)의 시간복잡도를 가진다고 볼 수 있지만 배열의 O(n)은 데이터를 물리적으로 이동해야하지만, 연결 리스트는 포인터만 조작하기때문에 일반적으로 배열이 더 느리다. 특히 연결리스트는 특정 경우에는 O(1)의 시간복잡도를 가지기때문에 더욱 빠르다. 
    - 그러나 이는 이론적인 말로 실제로 현대 CPU 환경에서는 캐시 효율로 인하여 배열의 크기가 매우 크지않는 한 배열의 중간 삽입이 연결 리스트의 중간 삽입보다 실행 속도가 더 빠를 수 있다. 다시 말해, 현대 CPU 환경에서는 자료구조의 이론적 복잡도(O(n) vs O(n))보다 메모리 접근 속도(캐시 히트 vs 캐시 미스)가 성능에 더 큰 영향을 미치며, 이런 이유로 배열의 크기가 매우 크지않다면 연결 리스트보다 중간 삽입/삭제 성능이 더 좋다고 볼 수 있다. 
    - 실제로 C# , Python의 기본 List 자료 구조는 연결 리스트가 아닌 동적 배열로 구현되어있다. 여러가지 이유가 있겠지만 이유 중 하나는 삽입/삭제 성능마저도 캐시 효율성 덕분에 배열이 연결 리스트를 앞서는 경우가 많기 때문이다. 


### 배열 변수, 연결 리스트 변수의 차이 
- 그래서 연결 리스트를 가리키는 변수가 있을 때는 연결 리스트의 전체를 가리킨다기보단 해당 노드를 가리킨다고 보면 된다.(ex 연결리스트의 head) 연결 리스트를 변수에 담으면 연결 리스트의 head를 가리킨다. 배열을 담고 있는 변수가 배열 전체를 가리키는 것과 다르다. 배열을 담는 변수(이름)는 메모리에 연속적으로 할당된 데이터 블록 전체를 사실상 가리킨다.

### 배열과 연결 리스트의 적합한 사용 예시 
- 배열은 데이터 접근/검색이 빈번하고, 자료의 크기가 고정적이며, 삽입/삭제가 적은 경우에 적합
- 연결 리스트는 데이터의 삽입/삭제가 빈번하게 일어나고, 자료의 크기가 가변적인 경우에 적합



#### 참고링크 

https://velog.io/@717lumos/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8Linked-List-%EB%8B%A8%EC%9D%BC%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%9D%B4%EC%A4%91%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8


https://moonlight-spot.tistory.com/entry/%EB%B0%B0%EC%97%B4Array-vs-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8Linked-List-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EB%B9%84%EA%B5%90-%EB%B0%8F-%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0?category=1034996