## 트라이(Trie)

![image](https://github.com/user-attachments/assets/30e30cf9-ae20-47b5-9c30-3f6ce77554b0)

- 트라이(Trie)는 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조이다.
- 이진 트리의 모습이 아닌 전형적인 다진 트리의 형태를 띤다.
- 자연어 처리(NLP) 분야에서 문자열 탐색을 위한 자료구조로 널리 쓰인다. **문자열을 위한 트리**의 형태이기때문에 사실상 문자 개수 만큼의 자식이 있어 많은 자식노드를 가지고 이싿. 
- 검색할 때 볼 수 있는 자동완성 기능, 사전 검색 등 문자열을 탐색하는데 특화되어있는 자료구조라고 한다.
    - 예를 들어 'Datastructure'라는 단어를 검색하기 위해서는 제일 먼저 'D'를 찾고, 다음에 'a', 't', ... 의 순서로 찾으면 된다. 이러한 개념을 적용한 것이 트라이(Trie)이다.
- **즉, 문자열을 빠르게 탐색할 수 있는 자료구조**

![image](https://github.com/user-attachments/assets/e2384e35-4d55-4085-bf51-da47b3a6614c)

- 위의 그림은 문자열 집합 {"rebro", "replay", "hi" , "high", "algo"} 를 트라이로 구현한 것이다. 
- 트라이는 집합에 포함된 문자열의 접두사들에 대응되는 노드들이 서로 연결된 트리이다. 한 문자열에서 다음에 나오는 문자가 현재 문자의 자식노드가 되고 빨간색으로 나타낸 노드는 문자열의 끝을 의미한다.
- 트라이 구조에서 문자열을 탐색하기 위해서는 다음 글자에 해당하는 노드가 연결되어 있는지, 연결되어 있다면 그 노드를 타고 계속해서 따라한다. 문자열의 끝에 도달했을 때, 해당 노드에서 끝나는 문자열(빨간 노드)이 있다면 찾고자 하는 문자열이 집합에 포함되어 있는 것이다. 
    - 즉, 문자열의 끝을 나타내는 빨간 노드는 항상 하나의 문자열의 끝을 의미하게 되는 것을 알 수 있다.
- 트라이의 중요한 속성 중 하나는, 루트에서부터 내려가는 경로에서 만나는 글자들을 모으면 찾고자 하는 문자열이 된다. 
    - 예를 들어서 "apple"를 찾는다고 가정하면 a -> ap -> app -> appl -> apple 된다.

## 트라이(Trie) 특징
### 루트 노드
- 루트 노드는 항상 비어있다.
- 루트 노드의 자식 노드는 각 단어의 첫 글자들이다.

### endOfWord 표시
- 파란색으로 칠해져있는 노드는 각 문자열의 마지막 글자다.

### 각 노드 구성
- 각 노드의 자식 노드들을 Map에 저장한다.
- 해당 노드가 단어의 마지막을 뜻하는 endOfWord를 저장할 boolean형 필드를 갖는다. 

## 트라이(Trie) 장점
- 문자열 검색시에 빠르다.
- 문자열을 탐색할 때 하나씩 전부 비교하면서 탐색하는 것보다 시간 복잡도 측면에서 훨씬 더 효율적이다.

## 트라이(Trie) 단점.
- 각 노드에서 자식들에 대한 포인터들을 배열로 모두 저장하고 있다는 점에서 저장 공간의 크기가 크다는 단점이 있다. 메모리 측면에서 비효율적일 수 있다.
    - 문자열이 모두 영소문자로 이루어져 있다고 해도, 자식 노드를 가리키는 26개의 포인터를 저장해야 한다. 
    - 최악의 경우에는 집합에 포함되는 문자열들의 길이의 총합만큼 노드가 필요하므로, 총메모리는 O(포인터 크기 * 포인터 배열 개수 * 총노드의 개수)가 된다. 
    - 만약, 1000자리의 문자열이 1000개만 들어온다고 하더라도 100만 개의 노드가 필요하고, 포인터의 크기가 8byte라고 하면 약 200MB의 메모리가 필요하게 된다. 
    - 따라서, 이 단점을 해결하기 위해서 보통 map이나 vector를 이용하여 필요한 노드만 메모리를 할당하는 방식들을 이용하는데, 문제에 따라서 메모리 제한이 빡빡한 경우에는 최적화가 꽤나 까다롭다. 
    - 또한, 문제에서 주어진 조건을 보고 트라이를 이용할 수 있는 문제인지 파악하는 것도 중요하다

## 시간복잡도 
- 제일 긴 문자열의 길이를 L 총 문자열들의 수를 M이라 할 때 시간복잡도는 아래와 같다.
    - 생성 시 시간복잡도: O(M*L), 모든 문자열들을 넣어야하니 M개에 대해서 트라이 자료구조에 넣는건 가장 긴 문자열 길이만큼 걸리니 L만큼 걸려서 O(M*L)만큼 걸린다. 물론 삽입 자체만은 O(L)만큼 걸린다.
    - 탐색시 시간복잡도: O(L), 트리를 타고 들어가봤자 가장 긴 문자열의 길이만큼만 탐색하기 때문에 O(L)만큼 걸린다.


#### 참고 링크 

https://velog.io/@kimdukbae/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%8A%B8%EB%9D%BC%EC%9D%B4-Trie

https://innovation123.tistory.com/116

https://twpower.github.io/187-trie-concept-and-basic-problem

https://rebro.kr/86