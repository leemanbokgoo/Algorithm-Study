# 트리(tree)

![image](https://github.com/user-attachments/assets/0eeae243-0989-4795-90d0-17f9363da7c4)

- 그래프의 일종으로 계층 구조를 가지는 비선형 자료구조다 루트 값과 부모-자식 관계의 서브 트리로 구성되며 서로 연결된 노드의 집합이다. 
- 비선형 구조로 선형 구조와는 다르게 데이터가 계층적 혹은 망으로 구성되어있다. 
    - 선형 구조는 자료를 저장하고 꺼내는 것에 초점이 맞춰져 있고, 비 선형 구조는 표현에 초점이 맞춰져있다. 

## 트리 특징
- 트리는 아래와 같은 특징들 덕분에 디렉터리 구조, 데이터 베이스 인덱스 등 계층적인 데이터 관리와 탐색에 널리 사용된다.

### 계층적 구조
- 트리는 루트 노드(root Node, 최상단 노드)에서 시작해 자식 노드(아래 방향)들로 뻗어나가는 계층적 자료구조로 데이터를 논리적이고 구조화된 방식으로 표현할 수 있다. 
- 고로 부모-자식 관계가 존재해 레벨이 존재한다. 

## 자기 참조 구조
- 재귀로 정의된 자기 참조 자료구조다.
    - 트리는 자식도 트리고, 그 자식도 트리다. 즉, 여러개의 트리가 쌓아올려져 큰 트리가 된다. 흔히 **서브 트리**로 구성된다고 표현한다.

### 비순환성 
- 트리는 사이클(순환)이 없는 비순환 구조다. 즉, 트리 내부에서 루프가 발생하지않으며 부모 노드와 자식노드간의 이동만 가능하다. 

### 연결성
- 트리의 모든 노드는 루트 노드에서 단 하나의 경로로 연결된다. 따라서 트리는 하나의 연결된 그래프로 볼 수 있다. 


### Tree 용어
- 노드(Node) : 트리에서 데이터를 저장하는 기본 단위. 트리의 각 노드는 데이터를 포함하며, 다른 노드들과의 부모-자식 관계를 형성할 수 있다.
- 간선(Edge, Link, Branch) : 트리에서 노드 간의 연결을 나타내는 선입니다. 간혹 Link, Branch라는 용어로도 불린다. 트리에서는 각 간선이 부모 노드와 자식 노드를 연결하며, 단방향성을 가진다.
    - 노드가 N개라고 할때, 간선은 N-1개. 간선(Edge)은 부모와 자식을 잇는 선으로 즉, 노드 하나당 자신을 부모와 연결해주는 간선이 딱 하나씩 달려 있다. 하지만 루트 노드는 부모가 없어 간선이 없음으로 -1을 해주는 것이다.각 레벨 k에 존재하는 노드는 2^K개(완전 이진트리의 경우)
- 루프 노드(Root Node) : 트리의 최상단에 위치한 노드로, 트리의 시작점이다. 트리에는 단 하나의 루트만이 존재하며, 이 루트 노드는 트리의 모든 다른 노드들과 경로로 연결되어 있다. 부모가 없는 유일한 노드
- 리프 노드(Leaf Node) : 자식이 없는 노드, 트리의 말단. 트리의 탐색이 끝나는 지점을 나타내며 다른 노드로 더이상 연결되지 않음.
- 부모 노드와 자식노드 
    - 부모 노드 (Parent Node) : 다른 노드를 연결하고 있는 상위 노드, 연결된 하위 노드를 자식 노드라고 함.
    - 한 부모 노드는 여러 자식 노드를 가질 수 있지만 한 자식 노드는 반드시 하나의 부모 노드만 가진다. 
- 형재 노드(Sibling Nodes) : 같은 부모 노드를 공유하는 노드들. 같은 레벨에 있는 노드들이며 서로 인접한 관계로 묶여있다. 위치가 인접하다는 것일뿐 그래프에서의 인접 개념과는 다른 의미다.

![image](https://github.com/user-attachments/assets/6d5bd514-fd21-4429-a4c2-c625341a785a)

- 서브 트리(SubTree) : 트리 내의 어느 한 노드를 루트로 하는 트리. 트리의 각 노드는 자신을 루트로 하는 하위 트리(서브트리)를 형성할 수 있다. 
- 깊이(Depth) : 특정 노드가 루트 노드로부터 떨어진 거리를 나타낸다. 루트 노드의 깊이는 0이며, 각 노드의 깊이는 부모 노드의 깊이보다 1만큼 크다. 
- 레벨 : 루트 노드를 기준으로 하는 트리의 깊이를 의미하며, 루트 노드는 0레벨, 그 아래로 내려갈수록 레벨이 1씩 증가한다. 같은 레벨에 있는 노드들은 같은 깊이를 가지며, 부모 노드가 같다면 이들은 서로 형제 노드가 된다.
- 높이(Height) : 특정 노드에서 리프 노드까지의 가장 긴 경로 (즉, 자식 노드로 내려가는 최대 깊이)를 의미한다. 트리의 높이는 루트 노드의 높이를 의미하며, 이는 트리에서 가장 깊은 노드까지의 경로 길이와 같다.
    - 리프 노드의 높이는 0이며, 부모 노드의 높이는 자식 노드의 높이보다 1만큼 크다.
    - 루트 노드의 높이는 트리 전체의 높이와 동일하다.
- 차수(Degree) : 하나의 노드가 가지고 있는 자식 노드의 수를 나타낸다. 트리의 최대 차수를 가지는 노드가 트리의 차수와 동일하다. 참고로 트리의 최대 차수가 2인 트리를 이진트리(Binary Tree)라고 부른다.


## Tree 용도
- 데이터의 계층적 구조를 표현하는 데 유용하다.
- 파일 시스템 구조 : 트리는 디렉토리 구조와 파일 시스템을 표현하는 데 사용. 루트 디렉토리에서 시작하여 하위 폴더와 파일로 뻗어 나가는 구조는 트리와 동일한 원리
- 데이터베이스 인덱스 : 트리는 데이터베이스 인덱싱에서 효율적인 검색을 위해 사용됨. 예를 들어, B-Tree와 B+Tree는 대규모 데이터베이스에서 빠른 검색과 정렬을 가능하게 해준다.
- 컴파일러 구조 : 트리는 컴파일러가 구문 분석 시 프로그램의 구조를 나타낼 때 사용된다. 구문 분석 트리(Syntax Tree)는 프로그램의 문법 구조를 트리 형태로 표현
- 이진 탐색 트리(Binary Search Tree, BST) : 이진 트리는 검색 속도를 개선하기 위해 활용된다. 특히, BST는 정렬된 데이터를 저장하여 빠른 검색, 삽입, 삭제 연산을 수행할 수 있다.
- 네트워크 라우팅 : 트리는 네트워크에서 효율적인 경로 탐색 및 패킷 전달을 위해 사용되며, 최소 신장 트리(MST) 같은 알고리즘으로 네트워크 연결을 최적화할 수 있다.
- 게임 및 AI : 트리는 게임 트리, 의사결정 트리(Decision Tree) 등의 구조로 활용되며, AI와 머신러닝 분야에서는 의사결정 트리(Decision Tree)와 같은 알고리즘이 사용된다.



## 트리 순회 
- 트리 순회란 그래프 순회의 한 형태로서 트리 자료구조에서 각 노드를 정확히 한번 방문하는 과정을 말한다.
- 그래프 순회와 마찬가지로 트리 순회 또한 DFS 또는 BFS로 탐색하는데 특히 이진 트리에서 DFS는 방문 순서에 따라 다음과 같이 크게 3가지 방식으로 구분된다.
- 순회 방식을 구성하는 L,R,N의 의미는 다음과 같다.
    - L : 현재 노드의 왼쪽 서브트리
    - R : 현재 노드의 오른쪽 서브트리
    - N : 현재 노드(자기 자신을 의미)

### 전위(Rre-Order) 순회(NLR)

![image](https://github.com/user-attachments/assets/cef41e76-73ae-4159-83c0-ecc79cb1f876)

- 트리를 복사하거나 전위 표기법을 구하는 데 주로 사용된다. 
    - 트리를 복사할때 전위 순회를 사용하는 이유는 트리를 생성할 때 자식 노드보다 부모 노드가 먼저 생성되어야 하기 때문이다.
- 현재 노드 -> 왼쪽 서브트리 -> 오른쪽 서브 트리 순으로 진행한다.
    - root 노드 방문
    - 왼쪽 서브 트리 전위 순회.
    - 오른쪽 서브 트리 전위 순회
- 위 트리의 전위 순회 결과는 A→B→D→E→C→F→G

```
def preorder(node):
    if node is None:
        return
    
    print(node.val)
    preorder(node.left)
    preorder(node.right)

```

### 중위(In-Order) 순회(LNR)

![image](https://github.com/user-attachments/assets/ae2fbe8b-bfa6-4a3d-96c5-5eab15c40d24)

- 이진 탐색트리(BST)에서 오름차순 또는 내림차순으로 값을 가져올 때 사용한다.
- 왼쪽 서브 트리-> 현재 노드 -> 오른쪽 서브 트리 순으로 순회한다.
    - 왼쪽 서브 트리 중위 순회.
    - root 노드 방문
    - 오른쪽 서브 트리 중위 순회
- 내림 차순으로 값을 가져오기 위해서는 역순(오른쪽-> root ->왼쪽)으로 순회한다. 
- 위 트리의 중위 순회 결과는 D→B→E→A→F→C→G

```
def inorder(node):
    if node is None:
        return
    
    inorder(node.left)
    print(node.val)
    inorder(node.right)

```

### 후위(Post-Order) 순회(LRN)

![image](https://github.com/user-attachments/assets/e64085ae-ac52-4dc5-b3ca-b8f5c6edc7e9)

- 트리를 삭제하는 데 주로 사용된다. 이유는 부모 노드를 삭제하기 전에 자식 노드를 삭제하는 순으로 노드를 삭제해야 하기 때문이다.
- 왼쪽 서브트리 -> 오른쪽 서브트리 -> 현재 노드 순으로 순회한다.
    - 왼쪽 서브 트리 후위 순회
    - 오른쪽 서브 트리 후위 순회
    - root 노드 방문
- 위 트리의 후위 순회 결과는 D->E->B->F->G->C->A

```
def postorder(node):
    if node is None:
        return
    
    postorder(node.left)
    postorder(node.right)
    print(node.val)

```

#### 예시 

![image](https://github.com/user-attachments/assets/0ef511b7-d595-43f1-b9d5-e09f6e8c1267)

- 위의 트리를 순회한다고 해보자.
    - 전위 순회 : F,B,A,D,C,E,G,I,H
    - 중위 순회 : A,B,C,D,E,F,G,I,H
    - 후위 순회 : A,C,E,D,B,H,I,G,F 


## 그래프 VS 트리 
! [그래프에 대한 설명](https://github.com/leemanbokgoo/Algorithm-Study/blob/main/study/%EA%B7%B8%EB%9E%98%ED%94%84.md)

- 주요 차이점은 순환유무, 계층구조, 연결성으로 트리는 계층적 데이터를 표현하거나 탐색하는데 적합한 자료구조이고, 그래프는 복잡한 네트워크나 연결성을 분석하는 데 적합한 자료구조.

### 순환 유무 
- 트리는 순환구조를 갖지않는 그래프이다. 둘의 핵심 차이는 순환구조가 아니라는 데 있다. 트리는 특수한 형태의 그래프의 일종이며 크게 그래프의 범주에 포함된다. 하지만 트리는 그래프와 달리 어떠한 경우에도 한번 연결된 노드가 다시 연결되는 법이 없다.
- 그래프는 순환이 발생할 수 있다. 비순환 그래프일수도 있고 순환 그래프일수도 있다. 

### 루트의 계층적 구조
- 트리는 하나의 루트 노드를 가지며, 모든 노드는 이 루트 노드로부터 어떤 경로를 통해 도달 할 수 있다. 또한 트리는 계층적인 구조를 가지며, 각 노드는 하나의 부모노드와 여러개의 자식 노드를 가질 수 있다. (오직 루트 노드만이 부모 노드가 없다.)
- 그래프는 루트 노드가 없거나 여러개의 루트 노드를 가질 수 있고 노드간의 관계가 자유로운 형태일 수 있다. 계층 구조가 강제 되지않는다.

### 간선의 방향성
- 트리는 부모 → 자식 단방향 자료구조이다. 
- 그래프는 방향 그래프일 수 있으며 방향이 자유롭게 지정될 수 있다. 

### 연결성
- 트리는 서로 항상 연결 되어있어야한다. 트리에서 "연결된" 상태란, 임의의 두 노드 사이에 반드시 경로가 존재한다는 것을 의미한다.
- 그래프는 연결 되어있지않을 수도있다. 비연결 그래프 (Disconnected Graph) 또는 분리된 그래프가 존재할 수 있다. 

### 가중치와 속성
- 트리는 노드의 값 자체를 데이터로 다루는 경우가 많아, 간선에 별도의 가중치를 두지 않는 것이 일반적이다. 하지만, 가중치나 속성을 가질 수 있다. (예: 우선순위 큐를 구현하는 **힙(Heap)**은 노드의 값에 우선순위 가중치가 부여된 트리 형태. 노드의 값이 곧 우선 순위(가중치) 역할을 함. )
- 그래프는 간선에 가중치를 가질 수 있으며 노드와 간선에 다양한 속성이 할당 될 수 있다. 


## 트리 종류
- 트리 중에서도 가장 널리 사용되는 트리 자료구조는 이진 트리와 이진 탐색 트리(이하 BST)

## 이진트리 Binary Tree
![image](https://github.com/user-attachments/assets/f3e38610-97ab-49a6-bf9d-ff5e85cd85e0)

![image](https://github.com/user-attachments/assets/bb8019c0-ecc3-4493-bf69-33c82d918865)


- 각 노드가 m개 이하의 자식을 가지고 있으면 m-ary트리(다항트리, 다진트리)라고 한다. 여기서 m=2일 경우. 즉, 모든 노드의 차수가 2 이하일때(= 각 노드가 최대 2개의 자식을 가질 때) 특별히 이진 트리(binary tree)라고 구분해서 부른다.
    - 최대 2개이기때문에 자식이 있을 수도 있고 한개만 있을 수도 있음. 이때 자식은 각각 왼쪽 자식 노드와 오른쪽 자식 노드로 표현한다. 
- 이진 트리는 최대 2개의 자식을 갖는 매우 단순한 형태로 다진 트리에 비해 간결할 뿐 아니라 여러가지 알고리즘을 구현하는 일도 좀 더 간단하게 처리할 수 있어서 대체로 트리라고 하면 이진트리를 일컫는다.
- - 그래서 같은 루트에 같은 자식 노드 하나를 가지고 있어도. 자식 노드의 위치가 각각 오른쪽과 왼쪽으로 다르다면 두 트리는 서로 다른 트리가 된다. 
- 자료를 효율적으로 정렬하고 탐색하는데 매우 유용하며, 다양한 알고리즘에서 널리 사용된다.

### 이진 트리 유형
! [해당 링크 참고](https://velog.io/@dankj1991/Tree-Binary-Tree)
- 정 이진 트리(Full Binary Tree) : 모든 노드가 0개 또는 2개의 자식 노드를 갖는다.
- 완전 이진 트리(Complete Binary Tree) : 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져있으며, 마지막 레벨의 노드는 가장 왼쪽부터 채워져있다.
- 포화 이진 트리(Perfect Binary Tree) : 모든 노드가 2개의 자식 노드를 갖고 있으며, 모든 리프 노드가 동일한 깊이 또는 레벨을 갖는다. 문자 그대로, 가장 완벽한 유형의 트리다.  

## 이진 트리의 주요 특징

### 자식 노드의 수 제한 
- 이진 트리의 가장 큰 특징은 각 노드가 최대 두 개의 자식 노드를 가질 수 있다는 점.
    - 즉, 왼쪽 자식과 오른쪽 자식으로만 연결된다.
    - 둘 중 하나가 없거나 둘다 없어도 무방하며 3개를 넘지만 않으면 된다.

### 재귀적 구조
- 트리는 본질적으로 재귀 구조를 가지며, 하위 트리 (subtree)들도 하나의 이진 트리로 취급된다. 

### 균형성
- 이진트리에서는 노드가 어느 한쪽에 치우치지 않고 균형적으로 분포되는 것이 이상적이다. 
    - 균형 잡힌 트리 (Balanced Binary Tree)는 탐색, 삽입, 삭제 와 같은 연산에서 O(log n)의 시간 복잡도를 가진다.
    - 반면, 비균형 트리는 특정한 경로가 지나치게 길어지면, 선형 탐색과 유사한 O(n) 시간 복잡도를 가질 수 있다. 

## 이진 트리의 용도
- 이진 트리는 그 특성상 여러 분야에서 탐색, 정렬, 데이터 관리 등의 목적으로 널리 사용된다.

#### 이진 탐색 트리(Binary Search Tree, BST)
- 이진 탐색 트리는 각 노드가 왼쪽 자식은 부모보다 작은 값, 오른쪽 자식은 부모보다 큰 값을 가지도록 구성된 트리이다. 이를 통해 빠른 검색과 정렬이 가능하다. 참고로 이진 트리는 이러한 강제적인 규칙이 없다. 
- 다만, BST는 삽입과 삭제 과정에서 트리가 한쪽으로 치우쳐 비균형 상태가 될 수 있다.
- 이 경우, 탐색 성능이 O(n)으로 저하될 수 있으며, 이를 해결하기 위해 AVL 트리나 Red-Black 트리와 같은 자체 균형 트리가 사용된다.

#### 힙(Heap)
- 힙은 최대값 또는 최소값을 빠르게 찾기 위해 사용하는 완전 이진 트리이다. 주로 우선순위 큐 및 최단 경로 탐색에 활용된다.
- 최대 힙(Max Heap)에서는 부모 노드의 값이 자식 노드보다 크거나 같습니다, 반면에 최소 힙(Min Heap)에서는 부모 노드의 값이 자식 노드보다 작거나 같다.

#### 트리 기반 검색 알고리즘
- 이진 트리는 이진 탐색, 트리 순회 알고리즘(Pre-order, In-order, Post-order) 등에서도 매우 유용하게 쓰인다.

### 이진 트리 탐색 기본 템플릿 코드 

```
/**
 * 이진 트리 노드 정의
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    // 결과를 저장할 멤버 변수 (파이썬의 self.longest 역할)
    private int longest = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return this.longest;
    }

    private int dfs(TreeNode node) {
        // 리프 노드의 자식(null)에 도달했을 때 -1 리턴
        if (node == null) {
            return -1;
        }

        // 왼쪽, 오른쪽 자식 노드 깊이 탐색
        int left = dfs(node.left);
        int right = dfs(node.right);

        // 지름(경로의 길이) 갱신: 왼쪽 깊이 + 오른쪽 깊이 + 간선 2개
        this.longest = Math.max(this.longest, left + right + 2);

        // 부모 노드에게 현재 노드까지의 최대 상태값 전달
        return Math.max(left, right) + 1;
    }
}
```

## 완전 이진트리 
- 이진트리 중에서도 마지막 레벨을 제외한 모든 레벨에는 노드들이 가득 차 있고, 마지막 레벨의 노드들도 좌측부터 순서로 들어가있는 형태의 이진트리를 완전 이진트리라고 한다. 노드를 삽입할때 왼쪽부터 차례대로 삽입하는 트리이다. 
- 노드가 최대 2개의 자식 노드를 갖는 트리 형태의 자료구조로서 마지막 레벨을 제외한 모든 노드는 완전히 채워져 있어야 한다. 또한, 최하단 레벨의 노드는 좌측만 노드가 채워져 있거나 좌측과 우측 모두 채워져 있어야 하며, 노드를 삽입할 때는 최하단 좌측 노드부터 차례대로 삽입해야 합니다(그림 1 참고). 그림 1 우측 트리는 노드 12의 자식 노드가 우측에만 삽입되어 있기 때문에 완전 이진트리라고 할 수 없다.

![image](https://github.com/user-attachments/assets/de2d3b9b-2478-435f-b90b-237235fa3c2c)

### 완전 이진트리 조건
- 첫째, 마지막 레벨을 제외하고 모든 노드가 채워져있어야한다. 마지막 레벨의 노드는 다 채워져 있을 수도 있고 아닐 수도 있다.
- 둘째, 노드는 왼쪽에서 오른쪽 방향으로 채워져야한다. 그래서 어느 노드에 오른쪽 자식이 존재한다면 왼쪽 자식도 가지고 있어야 완전 이진트리로 볼 수 있다. 

## 완전 이진트리 특징
### 효율적인 배열 구현
- 배열을 이용해 구현할때의 효율성이 좋다. 노드가 왼쪽부터 순서대로 빈틈없이 채워져 있기 때문에, 연결 구조(포인터)를 사용할 필요 없이 배열의 인덱스만으로 부모/자식 노드를 쉽게 계산할 수 있다. 예를 들어, 배열 인덱스 i에 있는 노드의 왼쪽 자식은 2i+1, 오른쪽 자식은 2i+2에 위치한다. (0부터 시작하는 인덱스 기준).이는 메모리상의 연속된 공간을 사용하므로, 메모리 접근 속도(캐시 효율성)가 높아지고 포인터 오버헤드가 없어 매우 빠르다.

### 자료구조 힙(Heap)의 근간이 됨
- 힙(Heap) 자료구조는 반드시 완전 이진 트리 형태여야 한다.
- 힙은 가장 중요한 요소(최소값 또는 최대값)를 O(1)의 시간 복잡도로 빠르게 찾고, 요소를 삽입하거나 삭제할 때 O(log n)의 효율적인 시간 복잡도를 유지해야 한다. 완전 이진 트리의 규칙(항상 균형이 잡혀있음) 덕분에 트리의 높이가 항상 logn으로 유지될 수 있으며, 이를 통해 힙 연산의 효율성(시간 복잡도)이 보장됩니다.
- 완전 이진 트리는 배열을 이용한 효율적인 저장 방식을 제공함으로써, 힙과 같은 자료구조가 안정적이고 빠른 성능을 발휘할 수 있는 구조적 토대를 마련해준다.






#### 참고 링크 
https://planbs.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Tree%EC%99%80-Tree%EC%9D%98-%ED%91%9C%ED%98%84-%EB%B0%A9%EC%8B%9D

https://vitaminlog.tistory.com/59

https://bigsong.tistory.com/33

- 트리 유형을 자세히 알고 싶으면 밑의 링크를 참고 
https://velog.io/@dankj1991/Tree-Binary-Tree

https://yoongrammer.tistory.com/70

https://heytech.tistory.com/105

https://rosweet-ai.tistory.com/55

https://velog.io/@dankj1991/Tree-Binary-Tree

https://velog.io/@dankj1991/Tree-Intro