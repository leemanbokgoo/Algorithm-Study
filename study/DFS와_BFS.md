## DFS와 BFS
- 정렬된 데이터를 이분 탐색하는 것처럼(Binary Search) 아주 효율적인 방법이 있는 반면에, 모든 경우의 수를 전부 탐색해야 하는 경우도 있다. 대표적인 예가 알파고다. 대국에서 발생하는 모든 수를 계산하고 예측해서 최적의 수를 계산하기위해서 모든 수를 탐색해야한다. 이럴때 DFS와 BFS를 사용한다. 
- DFS 와 BFS 는 그 탐색하는 순서에서 차이가 있다.
    - DFS 는 끝까지 파고드는 것.
    - BFS 는 갈라진 모든 경우의 수를 탐색해보고 오는 것

## DFS(Depth First Search) : 깊이 우선 탐색

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/500144591-09ad4e14-e6b1-4065-b5b6-5c33a00854bb.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251011%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251011T124431Z&X-Amz-Expires=300&X-Amz-Signature=6d214f7a2c93644c1dc8b3288d098930427de35f69c48ccec2a25b9ec7b55a22&X-Amz-SignedHeaders=host)


- 자료의 검색, 트리나 그래프를 탐색하는 방법. 한 노드를 시작으로 인접한 다른 노드를 재귀적으로 탐색해가고 끝까지 탐색하면 다시 위로 와서 다음을 탐색하여 검색한다.
- DFS 는 끝까지 파고들기 때문에 **그래프의 최대 깊이 만큼의 공간**을 요구한다. 따라서 공간을 적게 쓴다. 그러나 최단 경로를 탐색하기 쉽지 않다. 여기서 DFS가 공간을 적게 쓴다는 말은 **보조 자료 구조(Stack)**에 동시에 저장하는 노드의 수가 BFS의 큐에 저장하는 노드의 수보다 일반적으로 훨씬 적다는 의미이며, 전체 노드에 대한 방문 기록은 DFS도 똑같다. 즉, DFS가 재귀 호출 스택이나 명시적 스택을 사용하기떄문이다. 
- 갈 수 있는 만큼 계속해서 탐색하다가 갈 수 없게 되면 다른 방향으로 다시 탐색하는 구조다. 동작 흐름은 다음과 같다.
    - 노드를 방문하고 **깊이 우선으로 인접한 노드를 방문**한다.
    - 또 그 노드를 방문해서 **깊이 우선으로 인접한 노드를 방문**한다.
    - 만약 끝에 도달했다면 리턴한다. 


## DFS의 동작 흐름
- DFS 의 반복 방식은 방문하지 않은 원소를 계속해서 찾아가면 된다.즉, DFS(node) = node + DFS(node와 인접하지만 방문하지 않은 다른 node)로 반복하면 된다. 만약 1이라는 노드를 방문했다면 그다음 선택지는 1과 인접하지만 방문하지않은 노드들을 방문하라는 뜻이다. 
- 다만 해당 노드를 방문하지 않았다는 조건을 알기 위해서는 방문했던 노드를 전부 기록해놔야 한다. 이를 위해 visited 라는 배열에 방문한 노드를 기록해두면 된다.
- 동작 흐름은 다음과 같다. 
    - 1. 루트 노드부터 시작한다.
    - 2. 현재 방문한 노드를 visited 에 추가한다.
    - 3. 현재 방문한 노드와 인접한 노드 중 방문하지 않은 노드에 방문한다.
    - 4. 2부터 반복한다.

### DFS 구현 코드 예시 : 재귀 함수 

- 아래의 그래프를 DFS를 통해 탐색해본다. 

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/499976911-b61494fb-23ea-431f-b971-4bac67745713.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251010%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251010T172218Z&X-Amz-Expires=300&X-Amz-Signature=2e1312d8e60197fc2f0eb8b2ec4f4287fbc363f3dc0c4dddeff2cc3b5126616f&X-Amz-SignedHeaders=host)

- 다음은 재귀 함수를 통해 구현 할 경우 DFS 코드의 동작을 먼저 설명해본 글이다. 
```
# 위 그림의 그래프를 예시로 삼아서 인접 리스트 방식으로 표현해보자.
graph = {
    1: [2, 5, 9],
    2: [1, 3],
    3: [2, 4],
    4: [3],
    5: [1, 6, 8],
    6: [5, 7],
    7: [6],
    8: [5],
    9: [1, 10],
    10: [9]
}
visited = [] # 방문한 걸 저장하기 위한 배열

1. 우선 탐색 시작 노드를 1로 잡는다.

2. 현재 방문한 노드인 1을 visited 에 추가한다. # visited -> [1]

3. 인접한 노드들인 [2, 5, 9] 에서 방문하지 않은 것들은 [2, 5, 9] 이다. 2 에 방문한다.

4. 현재 방문한 노드인 2을 visited 에 추가한다. # visited -> [1, 2]

5. 인접한 노드들인 [1, 3] 에서 방문하지 않은 것들은 [3] 이다. 3에 방문한다.

6. 현재 방문한 노드인 3을 visited 에 추가한다. # visited -> [1, 2, 3]

7. 인접한 노드들인 [2, 4] 에서 방문하지 않은 것들은 [4] 이다. 4에 방문한다.

8. 현재 방문한 노드인 4을 visited 에 추가한다. # visited -> [1, 2, 3, 4]

9. 인접한 노드들인 [3] 에서 방문하지 않은 것들이 없다. 7로 돌아간다.

7. 인접한 노드들인 [2, 4] 에서 방문하지 않은 것들이 없다. 5로 돌아간다.

5. 인접한 노드들인 [1, 3] 에서 방문하지 않은 것들이 없다. 3로 돌아간다.

3. 인접한 노드들인 [2, 5, 9] 에서 방문하지 않은 것들은 [5, 9] 이다. 5에 방문한다.

10. 현재 방문한 노드인 5를 visited 에 추가한다.  # visited -> [1, 2, 3, 4, 5]

11. 인접한 노드들인 [1, 6, 8] 에서 방문하지 않은 것들은 [6, 8] 이다. 6에 방문한다.

12. 현재 방문한 노드인 6를 visited 에 추가한다.  # visited -> [1, 2, 3, 4, 5, 6]

13. 인접한 노드들인 [5, 7] 에서 방문하지 않은 것들은 [7] 이다. 7에 방문한다.

14. 현재 방문한 노드인 7를 visited 에 추가한다.  # visited -> [1, 2, 3, 4, 5, 6, 7]

15. 인접한 노드들인 [6] 에서 방문하지 않은 것들이 없다. 11로 돌아간다.

11. 인접한 노드들인 [1, 6, 8] 에서 방문하지 않은 것들은 [8] 이다. 8에 방문한다.

16. 현재 방문한 노드인 8을 visited 에 추가한다.  # visited -> [1, 2, 3, 4, 5, 6, 7, 8]

17. 인접한 노드들인 [5] 에서 방문하지 않은 것들이 없다. 11로 돌아간다.

11. 인접한 노드들인 [1, 6, 8] 에서 방문하지 않은 것들이 없다. 3으로 돌아간다.

3. 인접한 노드들인 [2, 5, 9] 에서 방문하지 않은 것들은 [9] 이다. 9에 방문한다.

18. 현재 방문한 노드인 9을 visited 에 추가한다.  # visited -> [1, 2, 3, 4, 5, 6, 7, 8, 9]

19. 인접한 노드들인 [1, 10] 에서 방문하지 않은 것들은 [10] 이다. 10에 방문한다.

20. 현재 방문한 노드인 10을 visited 에 추가한다.  # visited -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

21. 인접한 노드들인 [9] 에서 방문하지 않은 것들이 없다. 19로 돌아간다.

19. 인접한 노드들인 [1, 10] 에서 방문하지 않은 것들이 없다. 3로 돌아간다.

3. 인접한 노드들인 [2, 5, 9] 에서 방문하지 않은 것들이 없다. 1로 돌아간다.

1. 끝났습니다.

```

- 위의 동작방식을 코드로 표현하면 다음과 같다. 

```
# 위의 그래프를 예시로 삼아서 인접 리스트 방식으로 표현함.
graph = {
    1: [2, 5, 9],
    2: [1, 3],
    3: [2, 4],
    4: [3],
    5: [1, 6, 8],
    6: [5, 7],
    7: [6],
    8: [5],
    9: [1, 10],
    10: [9]
}
visited = []

def dfs_recursion(adjacent_graph, cur_node, visited_array):
    # 방문한 노드를 기록 , cur_node : 현재 노드 
    visited_array.append(cur_node)

    # print("cur_node" . cur_node , "인접한 노드[cur_node]", adjacent_graph[cur_node])

    # 인접한 노드들을 하나씩 꺼내오는 반복문
    for adjacent_node in adjacent_graph[cur_node]:
        # 만약 인접한 노드가 방문한 노드 배열에 존재하지 않는다면
        if adjacent_node not in visited_array:
            # 재귀 호출을 통해 다음 depth(깊이)의 노드를 탐색한다. 
            # 여기서 adjacent_node(인접한 노드가) cur_node(현재 노드)라는 인자로 다음 재귀 호출에 주어진다.
            # 즉, 인접한 노드가 현재 노드가 되어 다음 depth(깊이)로 탐색이 넘어가는 것
            dfs_recursion(adjacent_graph, adjacent_node, visited_array)

dfs_recursion(graph, 1, visited)  # 1 이 시작노드
print(visited)  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 이 출력되어야 함.

```

### DFS 구현 코드 예시 : Stack 
- DFS는 재귀 함수를 통해 구현 할 수 있지만 재귀 함수를 통해 구현했을 경우 무한정 깊어지는 노드가 있다면 RecursionError 에러가 생길 수 있다. 가장 마지막에 넣은 노드를 꺼내서 탐색해야함으로 재귀 함수가 아닌 stack으로도 구현해볼 수 있다. 
- stack으로 구현할 경우, 재귀로 구현하는 방식과는 탐색하는 순서가 조금 다르다. 하지만 가장 깊게 탐색한다는 방식은 똑같다. 구현의 차이일뿐 개념은 동일하다는 뜻이다. 

- 구현의 방법은 다음과 같다.
    - 1. 루트 노드를 스택에 넣는다.
    - 2. 현재 스택의 노드를 빼서 visited 에 추가한다.
    - 3. 현재 방문한 노드와 인접한 노드 중 방문하지 않은 노드를 스택에 추가한다.
    - 4. 2부터 반복한다.
    - 5. 스택이 비면 탐색을 종료한다.

- stack을 사용해 DFS를 구현한다면 동작 방식은 다음과 같다. 

```
# 위의 그래프를 예시로 삼아서 인접 리스트 방식으로 했다.
graph = {
    1: [2, 5, 9],
    2: [1, 3],
    3: [2, 4],
    4: [3],
    5: [1, 6, 8],
    6: [5, 7],
    7: [6],
    8: [5],
    9: [1, 10],
    10: [9]
}
visited = [] # 방문한 걸 저장하기 위한 배열
stack = [1] # 시작 노드인 1을 넣어둔다.


1. 현재 스택에서 가장 마지막에 넣은 1을 빼서, visited 에 추가한다. 
# stack -> [] visited -> [1]

2. 인접한 노드들인 [2, 5, 9] 에서 방문하지 않은 것들인 [2, 5, 9]를 stack 에 추가한다. 
# stack -> [2, 5, 9] visited -> [1]

3. 현재 스택에서 가장 마지막에 넣은 9을 빼서, visited 에 추가한다. 
# stack -> [2, 5] visited -> [1, 9]

4. 인접한 노드들인 [1, 10] 에서 방문하지 않은 것들인 [10] 을 stack 에 추가한다. 
# stack -> [2, 5, 10] visited -> [1, 9]

5. 현재 스택에서 가장 마지막에 넣은 10을 빼서, visited 에 추가한다. 
# stack -> [2, 5] visited -> [1, 9, 10]

6. 인접한 노드들인 [9] 에서 방문하지 않은 노드들이 없으니 추가하지 않는다.
# stack -> [2, 5] visited -> [1, 9, 10]

7. 현재 스택에서 가장 마지막에 넣은 5를 빼서, visited 에 추가한다. 
# stack -> [2] visited -> [1, 9, 10, 5]

8. 인접한 노드들인 [1, 6, 8] 에서 방문하지 않은 것들인 [6, 8]를 stack 에 추가한다. 
# stack -> [2, 6, 8] visited -> [1, 9, 10, 5]

9. 현재 스택에서 가장 마지막에 넣은 8를 을 빼서, visited 에 추가한다. 
# stack -> [2, 6] visited -> [1, 9, 10, 5, 8]

10. 인접한 노드들인 [5] 에서 방문하지 않은 노드들이 없으니 추가하지 않는다.
# stack -> [2, 6] visited -> [1, 9, 10, 5, 8]

11. 현재 스택에서 가장 마지막에 넣은 6을 빼서, visited 에 추가한다. 
# stack -> [2] visited -> [1, 9, 10, 5, 8, 6]

12. 인접한 노드들인 [5, 7] 에서 방문하지 않은 것들인 [7] 을 stack 에 추가한다. 
# stack -> [2, 7] visited -> [1, 9, 10, 5, 8, 6]

13. 현재 스택에서 가장 마지막에 넣은 7를 을 빼서, visited 에 추가한다. 
# stack -> [2] visited -> [1, 9, 10, 5, 8, 6, 7]

14. 인접한 노드들인 [6] 에서 방문하지 않은 노드들이 없으니 추가하지 않는다.
# stack -> [2] visited -> [1, 9, 10, 5, 8, 6, 7]

15. 현재 스택에서 가장 마지막에 넣은 2를 빼서, visited 에 추가한다. 
# stack -> [] visited -> [1, 9, 10, 5, 8, 6, 7, 2]

16. 인접한 노드들인 [1, 3] 에서 방문하지 않은 것들인 [3] 을 stack 에 추가한다. 
# stack -> [3] visited -> [1, 9, 10, 5, 8, 6, 7, 2]

17. 현재 스택에서 가장 마지막에 넣은 3을 빼서, visited 에 추가한다. 
# stack -> [] visited -> [1, 9, 10, 5, 8, 6, 7, 2, 3]

18. 인접한 노드들인 [2, 4] 에서 방문하지 않은 것들인 [4] 를 stack 에 추가한다. 
# stack -> [4] visited -> [1, 9, 10, 5, 8, 6, 7, 2, 3, 4]

19. 현재 스택에서 가장 마지막에 넣은 4를 빼서, visited 에 추가한다. 
# stack -> [] visited -> [1, 9, 10, 5, 8, 6, 7, 2, 3, 4]

20. 인접한 노드들인 [3] 에서 방문하지 않은 노드들이 없으니 추가하지 않는다.

21. 현재 스택에서 꺼낼 것이 없다. DFS 가 끝났다.

```

- 이를 코드로 구현하면 다음과 같다. 
```
graph = {
    1: [2, 5, 9],
    2: [1, 3],
    3: [2, 4],
    4: [3],
    5: [1, 6, 8],
    6: [5, 7],
    7: [6],
    8: [5],
    9: [1, 10],
    10: [9]
}

def dfs_stack(adjacent_graph, start_node):
    # 시작 노드를 stack에 넣어줌 
    stack = [start_node]
    visited = []

    # stack에 값이 존재하는 동안
    while stack:
        # 현재 노드를 스택에서 꺼내온다.
        current_node = stack.pop()
        # 방문한 노드 배열에 현재 노드를 넣는다. 
        visited.append(current_node)

        # 현재 노드와 인접한 노드를 가져온다.
        for adjacent_node in adjacent_graph[current_node]:
            # 만약 인접한 노드가 방문 노드 배열에 없다면
            if adjacent_node not in visited:
                # 예를 들어 A의 인접 노드인 B와 C가 스택에 들어간 경우, 만약 C에 연결된 E, F가 있다면 E와 F가 다시 스택에 들어간다.
                # 다음에는 E나 F 중 하나가 꺼내져서 C-E나 C-F 방향으로 더 깊게 탐색이 진행된다. 
                # B는 C와 그 하위 노드들이 모두 탐색될 때까지 스택에 남아있게 된다. 
                # 그리고 C의 하위 노드들이 모두 탐색되고나면 B의 차례가 되어 B의 하위 노드를 다시 탐색한다. 
                stack.append(adjacent_node) # 스택에 인접한 노드를 넣어줌. 
    return visited

print(dfs_stack(graph, 1))  # 1 이 시작노드
# [1, 9, 10, 5, 8, 6, 7, 2, 3, 4] 이 출력되어야 한다.
```


## BFS(Breadth-first search) : 너비 우선 탐색

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/500144792-55bf8dc1-088a-4a75-b78c-bcf185509e72.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251011%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251011T124519Z&X-Amz-Expires=300&X-Amz-Signature=c6cc69fa37fbd37e776ae0b1d2bdebb7d8160bb8ff468658be13541a85815783&X-Amz-SignedHeaders=host)


- 한 노드를 시작으로 인접한 모든 정점들을 우선 방문하는 방법으로 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 모든 정점들에 대해서도 **넓이 우선 검색**을 적용한다.
- 모든 분기되는 수를 다 보고 올 수 있기때문에 BFS 는 최단 경로를 쉽게 찾을 수 있다.그러나, 모든 분기되는 수를 다 저장하다보니 공간을 많이 써야하고, 모든 걸 다 보고 오다보니 시간이 더 오래걸릴 수 있다.

### BFS 구현 : Queue
- BFS 는 현재 인접한 노드 먼저 방문해야 한다. 즉, 인접한 노드 중 방문하지 않은 모든 노드들을 저장해두고,가장 처음에 넣은 노드를 꺼내서 탐색하면 된다. 그러므로 가장 처음에 넣은 노드들 꺼내기 위해 큐를 이용할 수 있다. 
- 구현의 방법은 다음과 같다.
    - 1. 루트 노드를 큐에 넣습니다.
    - 2. 현재 큐의 노드를 빼서 visited 에 추가한다.
    - 3. 현재 방문한 노드와 인접한 노드 중 방문하지 않은 노드를 큐에 추가한다.
    - 4. 2부터 반복한다.
    - 5. 큐가 비면 탐색을 종료한다.

- 아래의 그래프를 BFS를 통해 탐색해본다. 

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/123913164/499976911-b61494fb-23ea-431f-b971-4bac67745713.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251010%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251010T172218Z&X-Amz-Expires=300&X-Amz-Signature=2e1312d8e60197fc2f0eb8b2ec4f4287fbc363f3dc0c4dddeff2cc3b5126616f&X-Amz-SignedHeaders=host)


- 큐를 사용하여 BFS를 구현할때 동작 흐름은 다음과 같다. 

```
# 위의 그래프를 예시로 삼아서 인접 리스트 방식으로 표현한다.
graph = {
    1: [2, 3, 4],
    2: [1, 5],
    3: [1, 6, 7],
    4: [1, 8],
    5: [2, 9],
    6: [3, 10],
    7: [3],
    8: [4],
    9: [5],
    10: [6]
}
visited = [] # 방문한 걸 저장하기 위한 배열
queue = [1] # 시작 노드인 1을 넣어둔다.

1. 현재 큐에서 가장 처음에 넣은 1을 빼서, visited 에 추가한다. 
# queue -> [] visited -> [1]

2. 인접한 노드들인 [2, 3, 4] 에서 방문하지 않은 것들인 [2, 3, 4]를 queue 에 추가한다. 
# queue -> [2, 3, 4] visited -> [1]

3. 현재 큐에서 가장 처음에 넣은 2을 빼서, visited 에 추가한다. 
# queue -> [3, 4] visited -> [1, 2]

4. 인접한 노드들인 [1, 5] 에서 방문하지 않은 것들인 [5]를 queue 에 추가한다. 
# queue -> [3, 4, 5] visited -> [1, 2]

5. 현재 큐에서 가장 처음에 넣은 3을 빼서, visited 에 추가한다. 
# queue -> [4, 5] visited -> [1, 2, 3]

6. 인접한 노드들인 [1, 6, 7] 에서 방문하지 않은 것들인 [6, 7]를 queue 에 추가한다. 
# queue -> [4, 5, 6, 7] visited -> [1, 2, 3]

7. 현재 큐에서 가장 처음에 넣은 4을 빼서, visited 에 추가한다. 
# queue -> [5, 6, 7] visited -> [1, 2, 3, 4]

8. 인접한 노드들인 [1, 8] 에서 방문하지 않은 것들인 [8]를 queue 에 추가한다. 
# queue -> [5, 6, 7, 8] visited -> [1, 2, 3, 4]

9. 현재 큐에서 가장 처음에 넣은 5을 빼서, visited 에 추가한다. 
# queue -> [6, 7, 8] visited -> [1, 2, 3, 4, 5]

10. 인접한 노드들인 [2, 9] 에서 방문하지 않은 것들인 [9]를 queue 에 추가한다. 
# queue -> [6, 7, 8, 9] visited -> [1, 2, 3, 4, 5]

11. 현재 큐에서 가장 처음에 넣은 6을 빼서, visited 에 추가한다. 
# queue -> [7, 8, 9] visited -> [1, 2, 3, 4, 5, 6]

12. 인접한 노드들인 [3, 10] 에서 방문하지 않은 것들인 [10]를 queue 에 추가한다. 
# queue -> [7, 8, 9, 10] visited -> [1, 2, 3, 4, 5, 6]

13. 현재 큐에서 가장 처음에 넣은 7을 빼서, visited 에 추가한다. 
# queue -> [8, 9, 10] visited -> [1, 2, 3, 4, 5, 6, 7]

14. 인접한 노드들인 [3] 에서 방문하지 않은 것들이 없으니 추가하지 않는다.
# queue -> [8, 9, 10] visited -> [1, 2, 3, 4, 5, 6, 7]

15. 현재 큐에서 가장 처음에 넣은 8을 빼서, visited 에 추가한다. 
# queue -> [9, 10] visited -> [1, 2, 3, 4, 5, 6, 7, 8]

16. 인접한 노드들인 [4] 에서 방문하지 않은 것들이 없으니 추가하지 않는다.
# queue -> [9, 10] visited -> [1, 2, 3, 4, 5, 6, 7, 8]

17. 현재 큐에서 가장 처음에 넣은 9을 빼서, visited 에 추가한다. 
# queue -> [10] visited -> [1, 2, 3, 4, 5, 6, 7, 8, 9]

18. 인접한 노드들인 [5] 에서 방문하지 않은 것들이 없으니 추가하지 않는다.
# queue -> [10] visited -> [1, 2, 3, 4, 5, 6, 7, 8, 9]

19. 현재 큐에서 가장 처음에 넣은 10을 빼서, visited 에 추가한다. 
# queue -> [] visited -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

20. 인접한 노드들인 [6] 에서 방문하지 않은 것들이 없으니 추가하지 않는다.
# queue -> [] visited -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

21. 현재 큐에서 꺼낼 것이 없다. BFS 가 끝났다.

```

- 이를 코드로 구현하면 다음과 같다. 

```
# 위의 그래프를 예시로 삼아서 인접 리스트 방식으로 표현했습니다!
graph = {
    1: [2, 3, 4],
    2: [1, 5],
    3: [1, 6, 7],
    4: [1, 8],
    5: [2, 9],
    6: [3, 10],
    7: [3],
    8: [4],
    9: [5],
    10: [6]
}


def bfs_queue(adj_graph, start_node):
    # 큐에 start_node를 먼저 넣어준다. (값 초기화)
    queue = [start_node]
    visited = []

    # 큐가 존재하는 동안.
    while queue:
        # 현재 노드는 큐에서 꺼낸 값이다.(맨 처음 값)
        current_node = queue.pop(0)
        # 현재 노드를 방문했으니 방문한 노드 배열에 기록한다.
        visited.append(current_node)

        # 현재 노드의 인접한 노드를 꺼내온다.
        for adjacent_node in adj_graph[current_node]:
            # 인접한 노드 중에 방문한 노드가 없다면
            if adjacent_node not in visited:
                # 큐에 추가해서 다음 루프에 반복할 수 있도록 해준다. 
                queue.append(adjacent_node)

    return visited

print(bfs_queue(graph, 1))  # 1 이 시작노드입니다!
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 이 출력되어야 합니다!
```

## 백트래킹(Backtraking)
- 백트래킹(Backtracking)은 퇴각 검색이라고도 불리는 알고리즘 기법으로, 정답을 찾기 위해 모든 가능한 경우의 수를 탐색하는 **완전 탐색(Brute Force)**을 기반으로 한다. 하지만 무작정 모두 탐색하는 것이 아니라, **'가지치기(Pruning)'**라는 과정을 통해 불필요한 경로를 조기에 차단함으로써 탐색 시간을 크게 줄이는 데 중점을 둔다. 그러나 최악의 경우에는 모든 경우를 다 거친 다음에 정답을 찾아낼 수 있다. 
    - 가지치기 : 백트래킹은 트리 구조를 기반으로 구현하는 경우가 많기 때문에 한정 조건에 도달하여 뒤로 돌아가 현재 경우 수를 제거하는 것을 가지치기라고 한다.
- 즉, 백트래킹(Backtracking, 퇴각 검색)은 해를 찾는 과정에서 제약 조건(한정 조건)을 기반으로 현재의 경로가 해가 될 가능성이 없다고 판단되면, 더 깊이 탐색하지 않고 이전 단계로 되돌아가서(Backtrack) 다른 후보를 시도하는 전략적 완전 탐색 기법이다.
- 주로 제약 충족 문제를 풀 때 주로 쓰이며 DFS 방식으로 주로 구현된다. 
- DFS는 가능한 모든 경로를 끝까지 탐색하는 반면, 백트래킹은 DFS의 탐색 과정에 **제약 조건 검사 로직(유망성 검사)**을 추가하여, 정답이 될 수 없는 경로는 중간에 포기하고 되돌아오게(Backtrack) 만든다.
- 즉, 백트래킹 = DFS + 가지치기라고 이해할 수 있다.
- 원하는 정답을 찾지 못했을 때 탐색을 처음부터 다시 시작하는 것이 아니라 이전 노드로 돌아가기 때문에 반복 횟수를 줄일 수 있는 장점이 있다. 추가적으로 현재 경우가 얼마나 유망한지 일찍 판단할 수 있다면 탐색의 속도를 상향시킬 수 있다.
- 안 되는 조건은 없애면서 탐색하기 때문에 시간복잡도가 선형적으로 증가할 법한 문제에서 백트래킹을 적용하면 시간복잡도를 줄일 수 있다.
- 주로 **제약 충족 문제(CPS)**를 풀이 할때 필수적인 알고리즘이다. 가지치기를 통해 제약 충족 문제를 최적화하기떄문임.
    - 제약 충족 문제 : 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제.
    

## 백트래킹 구현 방법 : 재귀함수 
- 백트래킹 구현시 재귀 구현이 선호되는 이유는 '퇴각(Backtrack) 과정의 편리성' 때문이다. 이유는 다음과 같다. 
    - 재귀 (선호): 재귀 함수가 종료(return)될 때마다, 함수의 지역 변수들은 자동으로 사라지고 프로그램 제어는 이전 함수 호출 지점으로 돌아간다. 이 과정 자체가 '퇴각' 및 **'상태 복원'**을 자연스럽게 처리해준다.
    - 명시적 스택 (비선호): 명시적 스택을 사용할 경우, 노드를 꺼낸 후 **탐색 과정에서 변경된 모든 상태(예: 방문 표시, 누적된 결과값 등)**를 개발자가 직접 코드로 **복원**해줘야한다. 이 로직이 매우 복잡하고 오류를 유발하기 쉽다. 
- 다만 재귀 함수로 구현 시 재귀 호출의 깊이가 너무 깊으면 에러가 발생할 수 있다. 이 부분을 신경써야하지만 대부분의 코딩 테스트나 알고리즘 문제에서 백트래킹은 재귀 깊이가 깊지 않은 문제로 출제되므로, 재귀 함수를 사용하는 것이 가장 일반적인 해결책이다.


```
# N과 M (1) - 1부터 N까지 중복 없이 M개를 고른 순열 구하기 예시
N = 4  # 전체 원소의 개수
M = 2  # 선택할 원소의 개수

# 결과 저장을 위한 리스트
result = []
# 방문 여부를 체크하는 배열 (순열에서 중복 방지용)
visited = [False] * (N + 1)  # 1부터 N까지 사용하므로 크기를 N+1로 설정

def backtracking():
    # 1. 종료 조건 (Base Case): M개의 원소를 모두 선택했을 때
    if len(result) == M:
        print(' '.join(map(str, result)))
        return

    # 2. 재귀 호출 (Recursive Call)
    for i in range(1, N + 1):  # 1부터 N까지의 숫자 탐색
        # 3. 유망성 검사 (Constraint Check): 이미 사용한 숫자라면 건너뜀
        if not visited[i]:
            # **상태 변경 (Do)**
            result.append(i)
            visited[i] = True

            # 다음 단계로 재귀 호출
            backtracking()

            # **상태 복구 (Undo / Backtrack)**
            # 현재 경로를 탐색 완료했으므로, 다음 탐색을 위해 상태를 되돌림
            result.pop()
            visited[i] = False

# 함수 실행
# backtracking()
```

- 가장 대표적인 예제인 **N과 M 문제 (순열/조합 구하기)**를 위한 템플릿 코드. 
- **재귀 함수 (DFS)**를 사용해 깊이를 탐색하며, 유망한지를 판단하는 **조건(Constraint)**을 추가해 응용

#### 참고링크 

https://velog.io/@seanlion/bfsdfs