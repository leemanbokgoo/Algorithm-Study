
## 정렬 알고리즘 문제 유형
- 정렬 라이브러리로 풀 수 있는 문제: 
    - 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.
- 정렬 알고리즘의 원리에 대해서 물어보는 문제
    - 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
- 더 빠른 정렬이 필요한 문제
    - 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.

## 정렬 알고리즘 선택 기준
- 데이터가 적고 간단한 경우 
    - 데이터 크기가 작을 때는 구현이 쉬운 삽입 정렬이나 선택 정렬이 적합
    - 삽입 정렬, 선택 정렬, 버블 정렬
- 데이터가 이미 거의 정렬된 경우:
    - 삽입 정렬 : 데이터가 거의 정렬된 경우 O(n)의 시간 복잡도로 동작하여 효율적이다.
- 큰 데이터, 랜덤 데이터:
    - 퀵 정렬, 합병 정렬, 힙 정렬
    - 퀵 정렬은 평균적으로 가장 빠른 정렬 알고리즘 중 하나이다. 그러나 최악의 경우 시간 복잡도가 O(n²)이므로 안정적인 성능을 원한다면 합병 정렬이나 힙 정렬을 선택할 수 있다.
- 정수 범위가 한정된 경우:
    - 계수 정렬, 기수 정렬, 버킷 정렬
    - 정수 데이터의 범위가 제한적이라면 계수 정렬이나 기수 정렬이 매우 효율적이다. 버킷 정렬은 데이터를 여러 그룹으로 나눌 수 있을 때 유리하다.
- 메모리 사용을 최소화해야 하는 경우:
    - 힙 정렬, 퀵 정렬
    - 힙 정렬은 추가 메모리를 거의 사용하지 않으며, 퀵 정렬도 평균적으로 적은 메모리를 사용한다.


## 정렬 알고리즘 요약 정리

![image](https://github.com/user-attachments/assets/98c19f9d-6064-4e3f-9039-931645fd6d16)

### 안정 정렬
- 중복된 값을 입력 순서와 동일하게 정렬한다.
    - 예를 들어 기존의 시간순으로 정렬했던 순서는 지역명을 재정렬하더라도 기존 순서(시간순)가 그대로 유지된 상태에서 정렬이 이뤄진다.

### 불안정 정렬
- 중복된 값을 입력 순서와 상관없이 무작위로 뒤섞인 상태에서 정렬이 이뤄진다. 
    - 예를들어 기존의 시간순으로 정렬한 값을 지역명으로 재정렬하면 기존의 정렬 순서는 무시된채 모두 뒤죽박죽 뒤섞인다.


--------



## 선택 정렬
- 정렬되지 않은 리스트에서 가장 작은(또는 큰) 값을 찾아 맨 앞의 데이터와 바꾸는 과정을 반복하여 정렬하는 알고리즘. 가장 원시적인 방법으로 '매번 가장 작은 것을 선택'한다는 의미에서 선택 정렬 알고리즘이라고 한다. 
- 구현이 간단하지만 데이터 크기가 커질 수록 성능이 떨어질 수 있다. 
- 선택 정렬을 이용하는 경우 데이터의 개수가 10,000개 이상이면 속도가 급격히 느려지는 것을 확인할 수 있다. 실제로 대부분의 정렬 알고리즘과 비교했을 때, 매우 비효율적이지만 선택 정렬의 방식은 **특정 리스트에서 가장 작은 데이터의 값을 찾을 때 자주 쓰인다.**

### 선택 정렬 시간 복잡도
- 최선의 경우: O(n²)
- 평균적인 경우: O(n²)
- 최악의 경우: O(n²)

### 선택 정렬 동작 방식
- 정렬되지 않은 배열에서 최소값(또는 최대값)을 찾는다.
- 최소값을 배열의 첫번째 요소와 교환한다.
- 나머지 배열에 대해 위 과정을 반복한다.
- 모든 요소가 정렬 될 때까지 반복한다.

![image](https://github.com/user-attachments/assets/a3604e24-3289-4a37-89b9-e55e57de82bf)

### 선택 정렬 단점
- 시간복잡도가 **O(n²)**으로 비효율적
    - 데이터가 많을 경우 성능이 좋지않음.
- 안정 정렬이 아니라서 동일한 값의 순서가 변경 될 수 있다. 


### 선택 정렬 장점
- 간단하며 직관적인 구조
- 데이터 이동이 적어 쓰기 연산 비용이 낮다.


### 선택 정렬 알고리즘 구현 코드 

```
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
  max_index = i # 가장 작은 원소의 인덱스
  for j in range(i+1, len(array)):
    if array[min_index] > array[j]:
      min_index = j
  array[i], array[min_index] = array[min_index], array[i]    # 스와프

print(array)
```

## 삽입 정렬
- 정렬되지 않은 데이터를 하나씩 가져와 이미 정렬된 배열의 적절한 위치에 삽입하는 방식으로 동작하는 알고리즘으로 데이터를 하나씩 확인하며 특정한 데이터를 적절한 위치에 삽입한다는 의미에서 삽입 정렬이라고 부른다. 
    - 특정한 데이터가 적절한 위치에 들어가기 이전에 그 앞의 데이터는 이미 정렬 되어있다고 가정한다.
- 간단한 구현과 적은 데이터에서는 높은 성능을 보이는 정렬 방식이다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만 **선택 정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘**이다. 
    - 필요할때만 위치를 바꾸기때문에 **데이터가 거의 정렬 되어있을때** 훨씬 효과적이다.
- 시간복잡도는 **O(n²)**으로 선택 정렬과 흡사한 시간이 소요되지만, 현재 리스트의 데이터가 거의 정렬 되어있는 상태라면 매우 빠르게 동작한다.
    - 최선의 경우 O(N)의 시간복잡도를 가진다.
    - 따라서 거의 정렬 되어있는 상태라면 퀵 정렬 등 여타 알고리즘을 이용하는 것보다 삽입 정렬을 사용하는게 좋다.

### 삽입 정렬 시간복잡도
- 최선의 경우: O(n) (데이터가 이미 정렬되어 있는 경우)
- 평균적인 경우: O(n²)
- 최악의 경우: O(n²) (데이터가 역순으로 정렬된 경우)

### 삽입 정렬 단점
- 데이터 크기가 커질 수록 성능이 저하되므로 소규모 데이터에 적합하다.
- 시간복잡도가 **O(n²)**으로 비효율적이나, 정렬되어있는 데이터의 경우에는 O(N)으로 빠르다.
    - 따라서 대규모 데이터에 적합하지않다.

### 삽입 정렬 장점
- 구현이 간단하고 이해하기 쉬움
- 데이터가 거의 정렬 되어 있는 경우 빠르다.
- 안정 정렬로 동일한 값의 순서가 유지된다. 

### 삽입 정렬 동작 방식
- 배열의 두 번째 요소부터 시작하여 해당 요소를 정렬된 부분에 삽입한다.
- 이전 요소들과 비교하며 적절한 위치를 찾는다.
- 모든 요소가 정렬될 때까지 반복한다.

```
정렬할 배열: [5, 3, 8, 4, 2]

첫 번째 단계:
두 번째 요소 3을 정렬된 부분 [5]에 삽입합니다.
3은 5보다 작으므로 앞에 삽입합니다.
결과: [3, 5, 8, 4, 2]

두 번째 단계:
세 번째 요소 8을 정렬된 부분 [3, 5]에 삽입합니다.
8은 이미 가장 크므로 그대로 둡니다.
결과: [3, 5, 8, 4, 2]

세 번째 단계:
네 번째 요소 4를 정렬된 부분 [3, 5, 8]에 삽입합니다.
4는 5와 8 사이에 삽입됩니다.
결과: [3, 4, 5, 8, 2]

네 번째 단계:
다섯 번째 요소 2를 정렬된 부분 [3, 4, 5, 8]에 삽입합니다.
2는 가장 앞에 삽입됩니다.
결과: [2, 3, 4, 5, 8]

최종 정렬 결과: [2, 3, 4, 5, 8]
```


### 삽입 정렬 구현 코드 
```
# 삽입 정렬
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
  for j in range(i, 0, -1):    # 인덱스 i부터 1까지 감소하며 반복하는 문법
    if array[j] < array[j-1]:    # 한 칸씩 왼쪽으로 이동
      array[j], array[j-1] = array[j-1], array[j]
    else:    # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
      break
```

## 퀵 정렬 

- 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘으로 분할 정복(Divide and Conquer)기법을 활용한 정렬 알고리즘입니다. 기준이 되는 피벗(Pivot)을 설정하고, 이를 기준으로 작은 값과 큰 값을 분리한 뒤 재귀적으로 정렬한다. 평균적으로 매우 빠르며, 효율적인 정렬 알고리즘 중 하나다.
    - 퀵 정렬과 비교할 만큼 빠른 알고리즘으로 '병합 정렬' 알고리즘이 있다.
- 퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다. 퀵 정렬에서는 피벗(Pivot)이 사용되는데 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 피벗이라고 표현한다. 
- 피벗을 설정하고 리스트를 분할하는 방법에 따라 여러 가지 방식으로 퀵 정렬이 구분되는데, 가장 대표적인 분할 방식으로는 호어 분할(Hoare Partition) 방식이 있다. 호어 분할은 리스트에서 첫 번째 데이터를 피벗으로 정한다.
- 퀵 정렬의 평균시간 복잡도는 **O(NlogN)**이고, 최악의 경우 시간 복잡도가 **O(n²)**이다.
    - 데이터가 무작위로 입력 되는 퀵 정렬은 빠르게 동작할 확률이 높다. 하지만 배열의 가장 왼쪽 데이터를 피벗으로 삼을때, '이미 데이터가 정렬되어 있는 경우'에는 매우 느리게 동작한다. 
    - 그렇기 때문에 피벗 선택이 중요하다. 최적의 성능을 위해 중앙값을 선택하거나 랜덤 피벗 방식을 사용하는 것이 유리하다.
    - 최악의 경우를 방지하기위해 입력 데이터를 사전 처리 할 수도 있다.
    - 파이썬의 퀵 정렬을 기반으로 작성된 기본 정렬 라이브러리를 이용하면 추가적인 로직을 더해줘서 O(NlogN)을 보장해주기 때문에 걱정하지 않아도 된다.

### 퀵 정렬 시간복잡도 
- 최선의 경우: O(n log n) (피벗이 배열을 균등하게 나눌 때)
- 평균적인 경우: O(n log n)
- 최악의 경우: O(n²) (피벗이 배열의 최댓값 또는 최솟값일 때)


### 퀵 정렬 단점
- 최악의 경우 시간 복잡도가 O(n²).
- 재귀 호출이 많아 stackOverFlow 가능성이 있음.

### 퀵 정렬 장점
- 평균 시간 복잡도가 O(n log n)으로 빠름.
- 추가 메모리 사용이 적음 (인플레이스 정렬 가능).


### 퀵 정렬 동작 흐름
- 피벗을 선택한다.
- 피벗을 기준으로 배열을 나누어, 피벗보다 작은 요소는 왼쪽, 큰 요소는 오른쪽으로 이동시킨다.
- 왼쪽과 오른쪽 부분 배열에 대해 재귀적으로 정렬을 수행한다.
- 모든 재귀 호출이 끝나면 정렬이 완료된다.

```
정렬할 배열: [10, 80, 30, 90, 40, 50, 70]

피벗은 항상 배열의 마지막 원소로 선택.

첫 번째 분할:
    - 피벗: 70
    - 배열 분할: [10, 30, 40, 50] (작음) + [70] (피벗) + [80, 90] (큼)

왼쪽 부분 배열 [10, 30, 40, 50] 정렬:
    - 피벗: 50
    - 분할: [10, 30, 40] + [50]

오른쪽 부분 배열 [80, 90] 정렬:
    - 피벗: 90
    - 분할: [80] + [90]

정렬 완료:
    - 병합: [10, 30, 40, 50, 70, 80, 90]
```

![image](https://github.com/user-attachments/assets/8bef710c-53b9-4669-9954-383f7cfa7f9c)


### 퀵 정렬 구현 코드 

```
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
  if start >= end:    # 원소가 1개인 경우 종료
    return
  pivot = start    # 피벗은 첫 번째 원소
  left = start + 1
  right = end
  while left <= right:
    # 피벗보다 큰 데이터를 찾을 때까지 반복
    while left <= end and array[left] <= array[pivot]:
      left += 1
    # 피벗보다 작은 데이터를 찾을 때까지 반복
    while right > start and array[right] >= array[pivot]:
      right -= 1
    if left > right:    # 엇갈렸다면 작은 데이터와 피벗을 교체
      array[right], array[pivot] = array[pivot], array[right]
    else:    # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
      array[left], array[right] = array[right], array[left]
  # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
  quick_sort(array, start, right - 1)
  quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
```


## 계수 정렬
- '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때'만 사용할 수 있지만 매우 빠른 정렬 알고리즘.
    - 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다. 
    - 계수 정렬이 이러한 특징을 가지는 이유는, 계수 정렬을 이용할 때는 '모든 범위를 담을 수 있는 크기의 리스트(배열)을 선언'해야 하기 때문이다.
- 비교 기반이 아닌 정렬 알고리즘으로, 정수 또는 정수로 표현 가능한 데이터의 빈도를 기반으로 정렬한다. 값의 크기가 제한된 경우 매우 효율적이며, 주로 숫자 범위가 제한적이고 데이터가 중복이 많은 경우에 사용된다.
    - 계수 정렬은 직접 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식(비교 기반의 정렬 알고리즘)이 아니다. 계수 정렬은 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.
- 계수 정렬은 정수 또는 정수로 표현가능한 데이터에만 사용가능하다.
- 데이터의 최대 값이 너무 클 경우 공간 복잡도가 증가한다.


### 계수 정렬 시간복잡도
- 시간 복잡도: O(n + k)
    - n: 데이터의 개수
    - k: 데이터 값의 범위
- 공간 복잡도: O(n + k)


### 계수 정렬 단점
- 매우 빠른 성능 (O(n + k))을 제공.
- 데이터의 크기와 개수가 적당하면 효율적임.


### 게수 정렬 장점
- 데이터 범위가 크면 비효율적.
- 비교 기반 정렬 알고리즘이 아니기 때문에 범용성이 떨어짐.


### 게수 정렬 동작 방식
- 정렬할 데이터의 범위를 파악하여 해당 범위의 크기만큼의 카운팅 배열을 생성한다.
- 데이터의 각 값을 인덱스로 하여 카운팅 배열에 빈도를 저장한다.
- 카운팅 배열을 누적 합으로 변환하여 정렬된 위치를 결정한다.
- 원본 배열을 순회하며 데이터를 정렬된 위치에 삽입한다.

```
정렬할 배열: [4, 2, 2, 8, 3, 3, 1]

1. 카운팅 배열 생성:
    - 데이터의 최대값 8을 기준으로 크기 9의 카운팅 배열 생성(데이터 크기 범위가 [0,8]이니까) : [0, 0, 0, 0, 0, 0, 0, 0, 0]
    - 각 데이터를 카운팅: [0, 1, 2, 2, 1, 0, 0, 0, 1]
    - 1이 1개, 2가 2개, 3이 2개, 4가 1개, 5는 없음, 6도 없음, 7도 없음, 8은 1개

. 누적 합 계산:
    - 카운팅 배열을 누적 합으로 변환: [0, 1, 3, 5, 6, 6, 6, 6, 7]

3. 정렬된 배열 생성:
    - 원본 배열을 역순으로 순회하며 데이터를 정렬된 위치에 삽입:
        1 → 위치 0 → [1, _, _, _, _, _, _]
        3 → 위치 4 → [1, _, _, _, 3, _, _]
        3 → 위치 3 → [1, _, _, 3, 3, _, _]
        8 → 위치 6 → [1, _, _, 3, 3, _, 8]
        2 → 위치 2 → [1, _, 2, 3, 3, _, 8]
        2 → 위치 1 → [1, 2, 2, 3, 3, _, 8]
        4 → 위치 5 → [1, 2, 2, 3, 3, 4, 8]

4. 정렬 완료:
    - 최종 배열: [1, 2, 2, 3, 3, 4, 8]
```


### 계수 정렬 구현 코드 
```
# 계수 정렬
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
  count[array[i]] += 1    # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)):    # 리스트에 기록된 정렬 정보 확인
  for j in range(count[i]):
    print(i, end=' ')    # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
```
- 모든 데이터가 양의 정수인 상황에서 데이터의 개수를 N, 데이터 중 최댓값의 크기를 K라고 할 때, 계수 정렬의 시간 복잡도는 O(N+K)이다.
- 따라서 데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 작동한다. 사실상 현존하는 정렬 알고리즘 중에서 기수 정렬(Radix Sort)과 더불어 가장 빠르다고 볼 수 있다.


## 병합 정렬
- 분할 정복(Divide and Conquer)기법을 이용한 정렬 알고리즘으로, 리스트를 반으로 나누고 각각을 재귀적으로 정렬한 후 병합하여 정렬된 리스트를 만드는 방식이다. 안정 정렬에 속하며, 대규모 데이터에서 특히 효율적이다.
- 안정 정렬이며 퀵 정렬은 입력값에 따라 버블 정렬만큼이나 느려질 수 있어 실무에서는 병합 정렬이 여전히 활발히 쓰인다.

### 병합 정렬 시간복잡도
- 최선의 경우: O(n log n)
- 평균적인 경우: O(n log n)
- 최악의 경우: O(n log n)


### 병합 정렬 단점
- 추가적인 메모리 공간이 필요하다.
    - 재귀 호출이 많아질 수 있으므로, 스택 오버플로우에 주의해야한다.
    - 메모리 사용량이 많아질 수 있으므로, 제한된 환경에서는 적합하지 않을 수 있습니다.
- 구현이 다소 복잡하다.

### 병합 정렬 장점
- 시간 복잡도가 안정적: O(n log n).
- 안정 정렬로, 동일한 값의 순서가 유지됨.
- 대규모 데이터 정렬에 적합.


### 병합 정렬 동작 방식
- 배열을 두 부분으로 나눈다.
- 각 부분을 재귀적으로 병합 정렬한다.
- 두 정렬된 부분을 하나로 병합한다.

```
정렬할 배열: [38, 27, 43, 3, 9, 82, 10]

1. 배열 분할:
    [38, 27, 43, 3]와 [9, 82, 10]으로 나눕니다.

2. 왼쪽 부분 [38, 27, 43, 3] 정렬:
    다시 [38, 27]과 [43, 3]으로 나눕니다.
    [38, 27]은 [27, 38]로 정렬.
    [43, 3]은 [3, 43]로 정렬.
    두 부분을 병합: [27, 38, 3, 43] → [3, 27, 38, 43].

4. 오른쪽 부분 [9, 82, 10] 정렬:
    [9]과 [82, 10]으로 나눕니다.
    [82, 10]은 [10, 82]로 정렬.
    두 부분을 병합: [9, 10, 82].

5. 최종 병합:
    왼쪽 [3, 27, 38, 43]과 오른쪽 [9, 10, 82] 병합.
    결과: [3, 9, 10, 27, 38, 43, 82].

```


## 버블 정렬
- 버블 정렬은 인접한 두 요소를 비교하며 정렬하는 가장 기본적인 정렬 알고리즘이다. 실무와는 거리가 먼 알고리즘.
- 간단한 구조와 구현 덕분에 학습 목적으로 자주 사용되지만, 효율성 면에서는 다른 정렬 알고리즘에 비해 성능이 떨어진다.
- 배열 전체를 n번 반복해야하기때문에 시간 복잡도는 항상 **O(n²)**이다.

### 버블 정렬 동작 방식
- 첫 번째 요소와 두 번째 요소를 비교하여 크기를 기준으로 위치를 바꾼다.
- 두 번째 요소와 세 번째 요소를 비교하여 동일한 작업을 수행한다.
- 마지막 요소까지 이 작업을 반복한다. 이 과정을 한 번 완료하면 가장 큰 값이 맨 끝에 위치하게 된다.
- 위 과정을 반복하며 정렬되지 않은 나머지 요소를 계속 비교해 정렬을 완성한다.

```
정렬할 배열: [5, 3, 8, 4, 2], 오름차순으로 정렬하기

첫 번째 패스 (Pass 1):
비교: 5와 3 → 3과 5로 스왑 → [3, 5, 8, 4, 2]
비교: 5와 8 → 스왑 없음 → [3, 5, 8, 4, 2]
비교: 8과 4 → 4와 8로 스왑 → [3, 5, 4, 8, 2]
비교: 8과 2 → 2와 8로 스왑 → [3, 5, 4, 2, 8]
맨 끝 위치에 가장 큰 원소인 8이 위치하게 됨.

두 번째 패스 (Pass 2):
비교: 3과 5 → 스왑 없음 → [3, 5, 4, 2, 8]
비교: 5와 4 → 4와 5로 스왑 → [3, 4, 5, 2, 8]
비교: 5과 2 → 2와 5로 스왑 → [3, 4, 2, 5, 8]
끝에서 두번째 위치에 두번째로 큰 원소인 5가 위치하게 됨.

세 번째 패스 (Pass 3):
비교: 3과 4 → 스왑 없음 → [3, 4, 2, 5, 8]
비교: 4와 2 → 2와 4로 스왑 → [3, 2, 4, 5, 8]

네 번째 패스 (Pass 4):
비교: 3과 2 → 2와 3로 스왑 → [2, 3, 4, 5, 8]
최종 정렬 결과: [2, 3, 4, 5, 8]

```

### 버블 정렬 장점
- 간단하고 이해하기 쉬운 구조
- 코드 작성이 쉬움.

### 버블 정렬 단점
- 데이터가 많을 수록 **성능이 급격히 저하됨**
- 다른 효율적인 정렬 알고리즘에 비해 사용빈도가 적음.

### 구현 코드 
```
## Java
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {5, 3, 8, 4, 2};
        
        bubbleSort(arr);
        
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

## Python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

arr = [5, 3, 8, 4, 2]
bubble_sort(arr)
print(arr)

```

## 힙 정렬
- 힙(Heap) 자료구조를 기반으로 한 정렬 알고리즘으로, 완전 이진 트리를 활용한다. 
    - 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법으로서, 내림차순 정렬을 위해서는 최소 힙을 구성하고 오름차순 정렬을 위해서는 최대 힙을 구성하면 된다. 
- 힙 생성 과정에서의 시간 복잡도를 고려해야하며, 배열을 최대 힙으로 변환할 때 불필요한 연산을 최소화하도록 코드를 최적화해야 한다.

### 힙 정렬 시간복잡도
    - 최선의 경우: O(n log n)
    - 평균적인 경우: O(n log n)
    - 최악의 경우: O(n log n)

### 힙 정렬 단점
- 구현이 상대적으로 복잡함.
- 데이터가 거의 정렬된 경우 다른 알고리즘에 비해 성능이 떨어질 수 있음.

### 힙 정렬 장점
- 시간 복잡도가 항상 O(n log n)으로 안정적임.
- 추가 메모리 사용이 적음 (인플레이스 정렬).

### 힙 정렬 동작 방식
- 주어진 배열을 최대 힙(Max Heap)으로 변환한다.
- 힙의 루트(최댓값)를 배열의 끝으로 이동하고, 힙 크기를 줄인 뒤 나머지 힙을 다시 최대 힙으로 조정한다.
- 위 과정을 반복하여 정렬을 완료한다.

```

정렬할 배열: [4, 10, 3, 5, 1]

1. 최대 힙 생성:
    초기 배열: [4, 10, 3, 5, 1]
    최대 힙 변환: [10, 5, 3, 4, 1]

2. 루트 요소를 정렬:
    루트 10을 배열 끝으로 이동: [1, 5, 3, 4, 10]
    나머지 힙을 최대 힙으로 조정: [5, 4, 3, 1, 10]

3. 과정 반복:
    루트 5 이동: [1, 4, 3, 5, 10]
    최대 힙 조정: [4, 1, 3, 5, 10]
    루트 4 이동: [1, 3, 4, 5, 10]
    최대 힙 조정: [3, 1, 4, 5, 10]

4. 정렬 완료:
    최종 배열: [1, 3, 4, 5, 10]

```



#### 참고 링크 
https://jeong-devlog.tistory.com/entry/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EC%9A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-feat%EC%A0%95%EB%A0%AC

https://dsc-sookmyung.tistory.com/503

https://best-coding.tistory.com/60#google_vignette

![퀵정렬 자세한 글](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)

https://best-coding.tistory.com/70#google_vignette