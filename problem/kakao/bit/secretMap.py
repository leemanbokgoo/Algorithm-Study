from typing import List
# ) 카카오 공채 비밀 지도
# 문제 설명 :  https://tech.kakao.com/posts/344

# 해당 문제는 이진수 연산을 통해 풀이해야하는 문제다.
# "지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다." -> 이부분은 OR 연산을 설명하고 있다.
# "암호화된 배열은 지도의 각 가로줄에서 벽 부분을 $1$, 공백 부분을 $0$으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다."
# -> 이진수라는 직접적인 힌트를 주고있으며 이진수로 변환한 후, 그 이진수가 나타내는 십진수 값으로 배열에 저장되어있다는 것을 알려준다. 즉, 이진수를 이용한 문제라는 것이다.
# 2^n이라는 숫자는 n자리를 벗어나기 때문에, n개의 비트로 표현할 수 있는 최대 숫자는 2^n에서 1이 된다. n개의 비토로 표현할 수 있는 가장 큰 십진수 값을 의미한다.
# 2^n - 1은 단순한 수학 공식이 아니라, 컴퓨터의 기본 단위인 비트(Bit)와 직접적으로 관련된 숫자이다.
# 따라서, 문제에서 2^n - 1이 나오거나, 혹은 2^n에 가까운 숫자 (예: 15, 31, 63, 255 등)가 등장하면, 출제자가 비트의 개수(n)를 기준으로 사고하게 만들려는 의도일 가능성이 높다.
# n : 비트의 개수(자릿수) 2^n : n비트로 표현 가능한 총 경우의 수 2^n-1 : n비트로 표현 가능한 최대 십진수
# 즉, 2n만큼의 경우의 수가 존재할 수 있고 그 경우의 수 중 가장 큰 값은 2^n-1이다.
# 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2^n - 1을 만족한다.
# -> 입력받은 정수 x를 무조건 n자리 이진수로 간주하고 zfill(n)과 같은 처리를 해도 안전하다는 확신을 가질 수 있다.
#    입력된 정수가 음수가 아님을 명확히 하여, 이진수 변환 시 복잡한 2의 보수 등의 처리를 할 필요가 없음을 알려준다.
#    이 문장은 이 문제가 비트 연산과 정해진 길이(n)의 이진수 변환에 초점을 맞춘 문제임을 개발자에게 최종적으로 확인시켜주는 역할한다.
#    길이가 n 이하이다 : 입력된 숫자 x가 n자리를 초과하는 이진수(2^n 이상)가 아님을 보장함.

# 2n은 이진수에서 $n$번째 자리까지의 모든 값을 채우고, 다음 자리로 넘어간 수이다. 예를 들어 4자리 이진수의 최대값은 1111(십진수 15)이다. 여기에 1을 더하면 10000이 됨으로 4자리 수를 초과한다.

# n : 지도의 한변의 크기 (정사각형 지도)
# arr1 : 첫 번째 지도의 정보를 담고 있는 n 길이의 정수 리스트.
# arr2 : 두 번째 지도의 정보를 담고 있는 n 길이의 정수 리스트.
# 두 지도의 정보를 OR 연산(|)으로 합친 후, 이진수 형태를 문자열 형태의 비밀 지도로 변환하여 반환하는 문제.
def solution(n : int, arr1 : List[int], arr2 :  List[int] ) ->  List[int]:

    # 비밀 지도(문자열 리스트)를 저장할 빈 리스트 maps를 초기화.
    maps = []

    # n 번 반복하여 두 배열 arr1와 arr2의 같은 인덱스에 있는 요소들을 하나씩 처리한다. 즉, 각 행의 지도를 만드느 ㄴ과정이다.
    for i in range(n):
        maps.append(
            # OR 연산 및 이진수 변환.
            # bin() : OR 연산의 결과를 이진수 문자열로 변환한다. 예를 들어 9|13은 10011가 되고 bin(11)은 0b1011이라는 문자열을 반환한다.
            # bint()함수의 결과로 나오는 접두사 0b를 제거하기위해 슬라이싱 [2:]를 사용
            bin( arr1[i] | arr2[i] )[2:]
            # 이진수 문자열의 길이가 n보다 짧을 경우 문자열 왼쪽에 '0'을 채워 길이를 n으로 만든다.
            # 예: '1011'을 n=5일 때 '01011'로 만드는 것으로 지도의 크기를 맞추는 과정임.
            .zfill(n)
            # 이진수 문자열을 최종 지도 형식으로 변환한다.
            # 1 은 벽임으로 #로 표현, 0은 공백임으로 ' ' 공백으로 바꾼다.
            .replace('1', "#")
            .replace('0', ' ')
        )

    return maps

if __name__ == "__main__":

    n1 = 5
    arr1_1 = [9, 20, 28, 18, 11]
    arr1_2 = [30, 1, 21, 17, 28]

    n2 = 6
    arr2_1 = [46, 33, 33 ,22, 31, 50]
    arr2_2 = [27 ,56, 19, 14, 14, 10]

    print(solution(n1, arr1_1, arr1_2))
    print('["#####","# # #", "### #", "# ##", "#####"]')

    print("=============================================")
    print(solution(n2, arr2_1, arr2_2))
    print('["######", "###  #", "##  ##", " ####  ", "  #####", "### # "]')

## 다른 버전의 정답들.

# https://velog.io/@kysung95/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-2018-KAKAO-BLIND-RECRUITMENT-%EB%B9%84%EB%B0%80%EC%A7%80%EB%8F%84
def solution2(n, arr1, arr2):
    answer = []

    for i in range(n):

        word = ""

        arr1_binary = bin(arr1[i])[2:].rjust(n, "0")
        arr2_binary = bin(arr2[i])[2:].rjust(n, "0")

        for j in range(n):
            # int(arr1_binary[j])와 int(arr2_binary[j])는 각각 두 이진수의 같은 위치에 있는 비트(0 또는 1)를 정수로 변환한다.
            # int(...) or int(...): Python에서 or 연산자는 불리언 로직을 따르며, 이 경우 두 정수 중 하나라도 1이면 결과는 1이 된다.
            # 비트 OR 연산의 결과와 동일하다.
            if str( int(arr1_binary[j]) or int(arr2_binary[j]) ) == "0":
                word += " "
            else:
                word += "#"

        answer.append(word)

    return answer

# https://velog.io/@soopy368/Python-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4
def solution3(n, arr1, arr2):
    answer = []

    for n1, n2 in list(zip(arr1, arr2)):
        bin_str = bin(n1 | n2)[2:].zfill(n)
        bin_str = bin_str.replace('1', '#')
        bin_str = bin_str.replace('0', ' ')
        answer.append(bin_str)

    return answer