from typing import List
# 카카오 공채) 프렌즈 4 블록
# 문제 설명 :  https://tech.kakao.com/posts/344

# 비즈니스를 구현해야하는 문제로 총 3단계 미즈니스 로직을 구현해야한다.
# 1) 일치 여부를 찾는것 2) 일치한 위치를 삭제 (풀이에서는 #으로 변환한다.) 3) 빈공간에 위에 있는 블록을 아래로 떨어뜨리는 처리.
    # 앞 뒤로 처리를 쉽게 하기위해 문자열을 문자 단위 리스트로 분리하여 중첩 리스트 표현, 빈공간에 대한 개수 카운팅을 추가하면 모든 구현을 완료할 수 있따.
def solution( m : int, n : int, board : List[str] ) -> int :

    # 문자열 리스트 형태로 변환
    # "CCAA" -> ['C', 'C', 'A', 'A'] 이런식으로 원소 하나하나(문자열 하나)마다 접근 가능하게 타입을 변경하는 것이다.
    board = [ list(x) for x in board ]

    matched = True

    # 더이상 지울 수 없는 2X2 블록이 없을 때까지(matched 리스트가 빌때까지) 전체 과정을 반복한다.
    while matched:
        matched = []

        # 1단계 ) 2x2 블록 찾기 및 마킹
        # 이중 for 루프는 보드의 모든 2x2 영역을 검사
        # m은 행(세로 길이), n은 열(가로 길이)이다. 즉, 모든 좌상단 좌표를 탐색한다.
        for i in range( m - 1):
            for j in range( n - 1):
                # board[i][j] == board[i][j + 1] == board[i + 1][j + 1] == board[i + 1][j] : 2x2 영역의 네 칸의 블록 종류가 모두 같고
                # != '#' : 그 블록이 이미 지워진 표시인 '#'가 아닐 경우
                if board[i][j] == board[i][j + 1] == board[i + 1][j + 1] == board[i + 1][j] != '#':
                    # 해당 2x2 블록의 좌상단 좌표 [i, j]를 matched 리스트에 추가한다.
                    # 여기서 가장 왼쪽 위(Left-Top)에 위치한 칸의 좌표를 좌상단 좌표라고 한다. 이게 기준점이 된다.
                    matched.append([i, j])

        # 2단계 ) 블록 제거 (#으로 표시)
        # 앞 단계에서 찾은 모든 2x2 블록의 네 칸을 동시에 지워진 블록 표시인 '#'으로 변경한다.
        for i, j in matched:
            # 여기서 주의해야할 점은 찾은 모든 블록을 동시에 처리해한다. 첫번째 for 루프에서 찾은 블록들만 지워야한다.
            # 지우는 과정에서 새로운 2x2 블록이 생겨도 다음 라운드에서 처리해야 함.
            board[i][j] = board[i][j + 1] = board[i + 1][ j + 1] = board[ i + 1][j] = '#'

        # 3단계 ) 블록 떨어뜨리기
        # 지워진 블록(#)위에 있던 블록들을 아래로 떨어뜨리는 과정이다.
        # for _ in range(m)은 블록이 여러 칸 떨어져야 하는 경우를 대비하여, 안쪽의 '한 칸 떨어뜨리기' 로직을 충분한 횟수만큼 반복한다.
        # 즉, for i in range( m - 1),  for j in range(n) 이중 for문은 블록 전체를 한번 순회하며 블록을 떨어뜨리는 반복문이고,
        # for _ in range(m)은 블록이 5번째 칸에서 1번쨰 칸으로 추락하는 케이스를 위해 블록의 높이만큼 반복문을 돌리며 블록을 이동시키는 것이다.
        # m-1 인 이유는 1단계와 다르게 맨 밑에 있는 블록은 이동할 필요가 없음으로 높이에서 -1 을 해서 높이-1만큼 순회하는 것이다.
        for _ in range(m):
            # 행을 순회한다. (위에서 아래로)
            for i in range( m - 1):
                # 검사 및 스왑 ( 열을 순회한다. 즉, 한칸 씩 이동한다.)
                for j in range(n):
                    # 아래칸이 #라면
                    if board[ i + 1 ][j] == '#' :
                        # board[i + 1][j] : 현재 검사하고 있는 블록의 바로 아래 칸
                        # board[i][j] : 현재 검사 중인 블록
                        # 현재 검사하고 있는 블록은 #으로 아래칸에다가 현재 검사하고 있는 블록 값을 주입
                        # 즉, 현재 검사하고 있는 블록을 아래로 한칸 이동 시키는 것.
                        board[ i + 1 ][j], board[i][j] = board[i][j], '#'

    # board의 모든 행을 순회하면서 (for x in board), 각 행에 포함된 지워진 블록의 개수 (x.count('#'))를 세어 총합을 구한다.
    # 제너레이터 표현식으로 #의 개수를 미리 리스트로 만들지 않고, 필요할 때마다 하나씩 차례로 생성해주는 "제너레이터 객체"를 만든다.
    # sum()은 인자로 반복 가능한 객체(Iterable)를 받으면 그 객체의 모든 원소를 합산한다.
    return sum( x.count('#') for x in board)