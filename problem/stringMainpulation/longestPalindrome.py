# 가장 긴 펠림드롬 부분 문자열을 출력하라.

# 투 포인터가 중앙을 중심으로 확장하는 형태의 풀이 -> 두 개의 포인터(인덱스)가 문자열의 가운데 지점에서 시작해서 바깥쪽으로 한 칸씩 움직이며 검사하는 방식을 말함.
# 홀수 문자열은 중앙 위치에 문자가 존재하고 짝수 문자열은 중앙 위치에 문자가 존재하지않는다. 이 두가지 경우를 모두 처리하기 위해 투포인터를 사용한다.
# 투포인터를 중심에 위치시킨 다음, while 루프를 사용해 두 포인터가 가리키는 문자가 같은 지 확인하면서 좌우로 한 칸씩 확장해나간다.
# 여기서 포인터란 문자열의 특정 위치를 가리키는 인덱스이고 투 포인터란 두개의 포인터를 사용한다는 뜻이다.
# 오른쪽 포인터, 왼쪽 포인터를 사용하며 오른쪽 포인터는 문자열의 오른쪽(끝)을 가르키고 왼쪽 포인터는 문자열의 왼쪽(앞)을 가르킨다.
def longestPalindrome(s: str) -> str:

    # 투 포인터 확장 하는 함수
    # 확장한다는 의미는 왼쪽 포인터는 왼쪽(앞)으로 오른쪽 포인터는 오른쪽(뒤)로 한칸씩 움직인다는 뜻.
    def expand(left: int, right: int) -> str:
        #  left >= 0 : 왼쪽 포인터가 문자열의 시작점을 벗어났는지 확인
        #  right < len(s) : 오른쪽 포인터가 문자열의 끝을 벗어나지 않았는지
        # s[left] == s[right] : 왼쪽 포인터가 가리키는 문자와 오른쪽 포인터가 가리키는 문자가 같은지 확인.
        # 만약 문자가 서로 같다면, 이 부분은 회문의 일부이므로 더 긴 회문을 찾기 위해 포인터를 한 칸씩 바깥으로 확장
        # s[left]와 s[right]의 값이 달라지면 현재 검사 중인 부분은 더 이상 회문이 아니라는 뜻
        while left >= 0 and right < len(s) and s[left] == s[right]:
            # 왼쪽 포인터를 왼쪽(앞)쪽으로 이동
            left -= 1
            # 오른쪽 포인터를 오른쪽(뒤)쪽으로 이동
            right += 1
        # left + 1부터 시작하는 이유는 while문이 멈추기 위해서는 두 포인터가 가리키는 값이 회문이 아닌 문자열이여야한다.
        # 그래서 while문이 멈췄을때는, 두 포인터는 회문이 아닌 문자열을 가리키고 있고 여기서 회문을 찾으려면 그 전 문자열을 출력해야한다. (= while문이 동작했다면 회문이기때문)
        # 그래서 left는 -1을 하지만 파이썬 슬라이싱 기법의 표현식은 문자열의 끝을 지정하는 경우, 해당 인덱스를 포함하지않기때문에 right는 그대로 쓴다.
        # 만약 두번째 문자열을 끝으로 자르고 싶다면 3이라고 입력해야하는 것임.
        return s[left + 1:right]

    # 문자열 길이가 1이거나 전체가 회문이면 그대로 리턴
    # s == s[::-1] 에서 s[::-1] 은 문자열을 뒤집는 다는 뜻, 문자열을 뒤집어도 똑같다면 회문이다.
    if len(s) < 2 or s == s[::-1]:
        return s

    result = ''

    # s문자열의 길이 만큼의 반복문
    # max는 파이썬의 내장 함수로, 여러 값 중에서 가장 큰 값을 찾아 반환한다.
    # expand 함수가 반환하는 두 회문(expand(i, i+1)과 expand(i, i+2)) 중 더 긴 회문을 찾기 위해 사용됨.

    for i in range(len(s) - 1):
        # 지금 result,  expand(i, i + 1), expand(i, i + 2) 개 중 가장 길이 긴 회문을 result에 저장한다.
        result = max(result,
                     # 짝수 길이 회문은 가운데 문자가 없기때문에 +1해서 서로 이웃한 두 문자를 가리킴
                     expand(i, i + 1),
                     # 홀수 길이 회문은 가운데에 문자가 존재하기때문에 두 문자 가운데 있는 문자(i + 1)를 중심으로 두고, 양쪽으로 확장하면서 대칭을 검사
                     expand(i, i + 2),
                     key=len) # key=len은 max 함수에 사용되는 정렬 기준

    return result


if __name__ == "__main__":
    input1 = "babad"
    input2 = "cbbd"

    print(longestPalindrome(input1))  # 출력: "bab" 또는 "aba"
    print(longestPalindrome(input2))  # 출력: "bb"
