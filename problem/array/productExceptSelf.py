from typing import List

# 배열을 입력받아 output[i]가 자신을 제외한 나머지 모든 요소의 곱셈 결과가 되도록 출력하라.
# @@ 주의 : 나눗셈을 하지않고 O(n)에 풀이하라.
# O(n)에 풀이하라는 말은 O(n^2)의 시간복잡도를 가지는 >>중첩 반복문(이중 for문)<<대신, 배열을 한 번 또는 두 번만 순회하여 효율적으로 문제를 해결하라는 의미
# 위의 주의사항 때문에 미리 전체 곱셈 값을 구해놓고 각 항목별로 자기자신을 나눠서 풀이하는 방법은 안된다.
# 자기 자신을 제외하고 왼쪽의 곱셈 결과와 오른쪽의 곱셈 결과를 곱해야한다.

# [ 풀이 1 ] 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈.
def productExceptSelf(nums  :List[int]) -> List[int]:
    out = []
    # 곱셈 결과를 누적할 변수 p를 1로 초기화. (곱셈의 항등원은 1이므로)
    # 항등원 : 특정 연산에서 어떤 수와 연산해도 그 수가 변하지 않게 하는 수. 덧셈의 항등원은 0
    # 항등원으로 변수를 초기화하는 이유는 가장 왼쪽 인덱스(예: nums[0])의 경우 왼쪽 값이 없음,
    # 이럴때 곱셈 결과를 계산하려면 아무런 영향을 주지않는 값이 필요하기때문에 항등원의 값을 세팅해두는 것.
    p = 1

    # 배열을 왼쪽에서 오른쪽으로 순회하면서 각 인덱스의 왼쪽에 있는 요소들의 곱을 구한다.(오른쪽에 있는 요소는 X)
    for i in range(0, len(nums)):
        # i 인덱스의 왼쪽에 있는 요소들의 곱을 out에 추가.
        # 초기에는 초기값인 1이 저장될 것이고 반복문이 돌면서 차차 왼쪽에 있는 요소들의 곱이 추가 되기 시작함.
        out.append(p)

        # 기존의 p값에 현재 값을 곱해서 값을 누적시킨다.
        p = p * nums[i]

    # 여기까지 코드가 작동하면 해당 nums[i]을 기준으로, 왼쪽에 있는 값들은 전부 곱한 상태가 된다.
    # 즉 out 리스트는 [1, 1, 2, 6] 로 out[3]은 nums[3]의 왼쪽에 있는 요소들의 곱 (nums[0] * nums[1] * nums[2])이 되는 것.
    # 다시 곱셈의 항등원으로 초기화
    p = 1

    # 이제 현재 인덱스[i]의 오른쪽에 있는 모든 요소들의 곱을 구한다.
    # 마지막 인덱스()len(nums) -1부터 0번째 인덱스까지 역순으로 순회합니다. (-1은 range 함수의 종료 값이므로 0까지 포함)
    for i in range(len(nums) -1,  -1, -1):
        # out[i] : 위에서 구한 왼쪽 곱셈 결과
        # p : 현재 인덱스 i의 오른쪽 곱셈 결과
        # 이 둘을 곱함으로써 자신을 제외한 모든 요소의 곱이 완성
        #  nums[3]은 오른쪽에 아무것도 없기때문에 p = 1인데, out[3] = out[3] * 1 = 6 * 1 = 6 결과가 나오는 것.
        out[i] = out[i] * p

        # 다음 nums[i]의 계산을 위해 위해 현재 nums[i]를 p에 곱해 누적합니다. 이렇게 하면 다음 인덱스의 오른쪽 곱셈 값에 현재 nums[i]가 포함됩니다.
        p = p * nums[i]

    return out

if __name__ == "__main__":

    nums = [ 1,2,3,4 ]
    # 출력 [ 24, 12, 8, 6 ]
    print(f"productExceptSelf : {productExceptSelf(nums)}")

