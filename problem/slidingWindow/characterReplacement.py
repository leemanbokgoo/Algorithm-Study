import collections
# 77 ) 가장 긴 반복 문자 대체
# 대문자로 구성된 문자열 s가 주어졌을때 k번 만큼의 변경으로 만들 수 있는 연속으로 반복된 문자열의 가장 긴 길이를 출력하라.

# [ 풀이 1 ] 투 포인터, 슬라이딩 윈도우, Counter를 모두 이용
# 오른쪽 포인터가 계속 우측으로 이동한다는 점에서 슬라이딩 윈도우 문제이지만 왼쪽 포인터를 계속 좁혀서 범위를 조절해나간다는 점에서 투포인터와 결합된 문제라고 볼수있다.
# 오른쪽 포인터에서 왼쪽 포인터 위치를 뺀 다음, 윈도우 내 출현 빈도가 가장 높은 문자의 수를 뺸 값이 K와 같을 수 있는 수 중 가장 최대의 값이라고 정의한다.
# 최대 길이를 찾는 문제이므로 right는 클 수록 좋고 left는 작을 수록 좋다.
# AAABB라는 문자열이 주어질때 A->B는 3번 B->A는 2번으로 B->A로 바꾸는 편이 연산 횟수 K를 최소화하는 방법이다.
# 마찬가지로 오른쪽 포인터 5에서 왼쪽 포인터 0을 뺀 다음 출현빈도가 가장 높은 문자인 A의 개수 3개를 뺀 값 즉, 5-0-3이 연산 횟수 k가 되며 이 값은 2가 된다.
def characterReplacement( s : str, k : int) -> int :

    left = right = 0 # 포인터 셋팅
    counts = collections.Counter() # counter 빈 객체 생성

    # 왼쪽 포인터와 오른쪽 포인터를 0으로 지정하고 오른쪽 포인터 right는 계속 우측으로 한칸씩 이동한다.
    for right in range(1, len(s) + 1):
        # counter 변수에 현재 오른쪽 포인터가 가리키는 문자열을 카운팅한다.
        # right -1 하는 이유는 윈도우 전체를 카운팅할때는 +1할 필요가 없지만(파이썬은 슬라이싱 시 end 인자는 포힘되지않기때문) 새로 들어온 문자 하나만 카운팅하는 경우에는 -1을 해야한다.
        # 파이썬 문법상의 규칙임으로 그냥 외우면 된다.
        counts[s[right - 1]] += 1

        # 가장 많이 카운팅된 문자의 갯수를 들고오게 된다.
        # ex) ({ A:3, B:2})가 counters에 들어있다. 여기서 most_common(1)을 하면 [(A:3), ( B:2)]
        # counts.most_common(1)은 (A:3)이 되고  counts.most_common(1)[0]은 3이 출력된다.
        max_char_n = counts.most_common(1)[0][1]

        # 오른쪽 포인터는 계속 커지기때문에 최댓값을 추출하기 위해서는 왼쪽 포인터는 0에서 움직이지않는게 좋다.
        # 그러나 k 연산 횟수를 넘어서면 left 포인터를 -1 하여 오른쪽으로 한칸 이동해야한다.
        # right - left - max_char_n :  right - left 을 하면 현재 윈도우의 크기이다. 여기서 max_char_n(현재 윈도우에서 가장 많은 문자열의 갯수)를 빼면 변경해야할 문자열의 갯수가 된다.
        # 이 갯수가 k보다 크면 left를 줄여서 윈도우를 줄여야한다.
        if right - left - max_char_n > k:
            # left 포인터를 한칸 오른쪽으로 이동 할 것이기떄문에 현재 left 포인터가 가리키는 문자열의 카운팅 값을 -1 한다.
            counts[s[left]] -= 1
            # left 포인터 이동
            left += 1

    # max_len = max(right - left, max_len)
    # 오른쪽 포인터에서 왼쪽 포인터를 뺸 값이 가장 긴 길이가 되는 값이다. 그러나 이 부분은 생략이 가능하다.
    # 한번 최댓값이 생성된 상태에서는 오른쪽 포인터가 한칸 이동하면 왼쪽 포인터도 따라서 이동하게 되면서 max_len 값은 바뀌지않는다.
    # 여기서 왜 그렇게 되냐면 최댓값이 생성되고 난 후에 right가 이동하면  if right - left - max_char_n > k:의 조건이 참이 아니게 될 확률이 높다.
    # 그럼 if문의 안의 로직을 타며 left를 -1 하게되고 그럼 두 포인터가 같이 한칸씩 이동하며 윈도우는 계속 같은 크기를 유지하게 되는 것이다.
    # 따라서 최댓값을 구하는 부분은 생략할 수 있다.
    return right - left

if __name__ == "__main__":

    s = "AAABBC"
    k = 2

    # B를 A로 각각 2번 변경하면 길이 5인 AAAAA를 만들 수 있다.
    print("[ 풀이 1 ] 투 포인터, 슬라이딩 윈도우, Counter 이용 : ",characterReplacement(s,k), " | 기대 출력값 5 " )
