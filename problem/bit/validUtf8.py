from typing import List
# 73 ) utf-8 검증
# 입력값이 utf-8 문자열이 맞는지 검증하라

# [ 풀이 1 ] 첫 바이트를 기준으로 한 판별
# UTF-8은 1바이트부터 4바이트까지의 가변 길이 문자 인코딩인데, 각 문자의 첫 바이트에 그 문자가 몇 바이트로 구성되었는지에 대한 표식이 심어져있다.
# 즉, 첫번째 바이트만 보면, 그 바이트가 어떤 이진 패턴으로 시작하는지에 따라 문자의 총 길이를 즉시 알수있다.
# 후속 바이트의 경우 10으로 시작하며 문자의 일부임을 나타낸다. (ex 10xxxxxx)
def vaildUtf8( data : List[int]) -> bool:

    # 바이트 문자가 맞는지 확인하는 함수
    # size를 받아와 해당 사이즈만큼 바이트가 10으로 시작하는 지를 판별한다.
    # 만약 3바이트 문자라고 판별했다면 나머지 2 바이트가 모두 10으로 시작하는 지 판별한다.
    def check(size):

        # 현재 바이트(start)의 다음 바이트 부터 size개의 바이트를 순회한다.
        for i in range( start + 1, start + size + 1):

            # if i >= len(data): 데이터의 끝을 벗어났는지 확인. 즉, 선행 바이트는 N바이트 문자라고 선언했는데, 데이터 배열에 N-1개의 후속 바이트가 부족하면 유효하지 않다.
            # (data[i] >> 6) != 0b10 : UTF-8에서 모든 후속 바이트는 이진수로 반드시 10으로 시작해야한다.
            #                           data[i] >> 6은 해당 바이트를 오른쪽으로 6비트 시프트하여 가장 앞 2비트만 남기는 연산
            #                           남은 2비트가 0b10 (십진수 2)이 아니라면, 이 바이트는 유효한 후속 바이트가 아니다.
            if i >= len(data) or (data[i] >> 6) != 0b10:
                return False
        return True

    start = 0

    # while start < len(data) : UTF-8 문자의 길이에 따라 start를 건너뛰며 이동하기 위한 조건.
    #                          현재 처리한 UTF-8 문자의 길이만큼 건너뛸 수 있다.
    while start < len(data):
        # first : 첫 바이트.
        first = data[start]

        # 첫바이트 변수가 0으로 시작한다면 1바이트 문자. 110으로 시작한다면 2바이트 문자, 1110으로 시작한다면 3바이트 문자, 11110으로 시작한다면 4바이트 문자다.
        # 아래의 조건문은 해당 문자가 3바이트 문자인지 확인하는 것이다. 이 문자는 선행 바이트 1개와 후속바이트 2개로 구성되어있다.
        # first >> 3 : first에 저장된 이진수(비트 패턴)를 오른쪽으로 3칸 이동한다. 만약 11110000가 있다면 0001110으로 옮기는 것.
        # check(3) : 뒤따르는 3개의 바이트가 유효한 후속 바이트(10xxxxxx)인지 검사
        if (first >> 3) == 0b11110 and check(3):
            # if문을 통과했다면 현재 문자를 구성하는 총 3개의 바이트(data[0], data[1], data[2])를 모두 검사했는데 문제가 없었다는 뜻이다.
            # 그럼 다음 문자의 시작점인 data[3]부터 검사를 시작해야한다.
            start += 4

        elif (first >> 4) == 0b1110 and check(2):
            start += 3

        elif (first >> 5) == 0b110 and check(1):
            start += 2

        # UTF-8 인코딩에서 해당 바이트가 1바이트 문자 (ASCII)인지 아닌지 확인.
        # first 변수의 8개 비트를 오른쪽으로 7칸 이동시키는 연산으로 이 연산을 수행하면, 원래 바이트의 가장 왼쪽(최상위, MSB) 비트 하나만 남고, 나머지 7개의 비트는 모두 버려진다.
        # first >> 7한 문자가 0과 같다면, 원래 first 바이트의 가장 왼쪽 비트가 0이었다는 것을 의미한다.
        # UTF-8 인코딩 규칙에 따르면 1바이트 문자 (ASCII)는 항상 0으로 시작한다 (ex ) 0xxxxxxx). 0부터 127까지의 값을 의미한다.
        # 멀티 바이트 문자는 항상 1로 시작한다.
        elif (first >> 7) == 0:
            start += 1

        else :
            return False

    return True

if __name__ == "__main__":
    # 이값은 11000101 10000010 0000001로 표현되며 2바이트 문자 다음에 오는 1바이트 문자로 모두 2개며 정상.
    data = [197, 130, 1]

    # 이 값은 11101011 10001100 00000100로 표현되며 첫바이트의 첫 3비트가 모두 1이고 4번쨰 비트가 0이므로 3바이트 문자임을 뜻한다.
    # 다음 바이트도 10으로 시작하여 정상이지만 그 다음 바이트는 10으로 시작하지않으므로 비정상이다.
    data2 = [235, 140, 4]

    # 1 : 0 0 0 1
    # 4 : 0 1 0 1
    # 이기떄문에 다른건 2개다.
    print( vaildUtf8(data), "         |    기대 출력값 : True ")
    print( vaildUtf8(data2), "         |    기대 출력값 : False ")

