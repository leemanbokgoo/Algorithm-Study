# 85 -1 ) 배낭 문제
# 피보나치 수열과 함께 동적 계획법의 대표문제 중 하나이다.
# 분할 가능 배낭문제를 그리디 알고리즘으로 풀어본바있다. 탐욕 선택 속성이 있는 문제였는데 이번에는 짐을 쪼갤 수 없는 배낭 문제를 풀이한다.
# 탐욕 선택 속성이 문제가 아니며 중복된 하위 문제들 속성을 갖고있으므로 동적 계획법으로 풀수있다.

# [ 풀이 1 ] 동적 계획법 구현
# 단가 순으로 그리디하게 배치해서 풀이했던 분할 가능 배낭 문제와 달리, 배낭문제는 짐을 쪼갤 수 없다.
# 이 경우 모든 경우의 수를 계산해야 하며 이렇게 모든 경우의 수를 계산하는 문제에서 동적 계획법은 위력을 발휘한다.
def zero_one_knapsack(cargo):
    capacity = 15 # 배낭이 담을 수 있는 최대 무게(용량)

    # pack이라는 리스트 변수에 6 X 16 행렬 형태의 중간 결과 테이블이 생성할 것이다.
    # 테이블 크기의 기준은 짐의 최대 개수 +1, 배낭의 최대 용량 + 1 이렇게 6 X 16이다.
    # 이 테이블의 각각의 셀에는 그 위치까지의 짐의 개수와 배낭의 용량에 따른 최댓값이 담기게 된다.
    # pack[]   : 첫번째 짐부터 i번째 짐까지 왔을때의 가능한 모든 용량(c)에 대한 최적 가치들이 저장된 1차원 리스트
    # pack[][] : i번째 짐까지 고려했을 때, 용량이 c인 배낭에 담을 수 있는 최대 가치
    pack = [] # 2차원 배열 (테이블)

    # 짐의 갯수까지
    for i in range(len(cargo) + 1):
        pack.append([])

        for c in range( capacity + 1 ):
            # 짐의 개수가 0이거나 (i=0), 배낭 용량이 0이면 (c=0), 얻을 수 있는 가치는 당연히 0이다.
            if i == 0 or c == 0:
                pack[i].append(0)

            # 현재 짐의 무게(cargo[ i - 1 ][1])가 현재 용량 c보다 작거나 같을 때, 두 가지 옵션 중 더 큰 가치를 선택
            # i - 1하는 이유는 0부터 인덱싱이 시작하기때문이다. 첫번째 짐은 0번쨰 배열에 들어가있음.
            elif cargo[ i - 1 ][1] <= c:

                pack[i].append(
                    max(
                        # cargo[ i - 1 ][0] : 현재 짐의 가치 + pack[i - 1][ c - cargo[ i - 1 ][1] ] : 현재 짐의 가치를을 배낭에 넣고 남은 용량에서 얻을 수 있는 최대 가치
                        # c - cargo[ i - 1 ][1] : 총 용량 c에서 현재 짐의 무게(c - cargo[ i - 1 ][1])를 뺀 값. 남은 용량
                        # 즉, pack[i - 1][ 남은용량 ]의 값을 더한다.
                        # 여기서 헷갈리지 말아야할 부분은 cargo[i - 1]의 경우 0부터 인덱싱되는 실제 짐 목록(cargo 리스트)에서 현재 i번째의 짐을 찾기위해선 -1을 해야한다.
                        # 그러나 dp테이블 pack에서는 바로 이전 단계를 나타내는 행 인덱스이기때문에 i번째 행은 i번째 짐을 넣을지 말지 결정한 결과를 저장한다. 즉, i -1은 i번째 짐을 넣지않은 상태를 의미한다.
                        # 두 값을 더함으로 현재 짐을 넣는 최적의 시나리오의 총 가치가 계산된다. 이 값은 이후 현재 짐을 넣지않은 경우의 수의 가치(pack[i - 1][c])와 비교되어 둘 중 더 큰 값이 선택된다.
                        cargo[ i - 1 ][0] + pack[i - 1][ c - cargo[ i - 1 ][1] ],
                        # 현재 짐을 넣지않은 경우의 수.
                        pack[i - 1 ][c]
                    )
                )

            # 현재 짐이 너무 무거워 전체 용량(c)에  넣을 수 없는 경우
            else:
                # i번째 짐을 넣기 전, 즉 i-1번째 짐까지의 최대 가치를 그대로 유지한다.
                pack[i].append(pack[i - 1][c])

    # pack 테이블의 마지막 행[-1] 마지막 열 [-1]에 저장된 값이 배낭에 담을 수 있는 최대 가치다.
    return pack[-1][-1]

if __name__ == "__main__":
    # ( 가격, 무게 )
    cargo = [ (4,12), (2,1), (10,4), (1,1), (2,2) ]
    r = zero_one_knapsack(cargo)
    print(r)

