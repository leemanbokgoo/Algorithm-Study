import collections
# 85 ) 피보나치 수

# [ 풀이 1 ] 재귀 구조 브루트 포스
# 피보나치 수의 가장 기본적인 알고리즘이다.
def fib(N : int ) -> int:
    if N <= 1:
        return N

    # $N >= 2 일 때, N번째 피보나치 수는 (N-1)번째 피보나치 수와 (N-2)번째 피보나치 수의 합과 같다는 피보나치 수열의 점화식.
    # N의 앞의 숫자와, N의 앞의 숫자의 앞의 숫자의 합을 구하면 N의 값이 나온다.
    return fib(N - 1) + fib( N - 2 )

# [ 풀이 2 ] 메모이제이션
# 다이나믹 프로그래밍의 하향식 풀이로 정리한 것.
# 브루트 포스 풀이와 유시하게 재귀로 계산해 나가지만 이미 계산한 값은 저장해뒀다가 바로 리턴한다.
# fib(5)일때 15번 연산하던 풀이와는 다르게 9번의 연산만으로도 가능하다.
class Solution:
    dp = collections.defaultdict(int)

    def fib(self, N : int) -> int:
        if N <= 1:
            return N

        # 만약 dp[N]값이 존재한다면 리스트에 저장해둔 값을 바로 반환한다.
        if self.dp[N]:
            return self.dp[N]

        # 없으면 [ 풀이 1 ] 과 똑같이 계산하여 리스트에 저장해준다.
        self.dp[N] = self.fib(N - 1) + self.fib( N - 2 )

        # 저장해준 값을 반환
        return self.dp[N]

# [ 풀이 3 ] 타뷸레이션
# 재귀를 사용하지않고 반복으로 풀이하며, 작은 값부터 직접 게산하면서 타뷸레이션한다.
# 미리 계산을 해두는 것인데, 다른 복잡한 다이나믹 프로그래밍 문제와 달리 타뷸레이션이 일차원 선형구조라 복잡하지도 않고 구조도 단순해 이해가 쉬운편이다.
#메모이제이션과 마찬가지로 실행 속도도 당연히 빠르다.
class Solution2:
    dp = collections.defaultdict(int)

    def fib(self, N: int) -> int:
        # DP 배열(self.dp)에서 가장 기본이 되는 두 값, 즉 피보나치 수열의 초기 조건을 미리 설정해줘야함.
        # 가장 작은 문제(0, 1)부터 차례대로 시작하는 것.
        self.dp[0] = 0
        self.dp[1] = 1

        # 반복문으로 [ 풀이 1 ] 과 똑같은 점화식을 생성하는 것임.
        # 0과 1의 값은 이미 위에서 정했으므로, 2부터 시작한다.
        for i in range(2, N + 1):
            self.dp[i] = self.dp[ i - 1] + self.dp[ i - 2 ]

        return self.dp[N]

# [ 풀이 4 ] 두 변수만 이용해 공간 절약
#  [ 풀이 3 ]은 dp라는 딕셔너리에(편의상 그대로 사용했지만 사실 단순 배열만 사용해도 충분함) 결괄르 차곡차곡 담아나갔지만 변수는 2개만 있어도 충분하다.
# 동적 계획법 보다 메모리 사용량이 훨씬 적다.
def fib(N : int ) -> int:

    # 피보나치 수열의 시작값인 0과 1 셋팅
    # 여기서 x와 y는 매 반복마다 피보나치 수열의 두 이웃하는 항을 임시로 저장하는 역할을 한다.
    # x : 현재 항
    # y : 다음 항
    x,y = 0, 1

    for i in range(0, N):
        # 피보나치 수열은 바로 앞의 두항을 더하면 그 다음항이 된다는 규칙을 따른다. (n) + (n+1) = n+2 가 되는 것이다.
        # (새로운 x) <- (이전 y)  : 다음 루프의 현재 항. 이전의 y를 받아 다음 반복문의 현재 항이 되게 한다.
        # (새로운 y) <- (이전 x + 이전 y) : 다음 루프의 다음 항. 현재항과 다음항을 더하면 다음 x(현재항)의 다음항이 된다. 다음 반복문에서 y는 새로운 x의 다음항이 되어야함으로 x + y 로 값을 구한다.
        # 참고로 동시 할당을 해야 값이 문제 없이 들어간다. 그렇지않으면 x + y 계산 시 x값이 이미 y가 되버려서 계산이 제대로 안된다.
        x, y = y, x + y

    return x
