import collections
# 87 ) 계단 오르기
# 당신은 계단을 오르고있다. 정상에 도달하기 위해 n 계단을 올라야한다.
# 매번 각각 1계단 또는 2계단씩 오를 수 있다면 정상에 도달하기 위한 방법은 몇가지 경로가 되는 지 계산하라.

# [ 풀이 1 ] 재귀 구조 브루트 포스
# 어려워보이지만 기본적으로 피보나치 수와 동일한 유형의 문제다. 다만, 방법과 형식이 달라 연상하기 어려울 뿐 동일한 방식으로 풀이할 수 있다.
# 새로운 유형의 문제를 피보나치 수열 같은 기존의 유명한 문제와 연결해 풀이하는 방법은 문제 해결에 매우 좋은 방법이다.
# 그러나 이 방법은 타임아웃으로 풀리지않는다.
def climbStairs(n : int ) -> int:

    # 재귀 호출이 멈추고 답이 확정되는 지점.
    # n이 1일때 계단을 오르는 방법은 1가지(1칸)이다.
    if n == 1:
        return 1

    # n이 2일때 계단을 오르는 방법은 2가지(1,1)(2)이다.
    if n == 2:
        return 2

    # n개의 계단을 오르는 총 방법의 수는 (n-1)번째 계단까지 오는 방법의 수와 (n-2)번째 계단까지 오는 방법의 수를 합한 것과 같다. (피보나치 수열 원리)
    # 모든 경우의 수는 2가지로 분류할 수 있는데, 마지막 걸음이 1계단인 경우, 마지막 걸음이 2계단인 경우로 나뉠 수 있다. 고로 climbStairs(n - 1) + climbStairs(n - 2)이 가능하다.
    # 재귀가 마지막까지 도달하면 climbStairs(2) + climbStairs(1) = 2 + 1 = 3이다.
    # climbStairs(1)의 1가지 방법은 (1), climbStairs(2)의 2가지 방법은 (1, 1)과 (2)이다.
    # 만약, n=3의 총 3가지 방법은 다음과 같이 구성된다.
    # 1. 마지막에 1칸을 밟는 경우 (climbStairs(2)의 경로 + 1): (1, 1, 1), (2, 1) [총 2가지]
    # 2. 마지막에 2칸을 밟는 경우 (climbStairs(1)의 경로 + 2): (1, 2) [총 1가지]
    # 이런 식으로 작은 계단(n-1, n-2)의 경우의 수를 합치면 큰 계단(n)의 경우의 수가 나온다.
    return climbStairs(n - 1) + climbStairs(n - 2)

# [ 풀이 2 ] 메모이제이션
# [ 풀이 1 ] 과 사실상 동일한 코드이며 메모이제이션을 사용했을 뿐이다.
class Solution:
    dp = collections.defaultdict(int)

    def climbStairs(self, n : int ) -> int :
        # n=1 일 때는 1가지 방법 (1칸), n=2 일 때는 2가지 방법 (1+1, 2)이므로, n이 2 이하일 때 n을 반환
        if n <= 2:
            return n

        # 만약 이미 n을 계산했다면 n의 값을 리턴한다.
        if self.dp[n]:
            return self.dp[n]

        # [ 풀이 1 ] 과 똑같은 점화식이나 다른 점은 계산값을 dp에 저장하는 것이다.
        self.dp[n] = self.climbStairs(n - 1) + self.climbStairs(n - 2 )

        # dp에 저장한 n의 값을 내보낸다.
        return self.dp[n]

if __name__ == "__main__":

    input = 3
    s = Solution()

    # 1 + 1 + 1
    # 1 + 2
    # 2 + 1
    # 답은 3가지
    print( "[ 풀이 1 ] 재귀 구조 브루트 포스 "  , climbStairs(input), " | 기대 출력값 3")
    print( "[ 풀이 2 ] 메모이제이션 "  , s.climbStairs(input), " | 기대 출력값 3")

