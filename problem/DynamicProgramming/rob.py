import collections
from typing import List
# 88 ) 집 도둑
# 당신은 전문털이범이다. 어느 집에서든 돈을 훔쳐올 수 있지만 경보 시스템 떄문에 바로 옆집은 훔칠 수 없고 한칸 이상 떨어진 집만 가능하다.
# 각 집에는 훔칠 수 있는 돈의 액수가 입력값으로 표기되어있다. 훔칠 수 있는 가장 큰 금액을 출력하라


# [ 풀이 1 ] 재귀 구조 브루트 포스
# 이런 유형의 문제를 보면 바로 다이나믹 프로그래밍을 떠올려야한다.
# 바로 옆집은 훔칠 수 없으니 현재 집과 옆집 숫자 중 최댓값을 구하고 한 집 건넛집까지의 최댓값과 현재 집의 숫자값과의 합을 구해서 두수 중 더 높은 값이 정답이 된다.
# 이렇게 하면 피보나치 수열과 유사한 형태로 다음과 같이 간단한 재귀로 풀수있다.
# 다만 이 풀이는 정답은 잘 나오지만 탐색 범위가 넓어 타임아웃이 걸린다.
def rob( nums : List[int]) -> int:

    def _rob( i : int ) -> int:
        # 재귀 종료 조건
        if i < 0 :
            return 0

        # Top-Down 방식. 큰 문제 -> 작은 문제로 풀이한다.
        # i의 이전 집(i - 1)과 한집 건너집 + 현재 i를 더한 값((i - 2) + nums[i])을 구해서 비교한다.
        # 즉, i를 털지 않는 경우와 i를 털고 건너 집 까지 터는 경우를 비교해서 더 큰 값을 반환한다.
        return max(_rob( i - 1 ), _rob( i - 2 ) + nums[i])

    # 배열의 마지막 인덱스 (len(nums) - 1)부터 재귀 함수를 시작하여, 전체 집들을 고려했을 때 훔칠 수 있는 최대 금액을 얻어 반환
    return _rob( len(nums) - 1 )

# [ 풀이 2 ] 타뷸레이션
# 알고리즘은 동일하다. 다만, 이미 계산한 값은 dp에 저장하고 두번이상 계산하지않는다.
# 재귀로 구현하는 메모이제이션보다 순회 방식인 타뷸레이션이 좀 더 직관적이여서 이해하기 쉽다.
def rob2( nums : List[int]) -> int:

    # 예외 처리
    if not nums:
        return 0

    if len(nums) <= 2:
        return max(nums)

    dp = collections.OrderedDict()

    # dp[1]일 경우 집이 두개라는 의미임으로 둘 중 더 큰 금액을 넣어준다.
    dp[0] , dp[1] = nums[0], max(nums[0], nums[1])

    # range(2, len(nums))로 2부터 시작하는 이유는 인덱스 0과 1의 값은 이미 반복문 이전에 계산하여 초기화했기 때문이다.
    for i in range(2, len(nums)):
        # 아까와 같은 점화식을 쓰고 대신, 계산한 값을 저장한다.
        dp[i] = max( dp[i - 1], dp[ i - 2 ] + nums[i] )

    # 가장 마지막 값ㅇ르 추출하기 위해 popitem() 사용. 딕셔너리에서 가장 마지막 아이템을 추출하기위해서는 popitem()을 사용함.
    return dp.popitem()[1]

if __name__ == "__main__":

    nums = [1,2,3,1]
    nums2 = [2,7,9,3,1]

    # 첫번째 집에서 1, 세번째 집에서 3, 따라서 1 + 3 = 4
    print( "[ 풀이 1 ] 재귀 구조 브루트 포스 "  , rob(nums), " | 기대 출력값 4")
    # 첫번쨰 집에서 2, 세번째 집에서 9, 다섯번째 집에서1, 따라서 2 + 9 + 1 = 12
    print( "[ 풀이 1 ] 재귀 구조 브루트 포스 "  , rob(nums2), " | 기대 출력값 12")

    print(" ========================================================= ")

    print( "[ 풀이 2 ] 타뷸레이션 "  , rob2(nums), " | 기대 출력값 4")
    print( "[ 풀이 2 ] 타뷸레이션 "  , rob2(nums2), " | 기대 출력값 12")

