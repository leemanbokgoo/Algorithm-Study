import collections
import heapq
from typing import List
# 40) 네트워크 딜레이 타임
# K부터 출발해 모든 노드가 신호를 받을 수 있는 시간을 계산하라. 불가능한 경우 -1을 리턴한다.
# 입력값(u,v,w)는 각각 출발지,도착지, 소요 시간으로 구성되며, 전체 노드의 개수는 N으로 입력받는다.

# [ 풀이 1 ] 다익스트라 알고리즘 구현
# 이 문제는 1. 모든 노드가 신호를 받는 데 걸리는 시간 2. 모든 노드에 도달 할 수 있는 지 여부.를 판별해야한다.
# 모든 노드가 신호를 받는 데 걸리는 시간이란 가장 멀리 있는 노드까지 가는 데 걸리는 시간이라고 할 수 있다. 즉, 가장 멀리 있는 노드까지 가는데 걸리는 최단 시간을 말한다.
# 두번쨰 모든 노드에 도달할 수 있는 지 여부는 모든 노드의 다익스트라 알고리즘 계산값이 존재하는 유무로 판별할 수 있다.
# 만약 노드가 8개인데 다익스트라 알고리즘 계산은 7개밖에 할 수 없다면 나머지 한 노드는 도달할 수 없다는 의미다. 이 경우 -1을 리턴한다.
# 우선순위 큐를 통해 다익스트라 알고리즘을 가정한다.
def networkDelayTime(times: List[List[int]], N : int, K : int) -> int:
    graph = collections.defaultdict(list)

    # 입력값을 리스트 형태로 구성
    for u, v, w in times:
        # u : 출발 노드
        # v : 도착 노드
        # w : 소요시간
        # ex) 1번 노드에서 2번 노드로 5분 걸린다면 graph[1] = (2,5)
        graph[u].append((v,w))

    # Q : 우선 순위 큐 역할을 할 리스트
    # (0,K) : ( 소요시간, 노드번호 ) 구조로 구성하여 시작점에서 정점 까지의 소요시간을 담아둔다. 초깃값은 시작점 K, k부터 k까지의 소요시간 0.
    Q = [(0,K)]

    # 최단 거리(시간) 테이블을 저장할 변수. 출발 노드 K에서 각 노드까지 도달하는 최단 거리를 저장한다.
    dist = collections.defaultdict(int)

    # 우선순위 큐 Q가 빌 때까지, 즉 탐색할 노드가 없을 때까지 반복
    while Q:

        # Q에서 현재까지 발견된 시간 중 가장 짧은 시간을 가진 노드와 시간을 꺼낸다.
        # heapq.heappop(Q) : 힙(heap) 자료구조에서 가장 작은 원소를 제거하고 그 값을 반환하는 역할
        time, node = heapq.heappop(Q)

        # 노드가 dist(출발 노드 K에서 각 노드까지 도달하는 최단거리를 저장하는 변수)에 아직 기록되지않았다면(= 최단 시간이 확정되지않았다면)
        # 이미 기록된 노드는 더 긴 경로로 다시 온 것이므로 무시
        if node not in dist:
            # 현재 꺼낸 시간 time이 node까지의 확정된 최단 시간임으로 테이블에 기록.
            # 최단 거리임을 확신할 수 없는 이유는 다음과 같다.
            # 1. 우선순위 큐는 현재 소요시간이 가장 작은 원소를 먼저 꺼낸다. node로 다시 도착하는 더 짧은 경로가 있다면, 그 짧은 경로는 이미 먼저 우선순위 큐에 들어가있어야한다.
            # 2. 음수 가중치의 부재. 시간은 음수가 될 수 없음으로 소요시간 w(가중치)는 항상 양수이다. 노드 a에서 이웃노드 b로 이동할때 경로의 총시간은 반드시 증가한다.
            dist[node] = time

            # 현재 노드 node와 연결된 모든 이웃 노드 v와 그 간선의 가중치(소요 시간) w를 순회
            # 즉, node와 연결된 이웃 노드를 찾아서 그 이웃노드 까지 걸리는 시간을 구하는 반복문.
            # ex) 출발점 k에서 node 까지 3시간, node에서 이웃노드 v까지 걸리는 시간 w 이라고 가정하면 출발점 k에서 이웃노드 w까지 걸리는 시간은 time + w
            for v,w in graph[node]:
                # time(node 까지의 최단 시간 )에 이웃 노드 v까지 가는 시간 w를 더한다.
                # alt : 출발점 K-> 현재 노드 node -> 이웃노드 w 까지 가는 총 소요 시간
                # 이걸 하는 이유는 현재 노드와 연결된 이웃 노드 v라는 새로운 경로를 발견했기때문에 그 경로를 우선순위 큐에 넣어주기 위함.
                # 큐에 넣어주는 이유는 문제에서 모든 노드의 최단 거리를 구하라고 했기때문이다.
                alt = time + w

                # 위에서 계산한 출발점 k에서 이웃노드 v까지의 소요 시간 alt와 이웃 노드 노드 v를 우선순위 큐에 다시 넣어준다.
                heapq.heappush(Q, (alt, v))

    # 다익스트라 알고리즘이 끝난 후 dist 테이블에 기록된 노드 개수가 전체 노드 개수 N과 같다면 = 모든 노드가 신호를 받을 수 있음.
    if len(dist) == N:
        # 테이블에 기록된 가장 큰 시간 값을 반환. 이 값이 신호가 모든 노드에 도달하는데 걸리는 최소 최대 시간이다.
        return max(dist.values())

    #  if len(dist) == N:이 아니라면 모든 노드가 신호를 받지못했음으로 -1을 리턴.
    return -1

if __name__ == "__main__":
    # 입력값
    times = [ [2,1,1], [2,3,1], [3,4,1] ]
    N,K = 4,2

    # 출력값
    expected_result = 2

    result = networkDelayTime(times,N,K)
    print(str(result))
    print('True' if result == expected_result else 'False')
