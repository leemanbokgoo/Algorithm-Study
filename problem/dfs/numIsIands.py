from typing import List
# 32) 섬의 개수
# 1을 육지로 0을 물로 가정한 2D 그리드 맵이 주어졌을때, 섬의 개수를 계산하라.(연결되어있는 1의 덩어리 개수를 구하라.)
# 해당 문제는 1이 0으로 둘러쌓여서 1과 1끼리 연결 되어있지않으면 그 1덩어리를 하나의 섬으로 보는 것이다.
# 입력값이 정확히 그래프는 아니지만 사실상 동서남북이 모두 연결된 그래프로 가정하고 동일한 형태로 처리할 수 있다.
# 육지 1 , 물 0 으로 보고 상화좌우로 인접한 1들은 하나의 섬으로 간주된다.

from typing import List

# [ 풀이 1 ] DFS로 그래프 탐색
# 네 방향 각각 DFS 재귀를 이용해 탐색을 끝마치면 1이 증가하는 형태로 육지의 개수를 파악 할 수 있다.
# 그래프를 탐색하면서 1을 만나면 섬의 시작점으로 간주하고 count 변수를 +1 하고, 그 다음 1과 연결된 나머지 1을 모두 0으로 변경한다.
# (0으로 변경하는 행위는 해당 섬을 방문했다고 처리하는 셈이다. 이를 통해 나중에 다시 섬을 세는 일을 막는다.)
# 모든 노드를 탐색한후 최종 count 가 총 섬의 개수가 된다.
def numIslans(grid: List[List[str]]) -> int:

    def dfs(i, j):

        # 경계 조건을 확인하거나 이미 방문했거나 ('0' 또는 0으로 바뀐 경우) 물인 경우
        # i < 0 or i >= len(gird) : 현재 i(현재 행 인덱스)가 그리드의 상단(0) 또는 하단 경계(len(gird))를 벗어났는지 확인.
        #  len(gird)은 전 체 행의 갯수다.
        # j < 0 or j >= len(grid[0]) : 현재 j(현재 열 인덱스)가 그리드의 왼쪽(0)또는 오른쪽 경계(grid[0])를 벗어났는지 확인.
        # grid[i][j] != '1' : 해당 위치가(ex grid[0][1])이 1(육지)가 아닌지 확인한다. 즉, 0이면 멈춘다.
        if i < 0 or i >= len(grid) or \
                j < 0 or j >= len(grid[0]) or \
                grid[i][j] != '1':
            # 위 조건 중 하나라도 참이면, 이 경로에서의 재귀 호출을 즉시 중단하고 이전 호출로 돌아간다.
            return

        # 현재 노드가 위의 모든 if문 조건을 통과했다면, 이는 유효한 미방문 육지('1') 노드이다.
        # 그러니 현재 육지 노드를 방문했음을 표시하기위해 값을 0으로 바꾼다.
        grid[i][j] = 0

        # 방문 처리가 완료되면 현재 셀과 상화좌우로 인접한 노드에 대해 재귀적으로 dfs를 다시 호출한다.
        # 이 과정이 반복되면서 연결된 모든 1 노드를 [ 깊이 우선 ]으로 따라가면서 0으로 모두 바꾼다.
        dfs(i + 1, j) # 아래 (행 증가)
        dfs(i - 1, j) # 위 (행 감소)
        dfs(i, j + 1) # 오른쪽 (열 증가)
        dfs(i, j - 1) # 왼쪽 (열 감소)

    count = 0 # 섬의 개수를 0으로 초기화
    # 격자를 순회하며 '1'을 찾는다.
    # 모든 노드를 (0,0)부터 순서대로 탐색(i는 행, j는 열)
    for i in range(len(grid)):
        # 그리드는 격자모양이라 모든 행의 길이가 같기때문에 그냥 grid[0]의 길이 만큼 반복하면 된다.
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                # 현재 위치가 1이라면 새로운 섬으로 판단. dfs를 시작하여 노드를 탐색한다. -> 전체 섬을 방문처리.
                # numIslans 함수에 전달된 grid는 메모리에 있는 특정 2차원 리스트 객체를 가리키는데,
                # dfs 함수가 호출될 때, grid 리스트 전체가 복사되는 것이 아니라, dfs 함수 역시 메모리상의 동일한 grid 객체를 가리키게 되기떄문에
                # DFS 함수에서 0으로 바꾼 변경 사항은 numIslans 함수 내의 원래 grid 리스트에 즉시 적용된다.
                dfs(i, j)
                count += 1
    return count


if __name__ == "__main__":
    # 입력값 1
    # 11110
    # 11010
    # 11000
    # 00000
    grid1 = [
        ["1", "1", "1", "1", "0"],
        ["1", "1", "0", "1", "0"],
        ["1", "1", "0", "0", "0"],
        ["0", "0", "0", "0", "0"]
    ]
    output1 = numIslans(grid1)
    result_status = "True" if output1 == 1 else "False"
    print(f"입력값 1의 결과: {output1}" + " | 기대 출력 : 1 " + str(result_status))

    # 입력값 2
    # 11000
    # 11000
    # 00100
    # 00011
    grid2 = [
        ["1", "1", "0", "0", "0"],
        ["1", "1", "0", "0", "0"],
        ["0", "0", "1", "0", "0"],
        ["0", "0", "0", "1", "1"]
    ]
    # 기대 출력: 3
    output2 = numIslans(grid2)
    result_status2 = "True" if output2 == 3 else "False"
    print(f"입력값 2의 결과: {output2}" + " | 기대 출력 : 3 " + str(result_status2))

    # 참고: DFS가 원본 리스트를 변경하므로 (in-place modification),
    # 같은 리스트를 재사용하려면 복사해야 합니다.
    # 이 테스트에서는 별도의 리스트 변수를 사용했으므로 문제 없습니다.