
# 43) 이진 트리의 직경
# 이진 트리에서 두 노드간 가장 긴 경로의 길이를 출력하라.
# 이진 트리가 주어졌을때, 가장 긴 경로는 4->2->1->3 또는 5->2->1->3으로 3이다.
# 이진 트리 : [1] 의 자식 노드 [2]와 [3] , 2의 자식노드 [4]와 [5]
#         [2][3]
#       [4][5]

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# [ 풀이 1 ] 상태값 누적 트리 DFS
# 긴 경로를 찾는 방법은 먼저 가장 말단, 즉 리프 노드까지 탐색한 다음 부모 노드로 거슬러 올라가면서 각각의 거리를 계산해 상태 값을 업데이트하면서 다음과 같이 누적해 올라가면 된다.
# 여기서 상태 값은 부모 함수의 반환 값...?
class Solution:
    def __init__(self):
        # 트리에서 발견한 가장 긴 경로를 저장하는 역할.
        # 중첩 함수 내에서 값을 변경 할 수없음으로 클래스 변수로 사용.
        # self.longest = max(self.longest, left + right + 2)에서 longest 변수에 값을 재할당하는데 이게 부모 함수의 변수는 재할당을 할 수 없어서
        # 부모 함수의 변수를 그대로 사용할 수 없다. 그래서 클래스 변수로 만들어 사용한다.
        self.longest = 0

    def diameterOfBinaryTree(self, root: TreeNode) -> int:

        # 트리에서 경로를 셀때는 노드의 개수가 아니라 [[ 간선의 갯수  ]]를 계산한다.
        # 즉, DFS가 반환하는 높이도 간선 기준으로 계산된다.
        # 그러나 이 코드에서 주의해야할 점은 재귀 함수의 반환 값은 "높이"라는 것이다.
        # 가장 높은 노드의 "높이"를 구해서 거기에다 간선을 +2하면 가장 긴 경로 된다.
        # 왜냐면 경로을 잴때 root 노드에 도달하기 전까지는 간선 1개만 카운트하다가 root 노드의 자식 노드에 도달하면
        # root 노드의 왼쪽 자식 노드, 오른쪽 자식 노드를 연결하는 간선 2개를 카운트 해줘야하기 때문이다.
        # 헷갈리면 그림을 보면서 간선의 수를 세보면 이해가 된다.

        # 깊이 우선 탐색을 통해 트리를 탐색하면서 각 노드의 정보를 계산한다.
        # 현재 노드 기준에서 가장 깊은 자식 노드까지의 높이를 반환한다.
        def dfs(node: TreeNode) -> int:
            # 노드가 없으면 -1 을 반환.
            # -1을 쓰는 이유는 리프 노드(자식이 없는 노드)의 높이를 0으로 만들기 위함이다.
            # 리프 노드의 높이는 0이지만 다른 노드의 경우 현재 노드의 높이도 높이에 넣어줘야하기때문에 return max(left, right) + 1을 한다.
            # 하지만 이를 리프 노드에 동일하게 적용하면 리프 노드의 높이가 1이 되어버린다.
            # 이런 사태를 방지하기 위해 자식 노드가 없다면 -1을 반환하여 max(-1,-1) + 1이 되도록 한 것. 그러면 리프 노드의 높이값은 0이 된다.
            if not node:
                return -1

            # 현재 노드의 왼쪽 서브트리와 오른쪽 서브 트리의 높이를 제귀적으로 구한다.
            # 이런식으로 재귀를 타고 리프 노드(트리의 끝) 까지 내려간 후 부터 left, right를 구해서 값을 반환하며 트리를 타고 올라가는 것.
            left = dfs(node.left)
            right = dfs(node.right)

            # 현재 노드를 기준으로 (왼쪽 높이 + 오른쪽 높이 + 2)를 구한다.
            # left + right는 단순히 각 서브트리 높이만 더한 것으로 현재 노드와 왼쪽,오른쪽 자식 노드를 연결하는 간선이 포함 되지않았다.
            # 현재 노드와 왼쪽 노드를 연결하는 간선 2개를 포함해야 가장 긴 경로값이 된다. 그래서 +2를 하는 것이다.
            # 기존의 longest와 비교해서 더 큰값을 저장한다. 이렇게 트리 전체를 탐색하면서 가장 긴 경로를 찾는다.
            self.longest = max(self.longest, left + right + 2)

            # 현재 노드의 높이를 반환하는 것이다. 현재 자식 노드의 높이(left or right) + 자식 노드와 현재 노드와의 높이(1)을 더한다.
            # 여기서 +1은 현재 노드의 높이(간선) 값이다. 왼쪽 , 오른쪽 노드의 높이 중 더 높은 쪽에 현재 노드 높이 값을 더한다.
            # 1개만 더하는 이유는 경로를 잴떄 root 노드를 제외하고 부모 노드는 자식노드 둘다 와 연결 될 수 없다. 둘 중 하나만 연결된다.
            return max(left, right) + 1

        ## [[  헷갈 릴 수 있는 부분 ]]]
        # 43번 풀이는 갱신 시에는 양쪽 간선 2개를 더하고, 반환 시에는 부모에게 전달할 간선 1개를 더 한다.
        # 이들은 서로 다른 목적의 계산이기 때문에 동시에 사용되는 것이지, 매번 간선을 총 3개 더하는 것은 아니다.
        # 한번 노드를 올라갈때마다 +1(하나의 간선) 을 더 하거나 양쪽 간선 2개를 더한다.
        # 43번은 조건이 없으므로 44번 처럼 if문을 통해 +1하는 것보다 표준적인 재귀 높이 계산 방식(+1)을 사용하는 것이 일반적이다.
        # 표준적인 재귀 높이 계산 방식 : 어떤 노드 N의 높이는 N에서 리프 노드까지의 가장 긴 경로의 간선 수로 정의된다. Height(N)=max(Height(N.left),Height(N.right))+1


        # 루트 노드부터 탐색을 시작.
        dfs(root)

        # 최종적으로 갱신된 트리의 지름을 반환한다.
        return self.longest

if __name__ == "__main__":
    # 트리 구성
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)

    sol = Solution()
    result = sol.diameterOfBinaryTree(root)

    print("입력 트리 구조: [1, 2, 3, 4, 5]")
    print("출력값:", result)  # 기대값: 3