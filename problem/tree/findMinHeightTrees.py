import collections
from typing import List

# 49 ) 최소 높이 트리
# 노드 개수와 무방향 그래프를 입력받아 트리가 최소 높이가 되는 루트의 목록을 리턴한다.
# 입력 : n = 4, edges = [ [1,0],[1,2],[1,3] ]
# 출력 : [1]
# 입력 : n = 6, edges = [ [0,3],[1,3],[2,3],[4,3],[5,4] ]
# 출력 : [3,4]
# 3 또는 4가 루트가 되는 트리가 될 경우 최대 높이 2인 트리가 된다.

# [ 풀이 1 ] 단계별 리프 노드 제거
# 최소 높이를 구성하려면 가장 가운데 있는 값이 루트여야한다.
# 가장 가운데 있는 값을 구하려면 리프 노드를 하나씩 제거 해나가면서 남아있는 값을 찾으면 된다. ( 루트 노드는 하나니까.)
# 여기서 리프 노드를 판단하는 기준은 리프 노드는 자식 노드가 없음으로, 자식 노드가 없으면 제거 해나가면 된다.
def findMinHeightTrees( n : int, edges : List[List[int]]) -> List[int]:

    # n : 노드 개수가
    if n <= 1:
        return [0]

    # graph 변수 초기화
    graph = collections.defaultdict(list)

    # 그래프에 입력값을 넣는다.
    # 이 문제에서 그래프는 무 방향이므로 트리의 부모와 자식은 양쪽 노드 번갈아 가능하다.
    # 따라서 양쪽 모두 graph 라는 이름의 그래프 딕셔너리 변수에 양방향으로 삽입하여 구성한다.
    # graph의 데이터 형태는  { 1:[3], 2:[1,2,3,4] } 이런식으로 구성된다.
    for i, j in edges:
        # 양방향으로 삽입.
        graph[i].append(j)
        graph[j].append(i)

    # 리프 노드를 담둘 변수
    leaves = []

    for i in range( n + 1 ):
        # 만약 graph[i]의 값이 길이 1이라면 리프 노드다.
        # graph[i]의 값이 1이면 왜 리프 노드이냐? 현재 무방향 그래프를 입력값아 계층 구조 없이 일단 연결된 노드들은 양방향으로 연결하여 그래프를 만들었다.
        # 그렇기 때문에 연결된 노드가 하나라면 트리 구조로 치환 했을 때 부모 노드만 가지고 있고 자식 노드가 없다는 소리다.
        # 실제 입력값은 무방향 그래프임으로 리프 노드가 존재하지않지만, 이 문제에서 무방향 그래프를 트리로 만들기 떄문에 해당 노드를 편의상 리프 노드라고 지칭한다.
        # 무방향 그래프를 트리로 변환할때 리프 노드에 해당되는 노드이기때문이다.
        if len(graph[i]) == 1:
            # 리프 노드를 담아두는 배열에 저장
            leaves.append(i)

    # n가 > 2 이하라는 얘기는 남은 노드가 하나 혹은 두개 밖에 없다는 뜻이다.
    # 즉, root 노드만 남을때까지 반복해서 제거 한다.
    # 여기서 루트 노드는 홀수,혹은 짝수 즉, 1개 또는 2개일 수 있다.
    # (실제로 트리에서 루트 노드는 하나지만, 2개인 경우가 있는 이유는 어디까지나 root node가 될만한 후보 값을 찾는 것이기떄문)
    while n > 2 :
        # 노드 개수 - 저장한 리프 노드의 갯수 는 리프 노드를 제외한 노드의 개수다.
        n -= len(leaves)

        # 새로운 리프 노드를 담을 변수
        new_leaves = []

        # 리프 노드 들을 하나씩 꺼낸다.
        for leaf in leaves:
            # neighbor = graph[leaf].pop() : neighbor값은 트리 구조로 치환 했을 때 리프 노드의 부모 노드에 해당하는 값이다.
            neighbor = graph[leaf].pop()

            # 입력값이 무방향 그래프라 그래프를 각각 두번씩 만들었으므로 제거 또한 두번씩 진행한다.
            # 부모 노드와 연결 된 리프 노드의 값을 제거 한다. ex) 부모노드 : [ 연결 노드, 연결 노드, 리프 노드 ] 이런 식으로 저장되어 있음으로 리프 노드 삭제.
            # 즉, 두 노드 간의 연결을 끊어낸 것이다.
            graph[neighbor].remove(leaf)

            # 위에서 리프 노드를 삭제 한 후, 부모 노드와 연결된 노드가 하나 뿐이라면? 이제 이 부모 노드가 리프 노드가 된다는 말이다.
            if len( graph[neighbor] ) == 1 :
                # new_leaves(새로운 리프 노드 배열) 에 저장한다.
                new_leaves.append(neighbor)

        # leaves에 new_leaves값을 갱신한다.
        # 다음 반복 시에 는 new_leaves값이 leaves값이 되어 위의 코드대로 다시 동작한다.
        leaves = new_leaves

    # while문이 끝나면 리프 노드에는 최종적으로 2개 이하의 노드가 남게 되는데.
    # 마지막에 리프 노드 배열에 들어가는 노드가 root 노드이다. 고로 이것을 반환한다.
    return leaves



if __name__ == "__main__":
    # 입력 : n = 4, edges = [ [1,0],[1,2],[1,3] ]
    # 출력 : [1]
    # 입력 : n = 6, edges = [ [0,3],[1,3],[2,3],[4,3],[5,4] ]
    # 출력 : [3,4]
    print("출력값1 : ", str(findMinHeightTrees(4, [ [1,0],[1,2],[1,3] ])))
    print("기대값  : [1]")
    print("===================")
    print("출력값2 : ", str(findMinHeightTrees(6,  [ [0,3],[1,3],[2,3],[4,3],[5,4] ] )))
    print("기대값  : [3,4]")
