### 페어 스왑.
- 연결 리스트를 입력받아 페어 단위로 스왑하라.
```
def swapPairs2(head: ListNode) -> ListNode:
    root = prev = ListNode(None)
    prev.next = head

    while head and head.next:
        b = head.next

        head.next = b.next
        b.next = head
        prev.next = b
        head = head.next
        prev = prev.next.next
    return root.next

```
- 재귀 구조로 스왑
```
def swapPairs3(head: ListNode) -> ListNode:

    if head and head.next:
        p = head.next  # p는 두 번째 노드
        head.next = swapPairs3(p.next)
        p.next = head
        return p
    return head
```

### 역순 연결 리스트
- 연결 리스트를 홀수번째 노드 다음에 짝수번째 노드가 오도록 재구성하라. 공간복잡도 O(1), 시간복잡도 O(n)에 풀이하라.
```
def oddEvenList(head: ListNode) -> ListNode:

    if head is None:
        return None

    odd = head # 홀수 리스트
    even = head.next # 짝수 리스트
    even_head = head.next

    while even and even.next :
        odd.next, even.next = odd.next.next, even.next.next
        odd, even = odd.next, even.next

    odd.next = even_head
    return head
```

### 펠린 드롬 : 런너 기법
- 연결리스트가 펠린드롬 구조인지 판별하라.
```
def isPalindrome(head: ListNode) -> bool:
    rev = None
    slow = fast = head

    while fast and fast.next:
        fast = fast.next.next
        rev, rev.next , slow = slow, rev, slow.next

    if fast:
        slow = slow.next

    while rev and rev.val == slow.val:
        slow, rev = slow.next, rev.next
    return not rev
```

### 역순 연결 리스트
- 연결 리스트를 뒤집어라 
- 재귀 구조로 뒤집기 
```
def reverseList(head: ListNode) -> ListNode:
    def reverse(node: ListNode, prev: ListNode = None):
        if not node:
            return prev
        next_node = node.next
        node.next = prev
        return reverse(next_node, node)
    return reverse(head)
```

- 반복 구조로 뒤집기 
```
def reverseList2(head: ListNode) -> ListNode:
    node, prev = head, None
    while node:
        next, node.next = node.next, prev
        prev, node = node, next
    return prev
```