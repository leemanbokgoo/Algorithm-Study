### 배열의 양 끝에서 시작하여 중앙으로 이동하는 템플릿.

```
def opposite_end_two_pointers_template(data: List[Any]) -> Tuple[Any, Any]:
    # 입력 배열 (대부분의 경우 정렬된 배열을 가정)
    # 문제에 따른 최종 결과 (예: 두 포인터의 인덱스, 합계 등)
    
    # 1. 포인터 초기화
    # left: 배열의 시작 인덱스 (왼쪽 포인터)
    left = 0
    # right: 배열의 끝 인덱스 (오른쪽 포인터)
    right = len(data) - 1
    
    # 최종 결과 또는 임시 상태를 저장할 변수 초기화
    max_result = 0  # 문제에 따라 None, [] 등으로 초기화
    
    # 2. 포인터 교차 전까지 반복
    # left < right: 포인터가 서로 만나기 직전까지 (두 요소 필요)
    # left <= right: 포인터가 만나거나 교차할 때까지 (한 요소만 필요할 때)
    while left < right:
        
        # [A] 현재 값들을 사용하여 필요한 계산 수행
        current_value_1 = data[left]
        current_value_2 = data[right]
        # 예: current_sum = current_value_1 + current_value_2
        
        # 3. 포인터 이동 결정 로직
        # 현재 값들을 기반으로 어떤 포인터를 움직일지 결정합니다.
        
        # 예: if current_sum == target:
        if current_value_1 == current_value_2: # 임시 조건
            
            # 최종 결과 저장
            # max_result = (left, right)
            
            # 목표를 찾았으므로 양쪽 포인터를 모두 이동시키거나 (다음 해답 찾기),
            # break로 루프를 종료합니다.
            left += 1
            right -= 1
            # break # 첫 번째 해답만 필요할 경우
            
        # 왼쪽 값을 증가시켜야 할 때 (주로 정렬된 배열에서 합이 작을 때)
        # 예: elif current_sum < target:
        elif current_value_1 < current_value_2: # 임시 조건
            left += 1 # 왼쪽 포인터를 오른쪽으로 이동시켜 값을 키웁니다.
            
        # 오른쪽 값을 감소시켜야 할 때 (주로 정렬된 배열에서 합이 클 때)
        # 예: else: (current_sum > target)
        else:
            right -= 1 # 오른쪽 포인터를 왼쪽으로 이동시켜 값을 줄입니다.

    return max_result # 최종 결과 반환 (문제에 맞게 수정)
```
-  배열을 입력받아 합으로 0을 만들 수 있는 3개의 요소를 출력하라.
```
from typing import List

def two_pointers(nums: List[int], target: int) -> List[List[int]]:
    result = []
    
    # 1. 필수: 배열 정렬 (O(N log N))
    nums.sort() 
    
    # 2. 외부 루프 (Outer Loop)
    # i는 '고정된' 첫 번째 요소의 인덱스. 
    for i in range(len(nums) - 2):
        
        # 2-1. 중복된 시작 요소 건너뛰기
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        # 3. 투 포인터 설정
        left, right = i + 1, len(nums) - 1

        # 4. 투 포인터 탐색
        while left < right:
            
            # 현재 윈도우 합계 또는 값 계산
            current_sum = nums[i] + nums[left] + nums[right] 
            
            # 4-1. 조건에 따라 포인터 이동
            if current_sum < target:
                # 합이 작으면 left를 오른쪽으로 이동 (값을 키움)
                left += 1
            elif current_sum > target:
                # 합이 크면 right를 왼쪽으로 이동 (값을 줄임)
                right -= 1
            else:
                # 4-2. 조건 만족 (current_sum == target)
                result.append([ nums[i], nums[left], nums[right] ])

                # 4-3. 중복 처리 (Two Pointers의 핵심)
                # left와 right를 이동시키기 전, 중복된 값 건너뛰기
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1

                # 다음 조합을 찾기 위해 포인터 이동
                left += 1
                right -= 1

    return result
```

- 높이를 입력받아 비 온후 얼마나 많은 물이 쌓일 수 있는 지 계산하라

```
def trap(height : List[int]) -> int :
    if not height :
        return 0

    volume = 0 # 총 물의 양
    left_index, right_index = 0, len(height) -1
    left_max , right_max = height[left_index] , height[right_index]

    # 투 포인터가 만나기전까지 반복
    # 양쪽에서 안쪽으로 한 칸씩 좁혀 들어가기 떄문에 왼쪽 포인터가 오른쪽으로 오른쪽 포인터가 왼쪽으로 가다보면 만나는 지점이 생김. 그 지점 전까지 반복.
    while left_index < right_index :

        # 현재 위치(left, right)의  left_max와 right_max를 갱신(이전 최대와 현재 높이 중 큰 값).
        left_max , right_max = max(height[left_index], left_max), max(height[right_index],right_max)

        # max값이 더 작은 쪽이 기준이 됨. 왜냐하면 [3, 0, 2] 길의 막대가 두개 있다고 하면 2만큼의 물의 양을 넣을 수 있기때문에.
        if left_max <= right_max:
            volume += left_max - height[left_index]
            left_index += 1
        else:
            volume += right_max - height[right_index]
            right_index -= 1
    return volume
```

### 가장 긴 펠린드롬 부분 문자열
- 가장 긴 펠림드롬 부분 문자열을 출력하라.
```
def longestPalindrome(s: str) -> str:

    def expand(left: int, right: int) -> str:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            # 오른쪽 포인터를 오른쪽(뒤)쪽으로 이동
            right += 1
        return s[left + 1:right]

    if len(s) < 2 or s == s[::-1]:
        return s

    result = ''

    for i in range(len(s) - 1):
        result = max(result,
                     expand(i, i + 1),
                     expand(i, i + 2),
                     key=len) 
    return result
```

### 문자열 뒤집기 
- 투포인터를 이용한 스왑
```
def reverseString(self, s: List[str]) -> None:
    left , right = 0, len(s)-1 # 양 끝 인덱스
    while left < right : #  두 포인터가 교차하기 전까지 반복
        s[left] , s[right] = s[right] , s[left] 
        left += 1  
        right -= 1 
```