### 슬라이딩 윈도우 기본 템플릿 ( 투 포인터 )
- 슬라이딩 윈도우 알고리즘의 O(N)의 시간 복잡도를 가지게 하기 위한 템플릿.
- 합계가 max_sum 이하인 가장 긴 부분 배열의 길이를 찾는다.

```
def sliding_window(data):
    # 1. 초기화
    left = 0 # 윈도우 왼쪽 포인터 
    max_length = 0
    
    # 윈도우 내부 상태 추적 변수 
    current_sum = 0
    
    # 2. 윈도우 확장: right 포인터 이동
    for right in range(len(data)):
        
        # 현재 가리키고 있는 right 포인터의 값을 로직에 맞게 처리
        # 지금은 예시가 윈도우 안의 배열의 값을 더 해야함으로 더함.
        current_sum += data[right]
        
        # 3. 윈도우 축소: 조건이 유효하지 않을 때 (합계가 max_sum을 초과할 때)
        # 윈도우가 조건을 만족할 때까지 left를 이동
        while current_sum > max_sum:
            # 현재 윈도우의 값을 빼고 
            current_sum -= data[left]
            # 왼쪽 포인터를 오른쪽으로 이동시켜 윈도우 축소
            left += 1
            
        # 4. 결과 업데이트: 현재 유효한 윈도우 (data[left:right+1])의 길이 갱신
        # while 루프를 벗어났으므로 현재 윈도우는 유효한 상태임
        # 지금은 예시로는 유효한 배열의 길이를 찾아내는 것이나 문제에 따라 여기에 들어올 코드가 다름.
        current_length = right - left + 1
        max_length = max(max_length, current_length)
        
    return max_length
```

- 예시 코드 : 중복 문자가 없는 가장 긴 부분 문자열(subString)의 길이를 리턴하라.
- 위의 범용적 템플릿의 경우 while문으로 윈도우를 '한 칸씩' 밀어내는데 밑의 코드는 if문으로 윈도우 시작점(start)를 점프시킴.

```
def lengthOfLongestSubstring(s: str) -> int:
    used = {} # 문자(key)와 그 문자가 마지막으로 나타난 인덱스(value)를 저장
    max_length = 0
    start = 0

    for index, char in enumerate(s):
        if char in used and start <= used[char]:
            start = used[char] + 1
        else:
            max_length = max(max_length, index - start + 1)
        used[char] = index

    return max_length
```
